
CAV-CNC.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800200  00800200  00008176  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00008102  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000d10  00800200  00800200  00008176  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00008176  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000081a8  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000006b8  00000000  00000000  000081e8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000a9d4  00000000  00000000  000088a0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00002af0  00000000  00000000  00013274  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000622c  00000000  00000000  00015d64  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001524  00000000  00000000  0001bf90  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000205c  00000000  00000000  0001d4b4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000635b  00000000  00000000  0001f510  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000650  00000000  00000000  0002586b  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	87 c2       	rjmp	.+1294   	; 0x510 <__ctors_end>
       2:	00 00       	nop
       4:	98 c2       	rjmp	.+1328   	; 0x536 <__bad_interrupt>
       6:	00 00       	nop
       8:	96 c2       	rjmp	.+1324   	; 0x536 <__bad_interrupt>
       a:	00 00       	nop
       c:	94 c2       	rjmp	.+1320   	; 0x536 <__bad_interrupt>
       e:	00 00       	nop
      10:	92 c2       	rjmp	.+1316   	; 0x536 <__bad_interrupt>
      12:	00 00       	nop
      14:	90 c2       	rjmp	.+1312   	; 0x536 <__bad_interrupt>
      16:	00 00       	nop
      18:	8e c2       	rjmp	.+1308   	; 0x536 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	8c c2       	rjmp	.+1304   	; 0x536 <__bad_interrupt>
      1e:	00 00       	nop
      20:	8a c2       	rjmp	.+1300   	; 0x536 <__bad_interrupt>
      22:	00 00       	nop
      24:	0c 94 f1 2e 	jmp	0x5de2	; 0x5de2 <__vector_9>
      28:	86 c2       	rjmp	.+1292   	; 0x536 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	0c 94 5c 38 	jmp	0x70b8	; 0x70b8 <__vector_11>
      30:	82 c2       	rjmp	.+1284   	; 0x536 <__bad_interrupt>
      32:	00 00       	nop
      34:	80 c2       	rjmp	.+1280   	; 0x536 <__bad_interrupt>
      36:	00 00       	nop
      38:	7e c2       	rjmp	.+1276   	; 0x536 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	7c c2       	rjmp	.+1272   	; 0x536 <__bad_interrupt>
      3e:	00 00       	nop
      40:	7a c2       	rjmp	.+1268   	; 0x536 <__bad_interrupt>
      42:	00 00       	nop
      44:	0c 94 c7 18 	jmp	0x318e	; 0x318e <__vector_17>
      48:	76 c2       	rjmp	.+1260   	; 0x536 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	74 c2       	rjmp	.+1256   	; 0x536 <__bad_interrupt>
      4e:	00 00       	nop
      50:	72 c2       	rjmp	.+1252   	; 0x536 <__bad_interrupt>
      52:	00 00       	nop
      54:	70 c2       	rjmp	.+1248   	; 0x536 <__bad_interrupt>
      56:	00 00       	nop
      58:	6e c2       	rjmp	.+1244   	; 0x536 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	0c 94 c5 1a 	jmp	0x358a	; 0x358a <__vector_23>
      60:	6a c2       	rjmp	.+1236   	; 0x536 <__bad_interrupt>
      62:	00 00       	nop
      64:	0c 94 44 14 	jmp	0x2888	; 0x2888 <__vector_25>
      68:	0c 94 08 14 	jmp	0x2810	; 0x2810 <__vector_26>
      6c:	64 c2       	rjmp	.+1224   	; 0x536 <__bad_interrupt>
      6e:	00 00       	nop
      70:	62 c2       	rjmp	.+1220   	; 0x536 <__bad_interrupt>
      72:	00 00       	nop
      74:	60 c2       	rjmp	.+1216   	; 0x536 <__bad_interrupt>
      76:	00 00       	nop
      78:	5e c2       	rjmp	.+1212   	; 0x536 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	5c c2       	rjmp	.+1208   	; 0x536 <__bad_interrupt>
      7e:	00 00       	nop
      80:	5a c2       	rjmp	.+1204   	; 0x536 <__bad_interrupt>
      82:	00 00       	nop
      84:	58 c2       	rjmp	.+1200   	; 0x536 <__bad_interrupt>
      86:	00 00       	nop
      88:	56 c2       	rjmp	.+1196   	; 0x536 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	0c 94 e2 3b 	jmp	0x77c4	; 0x77c4 <__vector_35>
      90:	52 c2       	rjmp	.+1188   	; 0x536 <__bad_interrupt>
      92:	00 00       	nop
      94:	50 c2       	rjmp	.+1184   	; 0x536 <__bad_interrupt>
      96:	00 00       	nop
      98:	4e c2       	rjmp	.+1180   	; 0x536 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	4c c2       	rjmp	.+1176   	; 0x536 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	4a c2       	rjmp	.+1172   	; 0x536 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	48 c2       	rjmp	.+1168   	; 0x536 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	46 c2       	rjmp	.+1164   	; 0x536 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	44 c2       	rjmp	.+1160   	; 0x536 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	42 c2       	rjmp	.+1156   	; 0x536 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	40 c2       	rjmp	.+1152   	; 0x536 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	3e c2       	rjmp	.+1148   	; 0x536 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	3c c2       	rjmp	.+1144   	; 0x536 <__bad_interrupt>
      be:	00 00       	nop
      c0:	3a c2       	rjmp	.+1140   	; 0x536 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	38 c2       	rjmp	.+1136   	; 0x536 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	36 c2       	rjmp	.+1132   	; 0x536 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	34 c2       	rjmp	.+1128   	; 0x536 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	32 c2       	rjmp	.+1124   	; 0x536 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	30 c2       	rjmp	.+1120   	; 0x536 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	2e c2       	rjmp	.+1116   	; 0x536 <__bad_interrupt>
      da:	00 00       	nop
      dc:	2c c2       	rjmp	.+1112   	; 0x536 <__bad_interrupt>
      de:	00 00       	nop
      e0:	2a c2       	rjmp	.+1108   	; 0x536 <__bad_interrupt>
      e2:	00 00       	nop
      e4:	a4 07       	cpc	r26, r20
      e6:	a4 07       	cpc	r26, r20
      e8:	a4 07       	cpc	r26, r20
      ea:	a4 07       	cpc	r26, r20
      ec:	8a 07       	cpc	r24, r26
      ee:	b7 11       	cpse	r27, r7
      f0:	b7 11       	cpse	r27, r7
      f2:	b7 11       	cpse	r27, r7
      f4:	b7 11       	cpse	r27, r7
      f6:	b7 11       	cpse	r27, r7
      f8:	81 07       	cpc	r24, r17
      fa:	b7 11       	cpse	r27, r7
      fc:	b7 11       	cpse	r27, r7
      fe:	b7 11       	cpse	r27, r7
     100:	b7 11       	cpse	r27, r7
     102:	b7 11       	cpse	r27, r7
     104:	b7 11       	cpse	r27, r7
     106:	d1 07       	cpc	r29, r17
     108:	d1 07       	cpc	r29, r17
     10a:	d1 07       	cpc	r29, r17
     10c:	f4 07       	cpc	r31, r20
     10e:	f4 07       	cpc	r31, r20
     110:	b7 11       	cpse	r27, r7
     112:	b7 11       	cpse	r27, r7
     114:	b7 11       	cpse	r27, r7
     116:	b7 11       	cpse	r27, r7
     118:	b7 11       	cpse	r27, r7
     11a:	b7 11       	cpse	r27, r7
     11c:	81 07       	cpc	r24, r17
     11e:	b7 11       	cpse	r27, r7
     120:	81 07       	cpc	r24, r17
     122:	b7 11       	cpse	r27, r7
     124:	b7 11       	cpse	r27, r7
     126:	b7 11       	cpse	r27, r7
     128:	b7 11       	cpse	r27, r7
     12a:	b7 11       	cpse	r27, r7
     12c:	b7 11       	cpse	r27, r7
     12e:	b7 11       	cpse	r27, r7
     130:	a4 07       	cpc	r26, r20
     132:	b7 11       	cpse	r27, r7
     134:	24 08       	sbc	r2, r4
     136:	b7 11       	cpse	r27, r7
     138:	b7 11       	cpse	r27, r7
     13a:	fa 07       	cpc	r31, r26
     13c:	b7 11       	cpse	r27, r7
     13e:	b7 11       	cpse	r27, r7
     140:	b7 11       	cpse	r27, r7
     142:	b7 11       	cpse	r27, r7
     144:	b7 11       	cpse	r27, r7
     146:	fa 07       	cpc	r31, r26
     148:	b7 11       	cpse	r27, r7
     14a:	b7 11       	cpse	r27, r7
     14c:	b7 11       	cpse	r27, r7
     14e:	8a 07       	cpc	r24, r26
     150:	17 08       	sbc	r1, r7
     152:	17 08       	sbc	r1, r7
     154:	17 08       	sbc	r1, r7
     156:	17 08       	sbc	r1, r7
     158:	17 08       	sbc	r1, r7
     15a:	17 08       	sbc	r1, r7
     15c:	b7 11       	cpse	r27, r7
     15e:	1d 08       	sbc	r1, r13
     160:	b7 11       	cpse	r27, r7
     162:	b7 11       	cpse	r27, r7
     164:	b7 11       	cpse	r27, r7
     166:	b7 11       	cpse	r27, r7
     168:	b7 11       	cpse	r27, r7
     16a:	b7 11       	cpse	r27, r7
     16c:	b7 11       	cpse	r27, r7
     16e:	b7 11       	cpse	r27, r7
     170:	b7 11       	cpse	r27, r7
     172:	b7 11       	cpse	r27, r7
     174:	b7 11       	cpse	r27, r7
     176:	b7 11       	cpse	r27, r7
     178:	b7 11       	cpse	r27, r7
     17a:	b7 11       	cpse	r27, r7
     17c:	b7 11       	cpse	r27, r7
     17e:	b7 11       	cpse	r27, r7
     180:	b7 11       	cpse	r27, r7
     182:	b7 11       	cpse	r27, r7
     184:	aa 07       	cpc	r26, r26
     186:	b7 11       	cpse	r27, r7
     188:	b7 11       	cpse	r27, r7
     18a:	b7 11       	cpse	r27, r7
     18c:	b7 11       	cpse	r27, r7
     18e:	b7 11       	cpse	r27, r7
     190:	b7 11       	cpse	r27, r7
     192:	b7 11       	cpse	r27, r7
     194:	b7 11       	cpse	r27, r7
     196:	b7 11       	cpse	r27, r7
     198:	d7 07       	cpc	r29, r23
     19a:	d7 07       	cpc	r29, r23
     19c:	81 07       	cpc	r24, r17
     19e:	ee 07       	cpc	r30, r30
     1a0:	ee 07       	cpc	r30, r30
     1a2:	50 08       	sbc	r5, r0
     1a4:	50 08       	sbc	r5, r0
     1a6:	50 08       	sbc	r5, r0
     1a8:	5f 08       	sbc	r5, r15
     1aa:	5f 08       	sbc	r5, r15
     1ac:	5f 08       	sbc	r5, r15
     1ae:	d1 11       	cpse	r29, r1
     1b0:	76 08       	sbc	r7, r6
     1b2:	76 08       	sbc	r7, r6
     1b4:	76 08       	sbc	r7, r6
     1b6:	d1 11       	cpse	r29, r1
     1b8:	d1 11       	cpse	r29, r1
     1ba:	d1 11       	cpse	r29, r1
     1bc:	d1 11       	cpse	r29, r1
     1be:	d1 11       	cpse	r29, r1
     1c0:	d1 11       	cpse	r29, r1
     1c2:	d1 11       	cpse	r29, r1
     1c4:	d1 11       	cpse	r29, r1
     1c6:	d1 11       	cpse	r29, r1
     1c8:	d1 11       	cpse	r29, r1
     1ca:	d1 11       	cpse	r29, r1
     1cc:	d1 11       	cpse	r29, r1
     1ce:	d1 11       	cpse	r29, r1
     1d0:	d1 11       	cpse	r29, r1
     1d2:	d1 11       	cpse	r29, r1
     1d4:	d1 11       	cpse	r29, r1
     1d6:	d1 11       	cpse	r29, r1
     1d8:	d1 11       	cpse	r29, r1
     1da:	d1 11       	cpse	r29, r1
     1dc:	d1 11       	cpse	r29, r1
     1de:	50 08       	sbc	r5, r0
     1e0:	b7 08       	sbc	r11, r7
     1e2:	d5 11       	cpse	r29, r5
     1e4:	d5 11       	cpse	r29, r5
     1e6:	c1 08       	sbc	r12, r1
     1e8:	ce 08       	sbc	r12, r14
     1ea:	db 08       	sbc	r13, r11
     1ec:	e8 08       	sbc	r14, r8
     1ee:	d5 11       	cpse	r29, r5
     1f0:	ec 08       	sbc	r14, r12
     1f2:	d5 11       	cpse	r29, r5
     1f4:	fa 08       	sbc	r15, r10
     1f6:	d5 11       	cpse	r29, r5
     1f8:	04 09       	sbc	r16, r4
     1fa:	0e 09       	sbc	r16, r14
     1fc:	18 09       	sbc	r17, r8
     1fe:	d5 11       	cpse	r29, r5
     200:	d5 11       	cpse	r29, r5
     202:	d5 11       	cpse	r29, r5
     204:	28 09       	sbc	r18, r8
     206:	35 09       	sbc	r19, r5
     208:	42 09       	sbc	r20, r2
     20a:	85 14       	cp	r8, r5
     20c:	89 14       	cp	r8, r9
     20e:	91 14       	cp	r9, r1
     210:	e8 14       	cp	r14, r8
     212:	e8 14       	cp	r14, r8
     214:	e8 14       	cp	r14, r8
     216:	e8 14       	cp	r14, r8
     218:	e8 14       	cp	r14, r8
     21a:	e8 14       	cp	r14, r8
     21c:	e8 14       	cp	r14, r8
     21e:	e8 14       	cp	r14, r8
     220:	e8 14       	cp	r14, r8
     222:	9a 14       	cp	r9, r10
     224:	9e 14       	cp	r9, r14
     226:	a2 14       	cp	r10, r2
     228:	a6 14       	cp	r10, r6
     22a:	aa 14       	cp	r10, r10
     22c:	ae 14       	cp	r10, r14
     22e:	b2 14       	cp	r11, r2
     230:	b6 14       	cp	r11, r6
     232:	e8 14       	cp	r14, r8
     234:	ba 14       	cp	r11, r10
     236:	be 14       	cp	r11, r14
     238:	c2 14       	cp	r12, r2
     23a:	c6 14       	cp	r12, r6
     23c:	ca 14       	cp	r12, r10
     23e:	ce 14       	cp	r12, r14
     240:	e8 14       	cp	r14, r8
     242:	d2 14       	cp	r13, r2
     244:	d6 14       	cp	r13, r6
     246:	d7 25       	eor	r29, r7
     248:	dd 25       	eor	r29, r13
     24a:	e0 25       	eor	r30, r0
     24c:	e5 25       	eor	r30, r5
     24e:	ea 25       	eor	r30, r10
     250:	f8 25       	eor	r31, r8
     252:	06 26       	eor	r0, r22
     254:	bb 26       	eor	r11, r27
     256:	bb 26       	eor	r11, r27
     258:	bb 26       	eor	r11, r27
     25a:	17 26       	eor	r1, r23
     25c:	1a 26       	eor	r1, r26
     25e:	23 26       	eor	r2, r19
     260:	2c 26       	eor	r2, r28
     262:	bb 26       	eor	r11, r27
     264:	bb 26       	eor	r11, r27
     266:	bb 26       	eor	r11, r27
     268:	bb 26       	eor	r11, r27
     26a:	bb 26       	eor	r11, r27
     26c:	bb 26       	eor	r11, r27
     26e:	3c 26       	eor	r3, r28
     270:	4c 26       	eor	r4, r28
     272:	5c 26       	eor	r5, r28
     274:	6a 26       	eor	r6, r26
     276:	6d 26       	eor	r6, r29
     278:	76 26       	eor	r7, r22
     27a:	7f 26       	eor	r7, r31
     27c:	86 26       	eor	r8, r22
     27e:	bb 26       	eor	r11, r27
     280:	bb 26       	eor	r11, r27
     282:	8f 26       	eor	r8, r31
     284:	9a 26       	eor	r9, r26
     286:	a5 26       	eor	r10, r21
     288:	a7 33       	cpi	r26, 0x37	; 55
     28a:	ab 33       	cpi	r26, 0x3B	; 59
     28c:	af 33       	cpi	r26, 0x3F	; 63
     28e:	b3 33       	cpi	r27, 0x33	; 51
     290:	b7 33       	cpi	r27, 0x37	; 55
     292:	bb 33       	cpi	r27, 0x3B	; 59
     294:	bf 33       	cpi	r27, 0x3F	; 63
     296:	c3 33       	cpi	r28, 0x33	; 51
     298:	c7 33       	cpi	r28, 0x37	; 55
     29a:	cb 33       	cpi	r28, 0x3B	; 59
     29c:	cf 33       	cpi	r28, 0x3F	; 63
     29e:	08 4a       	sbci	r16, 0xA8	; 168
     2a0:	d7 3b       	cpi	r29, 0xB7	; 183
     2a2:	3b ce       	rjmp	.-906    	; 0xffffff1a <__eeprom_end+0xff7eff1a>
     2a4:	01 6e       	ori	r16, 0xE1	; 225
     2a6:	84 bc       	out	0x24, r8	; 36
     2a8:	bf fd       	.word	0xfdbf	; ????
     2aa:	c1 2f       	mov	r28, r17
     2ac:	3d 6c       	ori	r19, 0xCD	; 205
     2ae:	74 31       	cpi	r23, 0x14	; 20
     2b0:	9a bd       	out	0x2a, r25	; 42
     2b2:	56 83       	std	Z+6, r21	; 0x06
     2b4:	3d da       	rcall	.-2950   	; 0xfffff730 <__eeprom_end+0xff7ef730>
     2b6:	3d 00       	.word	0x003d	; ????
     2b8:	c7 7f       	andi	r28, 0xF7	; 247
     2ba:	11 be       	out	0x31, r1	; 49
     2bc:	d9 e4       	ldi	r29, 0x49	; 73
     2be:	bb 4c       	sbci	r27, 0xCB	; 203
     2c0:	3e 91       	ld	r19, -X
     2c2:	6b aa       	std	Y+51, r6	; 0x33
     2c4:	aa be       	out	0x3a, r10	; 58
     2c6:	00 00       	nop
     2c8:	00 80       	ld	r0, Z
     2ca:	3f 05       	cpc	r19, r15
     2cc:	a8 4c       	sbci	r26, 0xC8	; 200
     2ce:	cd b2       	in	r12, 0x1d	; 29
     2d0:	d4 4e       	sbci	r29, 0xE4	; 228
     2d2:	b9 38       	cpi	r27, 0x89	; 137
     2d4:	36 a9       	ldd	r19, Z+54	; 0x36
     2d6:	02 0c       	add	r0, r2
     2d8:	50 b9       	out	0x00, r21	; 0
     2da:	91 86       	std	Z+9, r9	; 0x09
     2dc:	88 08       	sbc	r8, r8
     2de:	3c a6       	std	Y+44, r3	; 0x2c
     2e0:	aa aa       	std	Y+50, r10	; 0x32
     2e2:	2a be       	out	0x3a, r2	; 58
     2e4:	00 00       	nop
     2e6:	00 80       	ld	r0, Z
     2e8:	3f 00       	.word	0x003f	; ????

000002ea <__trampolines_end>:
     2ea:	00 00       	nop
     2ec:	7a 43       	sbci	r23, 0x3A	; 58
     2ee:	00 00       	nop
     2f0:	7a 43       	sbci	r23, 0x3A	; 58
     2f2:	00 00       	nop
     2f4:	7a 43       	sbci	r23, 0x3A	; 58
     2f6:	00 00       	nop
     2f8:	fa 43       	sbci	r31, 0x3A	; 58
     2fa:	00 00       	nop
     2fc:	fa 43       	sbci	r31, 0x3A	; 58
     2fe:	00 00       	nop
     300:	fa 43       	sbci	r31, 0x3A	; 58
     302:	00 a0       	ldd	r0, Z+32	; 0x20
     304:	0c 47       	sbci	r16, 0x7C	; 124
     306:	00 a0       	ldd	r0, Z+32	; 0x20
     308:	0c 47       	sbci	r16, 0x7C	; 124
     30a:	00 a0       	ldd	r0, Z+32	; 0x20
     30c:	0c 47       	sbci	r16, 0x7C	; 124
     30e:	00 00       	nop
     310:	48 c3       	rjmp	.+1680   	; 0x9a2 <mc_arc+0x352>
     312:	00 00       	nop
     314:	48 c3       	rjmp	.+1680   	; 0x9a6 <mc_arc+0x356>
     316:	00 00       	nop
     318:	48 c3       	rjmp	.+1680   	; 0x9aa <mc_arc+0x35a>
     31a:	0a 00       	.word	0x000a	; ????
     31c:	00 19       	sub	r16, r0
     31e:	01 0a       	sbc	r0, r17
     320:	d7 23       	and	r29, r23
     322:	3c 6f       	ori	r19, 0xFC	; 252
     324:	12 03       	mulsu	r17, r18
     326:	3b 00       	.word	0x003b	; ????
     328:	00 7a       	andi	r16, 0xA0	; 160
     32a:	44 00       	.word	0x0044	; ????
     32c:	00 00       	nop
     32e:	00 00       	nop
     330:	00 00       	nop
     332:	00 c8       	rjmp	.-4096   	; 0xfffff334 <__eeprom_end+0xff7ef334>
     334:	41 00       	.word	0x0041	; ????
     336:	00 fa       	bst	r0, 0
     338:	43 fa       	bst	r4, 3
     33a:	00 00       	nop
     33c:	00 80       	ld	r0, Z
     33e:	3f 7c       	Address 0x0000033e is out of bounds.
.word	0xffff	; ????

0000033f <__c.2779>:
     33f:	7c 41 3a 00                                         |A:.

00000343 <__c.2775>:
     343:	7c 4f 76 3a 00                                      |Ov:.

00000348 <__c.2773>:
     348:	7c 57 43 4f 3a 00                                   |WCO:.

0000034e <__c.2771>:
     34e:	7c 50 6e 3a 00                                      |Pn:.

00000353 <__c.2766>:
     353:	7c 46 53 3a 00                                      |FS:.

00000358 <__c.2764>:
     358:	7c 4c 6e 3a 00                                      |Ln:.

0000035d <__c.2760>:
     35d:	7c 42 66 3a 00                                      |Bf:.

00000362 <__c.2758>:
     362:	7c 57 50 6f 73 3a 00                                |WPos:.

00000369 <__c.2756>:
     369:	7c 4d 50 6f 73 3a 00                                |MPos:.

00000370 <__c.2750>:
     370:	53 6c 65 65 70 00                                   Sleep.

00000376 <__c.2747>:
     376:	44 6f 6f 72 3a 00                                   Door:.

0000037c <__c.2744>:
     37c:	43 68 65 63 6b 00                                   Check.

00000382 <__c.2741>:
     382:	41 6c 61 72 6d 00                                   Alarm.

00000388 <__c.2738>:
     388:	48 6f 6d 65 00                                      Home.

0000038d <__c.2735>:
     38d:	4a 6f 67 00                                         Jog.

00000391 <__c.2732>:
     391:	48 6f 6c 64 3a 00                                   Hold:.

00000397 <__c.2729>:
     397:	52 75 6e 00                                         Run.

0000039b <__c.2725>:
     39b:	49 64 6c 65 00                                      Idle.

000003a0 <__c.2712>:
     3a0:	5b 4f 50 54 3a 00                                   [OPT:.

000003a6 <__c.2710>:
     3a6:	5b 56 45 52 3a 31 2e 31 67 2e 32 30 31 38 30 38     [VER:1.1g.201808
     3b6:	31 33 2e 4d 65 67 61 3a 00                          13.Mega:.

000003bf <__c.2701>:
     3bf:	24 4e 00                                            $N.

000003c2 <__c.2555>:
     3c2:	20 4d 00                                             M.

000003c5 <__c.2551>:
     3c5:	20 47 00                                             G.

000003c8 <__c.2695>:
     3c8:	20 53 00                                             S.

000003cb <__c.2693>:
     3cb:	20 46 00                                             F.

000003ce <__c.2691>:
     3ce:	20 54 00                                             T.

000003d1 <__c.2681>:
     3d1:	33 38 2e 00                                         38..

000003d5 <__c.2679>:
     3d5:	5b 47 43 3a 47 00                                   [GC:G.

000003db <__c.2675>:
     3db:	5b 54 4c 4f 3a 00                                   [TLO:.

000003e1 <__c.2673>:
     3e1:	5b 47 39 32 3a 00                                   [G92:.

000003e7 <__c.2667>:
     3e7:	33 30 00                                            30.

000003ea <__c.2663>:
     3ea:	32 38 00                                            28.

000003ed <__c.2660>:
     3ed:	5b 47 00                                            [G.

000003f0 <__c.2653>:
     3f0:	5b 50 52 42 3a 00                                   [PRB:.

000003f6 <__c.2633>:
     3f6:	5b 48 4c 50 3a 24 24 20 24 23 20 24 47 20 24 49     [HLP:$$ $# $G $I
     406:	20 24 4e 20 24 78 3d 76 61 6c 20 24 4e 78 3d 6c      $N $x=val $Nx=l
     416:	69 6e 65 20 24 4a 3d 6c 69 6e 65 20 24 53 4c 50     ine $J=line $SLP
     426:	20 24 43 20 24 58 20 24 48 20 7e 20 21 20 3f 20      $C $X $H ~ ! ? 
     436:	63 74 72 6c 2d 78 5d 0d 0a 00                       ctrl-x]...

00000440 <__c.2629>:
     440:	0d 0a 47 72 62 6c 20 31 2e 31 67 20 5b 27 24 27     ..Grbl 1.1g ['$'
     450:	20 66 6f 72 20 68 65 6c 70 5d 0d 0a 00               for help]...

0000045d <__c.2625>:
     45d:	53 6c 65 65 70 69 6e 67 00                          Sleeping.

00000466 <__c.2622>:
     466:	52 65 73 74 6f 72 69 6e 67 20 73 70 69 6e 64 6c     Restoring spindl
     476:	65 00                                               e.

00000478 <__c.2619>:
     478:	52 65 73 74 6f 72 69 6e 67 20 64 65 66 61 75 6c     Restoring defaul
     488:	74 73 00                                            ts.

0000048b <__c.2616>:
     48b:	50 67 6d 20 45 6e 64 00                             Pgm End.

00000493 <__c.2613>:
     493:	43 68 65 63 6b 20 4c 69 6d 69 74 73 00              Check Limits.

000004a0 <__c.2610>:
     4a0:	43 68 65 63 6b 20 44 6f 6f 72 00                    Check Door.

000004ab <__c.2607>:
     4ab:	44 69 73 61 62 6c 65 64 00                          Disabled.

000004b4 <__c.2604>:
     4b4:	45 6e 61 62 6c 65 64 00                             Enabled.

000004bc <__c.2601>:
     4bc:	43 61 75 74 69 6f 6e 3a 20 55 6e 6c 6f 63 6b 65     Caution: Unlocke
     4cc:	64 00                                               d.

000004ce <__c.2598>:
     4ce:	27 24 48 27 7c 27 24 58 27 20 74 6f 20 75 6e 6c     '$H'|'$X' to unl
     4de:	6f 63 6b 00                                         ock.

000004e2 <__c.2594>:
     4e2:	52 65 73 65 74 20 74 6f 20 63 6f 6e 74 69 6e 75     Reset to continu
     4f2:	65 00                                               e.

000004f4 <__c.2591>:
     4f4:	5b 4d 53 47 3a 00                                   [MSG:.

000004fa <__c.2586>:
     4fa:	41 4c 41 52 4d 3a 00                                ALARM:.

00000501 <__c.2545>:
     501:	0d 0a 00                                            ...

00000504 <__c.2581>:
     504:	65 72 72 6f 72 3a 00                                error:.

0000050b <__c.2577>:
     50b:	6f 6b 0d 0a 00                                      ok...

00000510 <__ctors_end>:
     510:	11 24       	eor	r1, r1
     512:	1f be       	out	0x3f, r1	; 63
     514:	cf ef       	ldi	r28, 0xFF	; 255
     516:	d1 e2       	ldi	r29, 0x21	; 33
     518:	de bf       	out	0x3e, r29	; 62
     51a:	cd bf       	out	0x3d, r28	; 61
     51c:	00 e0       	ldi	r16, 0x00	; 0
     51e:	0c bf       	out	0x3c, r16	; 60

00000520 <__do_clear_bss>:
     520:	2f e0       	ldi	r18, 0x0F	; 15
     522:	a0 e0       	ldi	r26, 0x00	; 0
     524:	b2 e0       	ldi	r27, 0x02	; 2
     526:	01 c0       	rjmp	.+2      	; 0x52a <.do_clear_bss_start>

00000528 <.do_clear_bss_loop>:
     528:	1d 92       	st	X+, r1

0000052a <.do_clear_bss_start>:
     52a:	a0 31       	cpi	r26, 0x10	; 16
     52c:	b2 07       	cpc	r27, r18
     52e:	e1 f7       	brne	.-8      	; 0x528 <.do_clear_bss_loop>
     530:	03 d0       	rcall	.+6      	; 0x538 <main>
     532:	0c 94 7f 40 	jmp	0x80fe	; 0x80fe <_exit>

00000536 <__bad_interrupt>:
     536:	64 cd       	rjmp	.-1336   	; 0x0 <__vectors>

00000538 <main>:


int main(void)
{
  // Initialize system upon power-up.
  serial_init();   // Setup serial baud rate and interrupts
     538:	0e 94 df 13 	call	0x27be	; 0x27be <serial_init>
  settings_init(); // Load Grbl settings from EEPROM
     53c:	0e 94 c7 26 	call	0x4d8e	; 0x4d8e <settings_init>
  stepper_init();  // Configure stepper pins and interrupt timers
     540:	0e 94 42 1b 	call	0x3684	; 0x3684 <stepper_init>
  system_init();   // Configure pinout pins and pin-change interrupt
     544:	0e 94 33 38 	call	0x7066	; 0x7066 <system_init>

  memset(sys_position,0,sizeof(sys_position)); // Clear machine position.
     548:	8c e0       	ldi	r24, 0x0C	; 12
     54a:	e1 e3       	ldi	r30, 0x31	; 49
     54c:	fc e0       	ldi	r31, 0x0C	; 12
     54e:	df 01       	movw	r26, r30
     550:	1d 92       	st	X+, r1
     552:	8a 95       	dec	r24
     554:	e9 f7       	brne	.-6      	; 0x550 <main+0x18>
  sei(); // Enable interrupts
     556:	78 94       	sei
  // Initialize system state.
  #ifdef FORCE_INITIALIZATION_ALARM
    // Force Grbl into an ALARM state upon a power-cycle or hard reset.
    sys.state = STATE_ALARM;
  #else
    sys.state = STATE_IDLE;
     558:	10 92 11 0c 	sts	0x0C11, r1	; 0x800c11 <sys>
  // cycle '$H' or kill alarm locks '$X' will disable the alarm.
  // NOTE: The startup script will run after successful completion of the homing cycle, but
  // not after disabling the alarm locks. Prevents motion startup blocks from crashing into
  // things uncontrollably. Very bad.
  #ifdef HOMING_INIT_LOCK
    if (bit_istrue(settings.flags,BITFLAG_HOMING_ENABLE)) { sys.state = STATE_ALARM; }
     55c:	80 91 fe 0e 	lds	r24, 0x0EFE	; 0x800efe <settings+0x45>
     560:	84 ff       	sbrs	r24, 4
     562:	03 c0       	rjmp	.+6      	; 0x56a <main+0x32>
     564:	81 e0       	ldi	r24, 0x01	; 1
     566:	80 93 11 0c 	sts	0x0C11, r24	; 0x800c11 <sys>
  // Grbl initialization loop upon power-up or a system abort. For the latter, all processes
  // will return to this loop to be cleanly re-initialized.
  for(;;) {

    // Reset system variables.
    uint8_t prior_state = sys.state;
     56a:	e1 e1       	ldi	r30, 0x11	; 17
     56c:	fc e0       	ldi	r31, 0x0C	; 12
     56e:	80 81       	ld	r24, Z
    memset(&sys, 0, sizeof(system_t)); // Clear system struct variable.
     570:	91 e1       	ldi	r25, 0x11	; 17
     572:	df 01       	movw	r26, r30
     574:	1d 92       	st	X+, r1
     576:	9a 95       	dec	r25
     578:	e9 f7       	brne	.-6      	; 0x574 <main+0x3c>
    sys.state = prior_state;
     57a:	80 83       	st	Z, r24
    sys.f_override = DEFAULT_FEED_OVERRIDE;  // Set to 100%
     57c:	84 e6       	ldi	r24, 0x64	; 100
     57e:	87 83       	std	Z+7, r24	; 0x07
    sys.r_override = DEFAULT_RAPID_OVERRIDE; // Set to 100%
     580:	80 87       	std	Z+8, r24	; 0x08
    sys.spindle_speed_ovr = DEFAULT_SPINDLE_SPEED_OVERRIDE; // Set to 100%
     582:	81 87       	std	Z+9, r24	; 0x09
		memset(sys_probe_position,0,sizeof(sys_probe_position)); // Clear probe position.
     584:	8c e0       	ldi	r24, 0x0C	; 12
     586:	e5 e2       	ldi	r30, 0x25	; 37
     588:	fc e0       	ldi	r31, 0x0C	; 12
     58a:	df 01       	movw	r26, r30
     58c:	1d 92       	st	X+, r1
     58e:	8a 95       	dec	r24
     590:	e9 f7       	brne	.-6      	; 0x58c <main+0x54>
    sys_probe_state = 0;
     592:	10 92 24 0c 	sts	0x0C24, r1	; 0x800c24 <sys_probe_state>
    sys_rt_exec_state = 0;
     596:	10 92 23 0c 	sts	0x0C23, r1	; 0x800c23 <sys_rt_exec_state>
    sys_rt_exec_alarm = 0;
     59a:	10 92 3d 0c 	sts	0x0C3D, r1	; 0x800c3d <sys_rt_exec_alarm>
    sys_rt_exec_motion_override = 0;
     59e:	10 92 10 0c 	sts	0x0C10, r1	; 0x800c10 <sys_rt_exec_motion_override>
    sys_rt_exec_accessory_override = 0;
     5a2:	10 92 22 0c 	sts	0x0C22, r1	; 0x800c22 <sys_rt_exec_accessory_override>

    // Reset Grbl primary systems.
    serial_reset_read_buffer(); // Clear serial read buffer
     5a6:	0e 94 fb 14 	call	0x29f6	; 0x29f6 <serial_reset_read_buffer>
    gc_init(); // Set g-code parser to default state
     5aa:	fa d3       	rcall	.+2036   	; 0xda0 <gc_init>
    spindle_init();
     5ac:	0e 94 52 12 	call	0x24a4	; 0x24a4 <spindle_init>
    coolant_init();
     5b0:	0e 94 9c 13 	call	0x2738	; 0x2738 <coolant_init>
    limits_init();
     5b4:	0e 94 b3 2e 	call	0x5d66	; 0x5d66 <limits_init>
    probe_init();
     5b8:	0e 94 f8 32 	call	0x65f0	; 0x65f0 <probe_init>
    sleep_init();
     5bc:	0e 94 d4 3b 	call	0x77a8	; 0x77a8 <sleep_init>
    plan_reset(); // Clear block buffer and planner variables
     5c0:	0e 94 9e 28 	call	0x513c	; 0x513c <plan_reset>
    st_reset(); // Clear stepper subsystem variables.
     5c4:	0e 94 11 1b 	call	0x3622	; 0x3622 <st_reset>

    // Sync cleared gcode and planner positions to current system position.
    plan_sync_position();
     5c8:	0e 94 6f 2c 	call	0x58de	; 0x58de <plan_sync_position>
    gc_sync_position();
     5cc:	fb d3       	rcall	.+2038   	; 0xdc4 <gc_sync_position>

    // Print welcome message. Indicates an initialization has occured at power-up or with a reset.
    report_init_message();
     5ce:	0e 94 d5 33 	call	0x67aa	; 0x67aa <report_init_message>

    // Start Grbl main loop. Processes program inputs and executes them.
    protocol_main_loop();
     5d2:	0e 94 b8 17 	call	0x2f70	; 0x2f70 <protocol_main_loop>
     5d6:	c9 cf       	rjmp	.-110    	; 0x56a <main+0x32>

000005d8 <mc_line>:
// NOTE: This is the primary gateway to the grbl planner. All line motions, including arc line
// segments, must pass through this routine before being passed to the planner. The seperation of
// mc_line and plan_buffer_line is done primarily to place non-planner-type functions from being
// in the planner and to let backlash compensation or canned cycle integration simple and direct.
void mc_line(float *target, plan_line_data_t *pl_data)
{
     5d8:	0f 93       	push	r16
     5da:	1f 93       	push	r17
     5dc:	cf 93       	push	r28
     5de:	df 93       	push	r29
     5e0:	ec 01       	movw	r28, r24
     5e2:	8b 01       	movw	r16, r22
  // If enabled, check for soft limit violations. Placed here all line motions are picked up
  // from everywhere in Grbl.
  if (bit_istrue(settings.flags,BITFLAG_SOFT_LIMIT_ENABLE)) {
     5e4:	80 91 fe 0e 	lds	r24, 0x0EFE	; 0x800efe <settings+0x45>
     5e8:	85 ff       	sbrs	r24, 5
     5ea:	07 c0       	rjmp	.+14     	; 0x5fa <mc_line+0x22>
    // NOTE: Block jog state. Jogging is a special case and soft limits are handled independently.
    if (sys.state != STATE_JOG) { limits_soft_check(target); }
     5ec:	80 91 11 0c 	lds	r24, 0x0C11	; 0x800c11 <sys>
     5f0:	80 32       	cpi	r24, 0x20	; 32
     5f2:	19 f0       	breq	.+6      	; 0x5fa <mc_line+0x22>
     5f4:	ce 01       	movw	r24, r28
     5f6:	0e 94 55 31 	call	0x62aa	; 0x62aa <limits_soft_check>
  }

  // If in check gcode mode, prevent motion by blocking planner. Soft limits still work.
  if (sys.state == STATE_CHECK_MODE) { return; }
     5fa:	80 91 11 0c 	lds	r24, 0x0C11	; 0x800c11 <sys>
     5fe:	82 30       	cpi	r24, 0x02	; 2
     600:	11 f1       	breq	.+68     	; 0x646 <mc_line+0x6e>
  // parser and planner are separate from the system machine positions, this is doable.

  // If the buffer is full: good! That means we are well ahead of the robot.
  // Remain in this loop until there is room in the buffer.
  do {
    protocol_execute_realtime(); // Check for any run-time commands
     602:	0e 94 b2 17 	call	0x2f64	; 0x2f64 <protocol_execute_realtime>
    if (sys.abort) { return; } // Bail, if system abort.
     606:	80 91 12 0c 	lds	r24, 0x0C12	; 0x800c12 <sys+0x1>
     60a:	81 11       	cpse	r24, r1
     60c:	1c c0       	rjmp	.+56     	; 0x646 <mc_line+0x6e>
    if ( plan_check_full_buffer() ) { protocol_auto_cycle_start(); } // Auto-cycle start when buffer is full.
     60e:	0e 94 e9 28 	call	0x51d2	; 0x51d2 <plan_check_full_buffer>
     612:	88 23       	and	r24, r24
     614:	19 f0       	breq	.+6      	; 0x61c <mc_line+0x44>
     616:	0e 94 00 15 	call	0x2a00	; 0x2a00 <protocol_auto_cycle_start>
    else { break; }
  } while (1);
     61a:	f3 cf       	rjmp	.-26     	; 0x602 <mc_line+0x2a>

  // Plan and queue motion into planner buffer
  if (plan_buffer_line(target, pl_data) == PLAN_EMPTY_BLOCK) {
     61c:	b8 01       	movw	r22, r16
     61e:	ce 01       	movw	r24, r28
     620:	0e 94 c6 29 	call	0x538c	; 0x538c <plan_buffer_line>
     624:	81 11       	cpse	r24, r1
     626:	0f c0       	rjmp	.+30     	; 0x646 <mc_line+0x6e>
    if (bit_istrue(settings.flags,BITFLAG_LASER_MODE)) {
     628:	80 91 fe 0e 	lds	r24, 0x0EFE	; 0x800efe <settings+0x45>
     62c:	81 ff       	sbrs	r24, 1
     62e:	0b c0       	rjmp	.+22     	; 0x646 <mc_line+0x6e>
      // Correctly set spindle state, if there is a coincident position passed. Forces a buffer
      // sync while in M3 laser mode only.
      if (pl_data->condition & PL_COND_FLAG_SPINDLE_CW) {
     630:	f8 01       	movw	r30, r16
     632:	84 85       	ldd	r24, Z+12	; 0x0c
     634:	84 ff       	sbrs	r24, 4
     636:	07 c0       	rjmp	.+14     	; 0x646 <mc_line+0x6e>
        spindle_sync(PL_COND_FLAG_SPINDLE_CW, pl_data->spindle_speed);
     638:	44 81       	ldd	r20, Z+4	; 0x04
     63a:	55 81       	ldd	r21, Z+5	; 0x05
     63c:	66 81       	ldd	r22, Z+6	; 0x06
     63e:	77 81       	ldd	r23, Z+7	; 0x07
     640:	80 e1       	ldi	r24, 0x10	; 16
     642:	0e 94 70 13 	call	0x26e0	; 0x26e0 <spindle_sync>
      }
    }
  }
}
     646:	df 91       	pop	r29
     648:	cf 91       	pop	r28
     64a:	1f 91       	pop	r17
     64c:	0f 91       	pop	r16
     64e:	08 95       	ret

00000650 <mc_arc>:
// The arc is approximated by generating a huge number of tiny, linear segments. The chordal tolerance
// of each segment is configured in settings.arc_tolerance, which is defined to be the maximum normal
// distance from segment to the circle when the end points both lie on the circle.
void mc_arc(float *target, plan_line_data_t *pl_data, float *position, float *offset, float radius,
  uint8_t axis_0, uint8_t axis_1, uint8_t axis_linear, uint8_t is_clockwise_arc)
{
     650:	2f 92       	push	r2
     652:	3f 92       	push	r3
     654:	4f 92       	push	r4
     656:	5f 92       	push	r5
     658:	6f 92       	push	r6
     65a:	7f 92       	push	r7
     65c:	8f 92       	push	r8
     65e:	9f 92       	push	r9
     660:	af 92       	push	r10
     662:	bf 92       	push	r11
     664:	cf 92       	push	r12
     666:	df 92       	push	r13
     668:	ef 92       	push	r14
     66a:	ff 92       	push	r15
     66c:	0f 93       	push	r16
     66e:	1f 93       	push	r17
     670:	cf 93       	push	r28
     672:	df 93       	push	r29
     674:	cd b7       	in	r28, 0x3d	; 61
     676:	de b7       	in	r29, 0x3e	; 62
     678:	e4 97       	sbiw	r28, 0x34	; 52
     67a:	0f b6       	in	r0, 0x3f	; 63
     67c:	f8 94       	cli
     67e:	de bf       	out	0x3e, r29	; 62
     680:	0f be       	out	0x3f, r0	; 63
     682:	cd bf       	out	0x3d, r28	; 61
     684:	9c ab       	std	Y+52, r25	; 0x34
     686:	8b ab       	std	Y+51, r24	; 0x33
     688:	78 8b       	std	Y+16, r23	; 0x10
     68a:	6f 87       	std	Y+15, r22	; 0x0f
     68c:	5e 87       	std	Y+14, r21	; 0x0e
     68e:	4d 87       	std	Y+13, r20	; 0x0d
     690:	39 01       	movw	r6, r18
     692:	ed 82       	std	Y+5, r14	; 0x05
     694:	fe 82       	std	Y+6, r15	; 0x06
     696:	0f 83       	std	Y+7, r16	; 0x07
     698:	18 87       	std	Y+8, r17	; 0x08
     69a:	08 2d       	mov	r16, r8
  float center_axis0 = position[axis_0] + offset[axis_0];
     69c:	d1 2c       	mov	r13, r1
     69e:	46 01       	movw	r8, r12
     6a0:	88 0c       	add	r8, r8
     6a2:	99 1c       	adc	r9, r9
     6a4:	88 0c       	add	r8, r8
     6a6:	99 1c       	adc	r9, r9
     6a8:	9a 01       	movw	r18, r20
     6aa:	28 0d       	add	r18, r8
     6ac:	39 1d       	adc	r19, r9
     6ae:	3c 8b       	std	Y+20, r19	; 0x14
     6b0:	2b 8b       	std	Y+19, r18	; 0x13
     6b2:	d9 01       	movw	r26, r18
     6b4:	6d 91       	ld	r22, X+
     6b6:	7d 91       	ld	r23, X+
     6b8:	8d 91       	ld	r24, X+
     6ba:	9c 91       	ld	r25, X
     6bc:	f3 01       	movw	r30, r6
     6be:	e8 0d       	add	r30, r8
     6c0:	f9 1d       	adc	r31, r9
     6c2:	f8 ab       	std	Y+48, r31	; 0x30
     6c4:	ef a7       	std	Y+47, r30	; 0x2f
     6c6:	20 80       	ld	r2, Z
     6c8:	31 80       	ldd	r3, Z+1	; 0x01
     6ca:	42 80       	ldd	r4, Z+2	; 0x02
     6cc:	53 80       	ldd	r5, Z+3	; 0x03
     6ce:	a2 01       	movw	r20, r4
     6d0:	91 01       	movw	r18, r2
     6d2:	0e 94 35 3c 	call	0x786a	; 0x786a <__addsf3>
     6d6:	6d 8b       	std	Y+21, r22	; 0x15
     6d8:	7e 8b       	std	Y+22, r23	; 0x16
     6da:	8f 8b       	std	Y+23, r24	; 0x17
     6dc:	98 8f       	std	Y+24, r25	; 0x18
  float center_axis1 = position[axis_1] + offset[axis_1];
     6de:	b1 2c       	mov	r11, r1
     6e0:	aa 0c       	add	r10, r10
     6e2:	bb 1c       	adc	r11, r11
     6e4:	aa 0c       	add	r10, r10
     6e6:	bb 1c       	adc	r11, r11
     6e8:	2d 85       	ldd	r18, Y+13	; 0x0d
     6ea:	3e 85       	ldd	r19, Y+14	; 0x0e
     6ec:	2a 0d       	add	r18, r10
     6ee:	3b 1d       	adc	r19, r11
     6f0:	3a 8f       	std	Y+26, r19	; 0x1a
     6f2:	29 8f       	std	Y+25, r18	; 0x19
     6f4:	d9 01       	movw	r26, r18
     6f6:	6d 91       	ld	r22, X+
     6f8:	7d 91       	ld	r23, X+
     6fa:	8d 91       	ld	r24, X+
     6fc:	9c 91       	ld	r25, X
     6fe:	f3 01       	movw	r30, r6
     700:	ea 0d       	add	r30, r10
     702:	fb 1d       	adc	r31, r11
     704:	fa ab       	std	Y+50, r31	; 0x32
     706:	e9 ab       	std	Y+49, r30	; 0x31
     708:	c0 80       	ld	r12, Z
     70a:	d1 80       	ldd	r13, Z+1	; 0x01
     70c:	e2 80       	ldd	r14, Z+2	; 0x02
     70e:	f3 80       	ldd	r15, Z+3	; 0x03
     710:	a7 01       	movw	r20, r14
     712:	96 01       	movw	r18, r12
     714:	0e 94 35 3c 	call	0x786a	; 0x786a <__addsf3>
     718:	6b 8f       	std	Y+27, r22	; 0x1b
     71a:	7c 8f       	std	Y+28, r23	; 0x1c
     71c:	8d 8f       	std	Y+29, r24	; 0x1d
     71e:	9e 8f       	std	Y+30, r25	; 0x1e
  float r_axis0 = -offset[axis_0];  // Radius vector from center to current location
     720:	32 01       	movw	r6, r4
     722:	21 01       	movw	r4, r2
     724:	77 fa       	bst	r7, 7
     726:	70 94       	com	r7
     728:	77 f8       	bld	r7, 7
     72a:	70 94       	com	r7
  float r_axis1 = -offset[axis_1];
     72c:	d7 01       	movw	r26, r14
     72e:	c6 01       	movw	r24, r12
     730:	b0 58       	subi	r27, 0x80	; 128
     732:	89 87       	std	Y+9, r24	; 0x09
     734:	9a 87       	std	Y+10, r25	; 0x0a
     736:	ab 87       	std	Y+11, r26	; 0x0b
     738:	bc 87       	std	Y+12, r27	; 0x0c
  float rt_axis0 = target[axis_0] - center_axis0;
     73a:	eb a9       	ldd	r30, Y+51	; 0x33
     73c:	fc a9       	ldd	r31, Y+52	; 0x34
     73e:	e8 0d       	add	r30, r8
     740:	f9 1d       	adc	r31, r9
     742:	60 81       	ld	r22, Z
     744:	71 81       	ldd	r23, Z+1	; 0x01
     746:	82 81       	ldd	r24, Z+2	; 0x02
     748:	93 81       	ldd	r25, Z+3	; 0x03
     74a:	2d 89       	ldd	r18, Y+21	; 0x15
     74c:	3e 89       	ldd	r19, Y+22	; 0x16
     74e:	4f 89       	ldd	r20, Y+23	; 0x17
     750:	58 8d       	ldd	r21, Y+24	; 0x18
     752:	0e 94 34 3c 	call	0x7868	; 0x7868 <__subsf3>
     756:	69 83       	std	Y+1, r22	; 0x01
     758:	7a 83       	std	Y+2, r23	; 0x02
     75a:	8b 83       	std	Y+3, r24	; 0x03
     75c:	9c 83       	std	Y+4, r25	; 0x04
  float rt_axis1 = target[axis_1] - center_axis1;
     75e:	eb a9       	ldd	r30, Y+51	; 0x33
     760:	fc a9       	ldd	r31, Y+52	; 0x34
     762:	ea 0d       	add	r30, r10
     764:	fb 1d       	adc	r31, r11
     766:	60 81       	ld	r22, Z
     768:	71 81       	ldd	r23, Z+1	; 0x01
     76a:	82 81       	ldd	r24, Z+2	; 0x02
     76c:	93 81       	ldd	r25, Z+3	; 0x03
     76e:	2b 8d       	ldd	r18, Y+27	; 0x1b
     770:	3c 8d       	ldd	r19, Y+28	; 0x1c
     772:	4d 8d       	ldd	r20, Y+29	; 0x1d
     774:	5e 8d       	ldd	r21, Y+30	; 0x1e
     776:	0e 94 34 3c 	call	0x7868	; 0x7868 <__subsf3>
     77a:	6b 01       	movw	r12, r22
     77c:	7c 01       	movw	r14, r24

  // CCW angle between position and target from circle center. Only one atan2() trig computation required.
  float angular_travel = atan2(r_axis0*rt_axis1-r_axis1*rt_axis0, r_axis0*rt_axis0+r_axis1*rt_axis1);
     77e:	29 81       	ldd	r18, Y+1	; 0x01
     780:	3a 81       	ldd	r19, Y+2	; 0x02
     782:	4b 81       	ldd	r20, Y+3	; 0x03
     784:	5c 81       	ldd	r21, Y+4	; 0x04
     786:	c3 01       	movw	r24, r6
     788:	b2 01       	movw	r22, r4
     78a:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
     78e:	4b 01       	movw	r8, r22
     790:	5c 01       	movw	r10, r24
     792:	a7 01       	movw	r20, r14
     794:	96 01       	movw	r18, r12
     796:	69 85       	ldd	r22, Y+9	; 0x09
     798:	7a 85       	ldd	r23, Y+10	; 0x0a
     79a:	8b 85       	ldd	r24, Y+11	; 0x0b
     79c:	9c 85       	ldd	r25, Y+12	; 0x0c
     79e:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
     7a2:	9b 01       	movw	r18, r22
     7a4:	ac 01       	movw	r20, r24
     7a6:	c5 01       	movw	r24, r10
     7a8:	b4 01       	movw	r22, r8
     7aa:	0e 94 35 3c 	call	0x786a	; 0x786a <__addsf3>
     7ae:	4b 01       	movw	r8, r22
     7b0:	5c 01       	movw	r10, r24
     7b2:	a7 01       	movw	r20, r14
     7b4:	96 01       	movw	r18, r12
     7b6:	c3 01       	movw	r24, r6
     7b8:	b2 01       	movw	r22, r4
     7ba:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
     7be:	6b 01       	movw	r12, r22
     7c0:	7c 01       	movw	r14, r24
     7c2:	29 81       	ldd	r18, Y+1	; 0x01
     7c4:	3a 81       	ldd	r19, Y+2	; 0x02
     7c6:	4b 81       	ldd	r20, Y+3	; 0x03
     7c8:	5c 81       	ldd	r21, Y+4	; 0x04
     7ca:	69 85       	ldd	r22, Y+9	; 0x09
     7cc:	7a 85       	ldd	r23, Y+10	; 0x0a
     7ce:	8b 85       	ldd	r24, Y+11	; 0x0b
     7d0:	9c 85       	ldd	r25, Y+12	; 0x0c
     7d2:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
     7d6:	9b 01       	movw	r18, r22
     7d8:	ac 01       	movw	r20, r24
     7da:	c7 01       	movw	r24, r14
     7dc:	b6 01       	movw	r22, r12
     7de:	0e 94 34 3c 	call	0x7868	; 0x7868 <__subsf3>
     7e2:	a5 01       	movw	r20, r10
     7e4:	94 01       	movw	r18, r8
     7e6:	0e 94 a8 3c 	call	0x7950	; 0x7950 <atan2>
     7ea:	69 83       	std	Y+1, r22	; 0x01
     7ec:	7a 83       	std	Y+2, r23	; 0x02
     7ee:	8b 83       	std	Y+3, r24	; 0x03
     7f0:	9c 83       	std	Y+4, r25	; 0x04
  if (is_clockwise_arc) { // Correct atan2 output per direction
     7f2:	2b 96       	adiw	r28, 0x0b	; 11
     7f4:	8f ad       	ldd	r24, Y+63	; 0x3f
     7f6:	2b 97       	sbiw	r28, 0x0b	; 11
     7f8:	88 23       	and	r24, r24
     7fa:	d9 f0       	breq	.+54     	; 0x832 <mc_arc+0x1e2>
    if (angular_travel >= -ARC_ANGULAR_TRAVEL_EPSILON) { angular_travel -= 2*M_PI; }
     7fc:	2d eb       	ldi	r18, 0xBD	; 189
     7fe:	37 e3       	ldi	r19, 0x37	; 55
     800:	46 e0       	ldi	r20, 0x06	; 6
     802:	55 eb       	ldi	r21, 0xB5	; 181
     804:	69 81       	ldd	r22, Y+1	; 0x01
     806:	7a 81       	ldd	r23, Y+2	; 0x02
     808:	8b 81       	ldd	r24, Y+3	; 0x03
     80a:	9c 81       	ldd	r25, Y+4	; 0x04
     80c:	0e 94 11 3f 	call	0x7e22	; 0x7e22 <__gesf2>
     810:	88 23       	and	r24, r24
     812:	4c f1       	brlt	.+82     	; 0x866 <mc_arc+0x216>
     814:	2b ed       	ldi	r18, 0xDB	; 219
     816:	3f e0       	ldi	r19, 0x0F	; 15
     818:	49 ec       	ldi	r20, 0xC9	; 201
     81a:	50 e4       	ldi	r21, 0x40	; 64
     81c:	69 81       	ldd	r22, Y+1	; 0x01
     81e:	7a 81       	ldd	r23, Y+2	; 0x02
     820:	8b 81       	ldd	r24, Y+3	; 0x03
     822:	9c 81       	ldd	r25, Y+4	; 0x04
     824:	0e 94 34 3c 	call	0x7868	; 0x7868 <__subsf3>
     828:	69 83       	std	Y+1, r22	; 0x01
     82a:	7a 83       	std	Y+2, r23	; 0x02
     82c:	8b 83       	std	Y+3, r24	; 0x03
     82e:	9c 83       	std	Y+4, r25	; 0x04
     830:	1a c0       	rjmp	.+52     	; 0x866 <mc_arc+0x216>
  } else {
    if (angular_travel <= ARC_ANGULAR_TRAVEL_EPSILON) { angular_travel += 2*M_PI; }
     832:	2d eb       	ldi	r18, 0xBD	; 189
     834:	37 e3       	ldi	r19, 0x37	; 55
     836:	46 e0       	ldi	r20, 0x06	; 6
     838:	55 e3       	ldi	r21, 0x35	; 53
     83a:	69 81       	ldd	r22, Y+1	; 0x01
     83c:	7a 81       	ldd	r23, Y+2	; 0x02
     83e:	8b 81       	ldd	r24, Y+3	; 0x03
     840:	9c 81       	ldd	r25, Y+4	; 0x04
     842:	0e 94 0e 3d 	call	0x7a1c	; 0x7a1c <__cmpsf2>
     846:	18 16       	cp	r1, r24
     848:	74 f0       	brlt	.+28     	; 0x866 <mc_arc+0x216>
     84a:	2b ed       	ldi	r18, 0xDB	; 219
     84c:	3f e0       	ldi	r19, 0x0F	; 15
     84e:	49 ec       	ldi	r20, 0xC9	; 201
     850:	50 e4       	ldi	r21, 0x40	; 64
     852:	69 81       	ldd	r22, Y+1	; 0x01
     854:	7a 81       	ldd	r23, Y+2	; 0x02
     856:	8b 81       	ldd	r24, Y+3	; 0x03
     858:	9c 81       	ldd	r25, Y+4	; 0x04
     85a:	0e 94 35 3c 	call	0x786a	; 0x786a <__addsf3>
     85e:	69 83       	std	Y+1, r22	; 0x01
     860:	7a 83       	std	Y+2, r23	; 0x02
     862:	8b 83       	std	Y+3, r24	; 0x03
     864:	9c 83       	std	Y+4, r25	; 0x04

  // NOTE: Segment end points are on the arc, which can lead to the arc diameter being smaller by up to
  // (2x) settings.arc_tolerance. For 99% of users, this is just fine. If a different arc segment fit
  // is desired, i.e. least-squares, midpoint on arc, just change the mm_per_arc_segment calculation.
  // For the intended uses of Grbl, this value shouldn't exceed 2000 for the strictest of cases.
  uint16_t segments = floor(fabs(0.5*angular_travel*radius)/
     866:	20 e0       	ldi	r18, 0x00	; 0
     868:	30 e0       	ldi	r19, 0x00	; 0
     86a:	40 e0       	ldi	r20, 0x00	; 0
     86c:	5f e3       	ldi	r21, 0x3F	; 63
     86e:	69 81       	ldd	r22, Y+1	; 0x01
     870:	7a 81       	ldd	r23, Y+2	; 0x02
     872:	8b 81       	ldd	r24, Y+3	; 0x03
     874:	9c 81       	ldd	r25, Y+4	; 0x04
     876:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
     87a:	2d 81       	ldd	r18, Y+5	; 0x05
     87c:	3e 81       	ldd	r19, Y+6	; 0x06
     87e:	4f 81       	ldd	r20, Y+7	; 0x07
     880:	58 85       	ldd	r21, Y+8	; 0x08
     882:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
     886:	4b 01       	movw	r8, r22
     888:	5c 01       	movw	r10, r24
     88a:	e8 94       	clt
     88c:	b7 f8       	bld	r11, 7
                          sqrt(settings.arc_tolerance*(2*radius - settings.arc_tolerance)) );
     88e:	2d 81       	ldd	r18, Y+5	; 0x05
     890:	3e 81       	ldd	r19, Y+6	; 0x06
     892:	4f 81       	ldd	r20, Y+7	; 0x07
     894:	58 85       	ldd	r21, Y+8	; 0x08
     896:	ca 01       	movw	r24, r20
     898:	b9 01       	movw	r22, r18
     89a:	0e 94 35 3c 	call	0x786a	; 0x786a <__addsf3>
     89e:	c0 90 f2 0e 	lds	r12, 0x0EF2	; 0x800ef2 <settings+0x39>
     8a2:	d0 90 f3 0e 	lds	r13, 0x0EF3	; 0x800ef3 <settings+0x3a>
     8a6:	e0 90 f4 0e 	lds	r14, 0x0EF4	; 0x800ef4 <settings+0x3b>
     8aa:	f0 90 f5 0e 	lds	r15, 0x0EF5	; 0x800ef5 <settings+0x3c>
     8ae:	a7 01       	movw	r20, r14
     8b0:	96 01       	movw	r18, r12
     8b2:	0e 94 34 3c 	call	0x7868	; 0x7868 <__subsf3>
     8b6:	9b 01       	movw	r18, r22
     8b8:	ac 01       	movw	r20, r24
     8ba:	c7 01       	movw	r24, r14
     8bc:	b6 01       	movw	r22, r12
     8be:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
     8c2:	0e 94 d9 3f 	call	0x7fb2	; 0x7fb2 <sqrt>
     8c6:	9b 01       	movw	r18, r22
     8c8:	ac 01       	movw	r20, r24

  // NOTE: Segment end points are on the arc, which can lead to the arc diameter being smaller by up to
  // (2x) settings.arc_tolerance. For 99% of users, this is just fine. If a different arc segment fit
  // is desired, i.e. least-squares, midpoint on arc, just change the mm_per_arc_segment calculation.
  // For the intended uses of Grbl, this value shouldn't exceed 2000 for the strictest of cases.
  uint16_t segments = floor(fabs(0.5*angular_travel*radius)/
     8ca:	c5 01       	movw	r24, r10
     8cc:	b4 01       	movw	r22, r8
     8ce:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <__divsf3>
     8d2:	0e 94 eb 3d 	call	0x7bd6	; 0x7bd6 <floor>
     8d6:	0e 94 82 3d 	call	0x7b04	; 0x7b04 <__fixunssfsi>
     8da:	6b 01       	movw	r12, r22
     8dc:	7c 01       	movw	r14, r24
     8de:	7a 8b       	std	Y+18, r23	; 0x12
     8e0:	69 8b       	std	Y+17, r22	; 0x11
                          sqrt(settings.arc_tolerance*(2*radius - settings.arc_tolerance)) );

  if (segments) {
     8e2:	db 01       	movw	r26, r22
     8e4:	ab 2b       	or	r26, r27
     8e6:	09 f4       	brne	.+2      	; 0x8ea <mc_arc+0x29a>
     8e8:	79 c1       	rjmp	.+754    	; 0xbdc <mc_arc+0x58c>
    // Multiply inverse feed_rate to compensate for the fact that this movement is approximated
    // by a number of discrete segments. The inverse feed_rate should be correct for the sum of
    // all segments.
    if (pl_data->condition & PL_COND_FLAG_INVERSE_TIME) { 
     8ea:	ef 85       	ldd	r30, Y+15	; 0x0f
     8ec:	f8 89       	ldd	r31, Y+16	; 0x10
     8ee:	14 85       	ldd	r17, Z+12	; 0x0c
     8f0:	13 ff       	sbrs	r17, 3
     8f2:	16 c0       	rjmp	.+44     	; 0x920 <mc_arc+0x2d0>
      pl_data->feed_rate *= segments; 
     8f4:	80 e0       	ldi	r24, 0x00	; 0
     8f6:	90 e0       	ldi	r25, 0x00	; 0
     8f8:	0e 94 ae 3d 	call	0x7b5c	; 0x7b5c <__floatunsisf>
     8fc:	9b 01       	movw	r18, r22
     8fe:	ac 01       	movw	r20, r24
     900:	af 85       	ldd	r26, Y+15	; 0x0f
     902:	b8 89       	ldd	r27, Y+16	; 0x10
     904:	6d 91       	ld	r22, X+
     906:	7d 91       	ld	r23, X+
     908:	8d 91       	ld	r24, X+
     90a:	9c 91       	ld	r25, X
     90c:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
     910:	ef 85       	ldd	r30, Y+15	; 0x0f
     912:	f8 89       	ldd	r31, Y+16	; 0x10
     914:	60 83       	st	Z, r22
     916:	71 83       	std	Z+1, r23	; 0x01
     918:	82 83       	std	Z+2, r24	; 0x02
     91a:	93 83       	std	Z+3, r25	; 0x03
      bit_false(pl_data->condition,PL_COND_FLAG_INVERSE_TIME); // Force as feed absolute mode over arc segments.
     91c:	17 7f       	andi	r17, 0xF7	; 247
     91e:	14 87       	std	Z+12, r17	; 0x0c
    }
    
    float theta_per_segment = angular_travel/segments;
     920:	b6 01       	movw	r22, r12
     922:	80 e0       	ldi	r24, 0x00	; 0
     924:	90 e0       	ldi	r25, 0x00	; 0
     926:	0e 94 ae 3d 	call	0x7b5c	; 0x7b5c <__floatunsisf>
     92a:	6b 01       	movw	r12, r22
     92c:	7c 01       	movw	r14, r24
     92e:	9b 01       	movw	r18, r22
     930:	ac 01       	movw	r20, r24
     932:	69 81       	ldd	r22, Y+1	; 0x01
     934:	7a 81       	ldd	r23, Y+2	; 0x02
     936:	8b 81       	ldd	r24, Y+3	; 0x03
     938:	9c 81       	ldd	r25, Y+4	; 0x04
     93a:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <__divsf3>
     93e:	6b a7       	std	Y+43, r22	; 0x2b
     940:	7c a7       	std	Y+44, r23	; 0x2c
     942:	8d a7       	std	Y+45, r24	; 0x2d
     944:	9e a7       	std	Y+46, r25	; 0x2e
    float linear_per_segment = (target[axis_linear] - position[axis_linear])/segments;
     946:	10 e0       	ldi	r17, 0x00	; 0
     948:	00 0f       	add	r16, r16
     94a:	11 1f       	adc	r17, r17
     94c:	00 0f       	add	r16, r16
     94e:	11 1f       	adc	r17, r17
     950:	eb a9       	ldd	r30, Y+51	; 0x33
     952:	fc a9       	ldd	r31, Y+52	; 0x34
     954:	e0 0f       	add	r30, r16
     956:	f1 1f       	adc	r31, r17
     958:	60 81       	ld	r22, Z
     95a:	71 81       	ldd	r23, Z+1	; 0x01
     95c:	82 81       	ldd	r24, Z+2	; 0x02
     95e:	93 81       	ldd	r25, Z+3	; 0x03
     960:	2d 85       	ldd	r18, Y+13	; 0x0d
     962:	3e 85       	ldd	r19, Y+14	; 0x0e
     964:	20 0f       	add	r18, r16
     966:	31 1f       	adc	r19, r17
     968:	3a 83       	std	Y+2, r19	; 0x02
     96a:	29 83       	std	Y+1, r18	; 0x01
     96c:	d9 01       	movw	r26, r18
     96e:	2d 91       	ld	r18, X+
     970:	3d 91       	ld	r19, X+
     972:	4d 91       	ld	r20, X+
     974:	5c 91       	ld	r21, X
     976:	0e 94 34 3c 	call	0x7868	; 0x7868 <__subsf3>
     97a:	a7 01       	movw	r20, r14
     97c:	96 01       	movw	r18, r12
     97e:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <__divsf3>
     982:	6f 8f       	std	Y+31, r22	; 0x1f
     984:	78 a3       	std	Y+32, r23	; 0x20
     986:	89 a3       	std	Y+33, r24	; 0x21
     988:	9a a3       	std	Y+34, r25	; 0x22
       without the initial overhead of computing cos() or sin(). By the time the arc needs to be applied
       a correction, the planner should have caught up to the lag caused by the initial mc_arc overhead.
       This is important when there are successive arc motions.
    */
    // Computes: cos_T = 1 - theta_per_segment^2/2, sin_T = theta_per_segment - theta_per_segment^3/6) in ~52usec
    float cos_T = 2.0 - theta_per_segment*theta_per_segment;
     98a:	2b a5       	ldd	r18, Y+43	; 0x2b
     98c:	3c a5       	ldd	r19, Y+44	; 0x2c
     98e:	4d a5       	ldd	r20, Y+45	; 0x2d
     990:	5e a5       	ldd	r21, Y+46	; 0x2e
     992:	ca 01       	movw	r24, r20
     994:	b9 01       	movw	r22, r18
     996:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
     99a:	9b 01       	movw	r18, r22
     99c:	ac 01       	movw	r20, r24
     99e:	60 e0       	ldi	r22, 0x00	; 0
     9a0:	70 e0       	ldi	r23, 0x00	; 0
     9a2:	80 e0       	ldi	r24, 0x00	; 0
     9a4:	90 e4       	ldi	r25, 0x40	; 64
     9a6:	0e 94 34 3c 	call	0x7868	; 0x7868 <__subsf3>
     9aa:	6b 01       	movw	r12, r22
     9ac:	7c 01       	movw	r14, r24
    float sin_T = theta_per_segment*0.16666667*(cos_T + 4.0);
     9ae:	2b ea       	ldi	r18, 0xAB	; 171
     9b0:	3a ea       	ldi	r19, 0xAA	; 170
     9b2:	4a e2       	ldi	r20, 0x2A	; 42
     9b4:	5e e3       	ldi	r21, 0x3E	; 62
     9b6:	6b a5       	ldd	r22, Y+43	; 0x2b
     9b8:	7c a5       	ldd	r23, Y+44	; 0x2c
     9ba:	8d a5       	ldd	r24, Y+45	; 0x2d
     9bc:	9e a5       	ldd	r25, Y+46	; 0x2e
     9be:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
     9c2:	4b 01       	movw	r8, r22
     9c4:	5c 01       	movw	r10, r24
     9c6:	20 e0       	ldi	r18, 0x00	; 0
     9c8:	30 e0       	ldi	r19, 0x00	; 0
     9ca:	40 e8       	ldi	r20, 0x80	; 128
     9cc:	50 e4       	ldi	r21, 0x40	; 64
     9ce:	c7 01       	movw	r24, r14
     9d0:	b6 01       	movw	r22, r12
     9d2:	0e 94 35 3c 	call	0x786a	; 0x786a <__addsf3>
     9d6:	9b 01       	movw	r18, r22
     9d8:	ac 01       	movw	r20, r24
     9da:	c5 01       	movw	r24, r10
     9dc:	b4 01       	movw	r22, r8
     9de:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
     9e2:	6b a3       	std	Y+35, r22	; 0x23
     9e4:	7c a3       	std	Y+36, r23	; 0x24
     9e6:	8d a3       	std	Y+37, r24	; 0x25
     9e8:	9e a3       	std	Y+38, r25	; 0x26
    cos_T *= 0.5;
     9ea:	20 e0       	ldi	r18, 0x00	; 0
     9ec:	30 e0       	ldi	r19, 0x00	; 0
     9ee:	40 e0       	ldi	r20, 0x00	; 0
     9f0:	5f e3       	ldi	r21, 0x3F	; 63
     9f2:	c7 01       	movw	r24, r14
     9f4:	b6 01       	movw	r22, r12
     9f6:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
     9fa:	6f a3       	std	Y+39, r22	; 0x27
     9fc:	78 a7       	std	Y+40, r23	; 0x28
     9fe:	89 a7       	std	Y+41, r24	; 0x29
     a00:	9a a7       	std	Y+42, r25	; 0x2a

    float sin_Ti;
    float cos_Ti;
    float r_axisi;
    uint16_t i;
    uint8_t count = 0;
     a02:	10 e0       	ldi	r17, 0x00	; 0

    for (i = 1; i<segments; i++) { // Increment (segments-1).
     a04:	22 24       	eor	r2, r2
     a06:	23 94       	inc	r2
     a08:	31 2c       	mov	r3, r1
     a0a:	c9 84       	ldd	r12, Y+9	; 0x09
     a0c:	da 84       	ldd	r13, Y+10	; 0x0a
     a0e:	eb 84       	ldd	r14, Y+11	; 0x0b
     a10:	fc 84       	ldd	r15, Y+12	; 0x0c
     a12:	de c0       	rjmp	.+444    	; 0xbd0 <mc_arc+0x580>

      if (count < N_ARC_CORRECTION) {
     a14:	1c 30       	cpi	r17, 0x0C	; 12
     a16:	e0 f5       	brcc	.+120    	; 0xa90 <mc_arc+0x440>
        // Apply vector rotation matrix. ~40 usec
        r_axisi = r_axis0*sin_T + r_axis1*cos_T;
     a18:	2b a1       	ldd	r18, Y+35	; 0x23
     a1a:	3c a1       	ldd	r19, Y+36	; 0x24
     a1c:	4d a1       	ldd	r20, Y+37	; 0x25
     a1e:	5e a1       	ldd	r21, Y+38	; 0x26
     a20:	c3 01       	movw	r24, r6
     a22:	b2 01       	movw	r22, r4
     a24:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
     a28:	4b 01       	movw	r8, r22
     a2a:	5c 01       	movw	r10, r24
     a2c:	2f a1       	ldd	r18, Y+39	; 0x27
     a2e:	38 a5       	ldd	r19, Y+40	; 0x28
     a30:	49 a5       	ldd	r20, Y+41	; 0x29
     a32:	5a a5       	ldd	r21, Y+42	; 0x2a
     a34:	c7 01       	movw	r24, r14
     a36:	b6 01       	movw	r22, r12
     a38:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
     a3c:	9b 01       	movw	r18, r22
     a3e:	ac 01       	movw	r20, r24
     a40:	c5 01       	movw	r24, r10
     a42:	b4 01       	movw	r22, r8
     a44:	0e 94 35 3c 	call	0x786a	; 0x786a <__addsf3>
     a48:	96 2e       	mov	r9, r22
     a4a:	a7 2e       	mov	r10, r23
     a4c:	b8 2e       	mov	r11, r24
     a4e:	09 2f       	mov	r16, r25
        r_axis0 = r_axis0*cos_T - r_axis1*sin_T;
     a50:	2f a1       	ldd	r18, Y+39	; 0x27
     a52:	38 a5       	ldd	r19, Y+40	; 0x28
     a54:	49 a5       	ldd	r20, Y+41	; 0x29
     a56:	5a a5       	ldd	r21, Y+42	; 0x2a
     a58:	c3 01       	movw	r24, r6
     a5a:	b2 01       	movw	r22, r4
     a5c:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
     a60:	2b 01       	movw	r4, r22
     a62:	3c 01       	movw	r6, r24
     a64:	2b a1       	ldd	r18, Y+35	; 0x23
     a66:	3c a1       	ldd	r19, Y+36	; 0x24
     a68:	4d a1       	ldd	r20, Y+37	; 0x25
     a6a:	5e a1       	ldd	r21, Y+38	; 0x26
     a6c:	c7 01       	movw	r24, r14
     a6e:	b6 01       	movw	r22, r12
     a70:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
     a74:	9b 01       	movw	r18, r22
     a76:	ac 01       	movw	r20, r24
     a78:	c3 01       	movw	r24, r6
     a7a:	b2 01       	movw	r22, r4
     a7c:	0e 94 34 3c 	call	0x7868	; 0x7868 <__subsf3>
     a80:	2b 01       	movw	r4, r22
     a82:	3c 01       	movw	r6, r24
        r_axis1 = r_axisi;
        count++;
     a84:	1f 5f       	subi	r17, 0xFF	; 255

      if (count < N_ARC_CORRECTION) {
        // Apply vector rotation matrix. ~40 usec
        r_axisi = r_axis0*sin_T + r_axis1*cos_T;
        r_axis0 = r_axis0*cos_T - r_axis1*sin_T;
        r_axis1 = r_axisi;
     a86:	c9 2c       	mov	r12, r9
     a88:	da 2c       	mov	r13, r10
     a8a:	eb 2c       	mov	r14, r11
     a8c:	f0 2e       	mov	r15, r16
     a8e:	64 c0       	rjmp	.+200    	; 0xb58 <mc_arc+0x508>
        count++;
      } else {
        // Arc correction to radius vector. Computed only every N_ARC_CORRECTION increments. ~375 usec
        // Compute exact location by applying transformation matrix from initial radius vector(=-offset).
        cos_Ti = cos(i*theta_per_segment);
     a90:	b1 01       	movw	r22, r2
     a92:	80 e0       	ldi	r24, 0x00	; 0
     a94:	90 e0       	ldi	r25, 0x00	; 0
     a96:	0e 94 ae 3d 	call	0x7b5c	; 0x7b5c <__floatunsisf>
     a9a:	9b 01       	movw	r18, r22
     a9c:	ac 01       	movw	r20, r24
     a9e:	6b a5       	ldd	r22, Y+43	; 0x2b
     aa0:	7c a5       	ldd	r23, Y+44	; 0x2c
     aa2:	8d a5       	ldd	r24, Y+45	; 0x2d
     aa4:	9e a5       	ldd	r25, Y+46	; 0x2e
     aa6:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
     aaa:	6b 01       	movw	r12, r22
     aac:	7c 01       	movw	r14, r24
     aae:	0e 94 12 3d 	call	0x7a24	; 0x7a24 <cos>
     ab2:	6d 83       	std	Y+5, r22	; 0x05
     ab4:	7e 83       	std	Y+6, r23	; 0x06
     ab6:	8f 83       	std	Y+7, r24	; 0x07
     ab8:	98 87       	std	Y+8, r25	; 0x08
        sin_Ti = sin(i*theta_per_segment);
     aba:	c7 01       	movw	r24, r14
     abc:	b6 01       	movw	r22, r12
     abe:	0e 94 cf 3f 	call	0x7f9e	; 0x7f9e <sin>
     ac2:	69 87       	std	Y+9, r22	; 0x09
     ac4:	7a 87       	std	Y+10, r23	; 0x0a
     ac6:	8b 87       	std	Y+11, r24	; 0x0b
     ac8:	9c 87       	std	Y+12, r25	; 0x0c
        r_axis0 = -offset[axis_0]*cos_Ti + offset[axis_1]*sin_Ti;
     aca:	ef a5       	ldd	r30, Y+47	; 0x2f
     acc:	f8 a9       	ldd	r31, Y+48	; 0x30
     ace:	80 81       	ld	r24, Z
     ad0:	91 81       	ldd	r25, Z+1	; 0x01
     ad2:	a2 81       	ldd	r26, Z+2	; 0x02
     ad4:	b3 81       	ldd	r27, Z+3	; 0x03
     ad6:	4c 01       	movw	r8, r24
     ad8:	5d 01       	movw	r10, r26
     ada:	b7 fa       	bst	r11, 7
     adc:	b0 94       	com	r11
     ade:	b7 f8       	bld	r11, 7
     ae0:	b0 94       	com	r11
     ae2:	a5 01       	movw	r20, r10
     ae4:	94 01       	movw	r18, r8
     ae6:	6d 81       	ldd	r22, Y+5	; 0x05
     ae8:	7e 81       	ldd	r23, Y+6	; 0x06
     aea:	8f 81       	ldd	r24, Y+7	; 0x07
     aec:	98 85       	ldd	r25, Y+8	; 0x08
     aee:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
     af2:	2b 01       	movw	r4, r22
     af4:	3c 01       	movw	r6, r24
     af6:	a9 a9       	ldd	r26, Y+49	; 0x31
     af8:	ba a9       	ldd	r27, Y+50	; 0x32
     afa:	cd 90       	ld	r12, X+
     afc:	dd 90       	ld	r13, X+
     afe:	ed 90       	ld	r14, X+
     b00:	fc 90       	ld	r15, X
     b02:	a7 01       	movw	r20, r14
     b04:	96 01       	movw	r18, r12
     b06:	69 85       	ldd	r22, Y+9	; 0x09
     b08:	7a 85       	ldd	r23, Y+10	; 0x0a
     b0a:	8b 85       	ldd	r24, Y+11	; 0x0b
     b0c:	9c 85       	ldd	r25, Y+12	; 0x0c
     b0e:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
     b12:	9b 01       	movw	r18, r22
     b14:	ac 01       	movw	r20, r24
     b16:	c3 01       	movw	r24, r6
     b18:	b2 01       	movw	r22, r4
     b1a:	0e 94 35 3c 	call	0x786a	; 0x786a <__addsf3>
     b1e:	2b 01       	movw	r4, r22
     b20:	3c 01       	movw	r6, r24
        r_axis1 = -offset[axis_0]*sin_Ti - offset[axis_1]*cos_Ti;
     b22:	a5 01       	movw	r20, r10
     b24:	94 01       	movw	r18, r8
     b26:	69 85       	ldd	r22, Y+9	; 0x09
     b28:	7a 85       	ldd	r23, Y+10	; 0x0a
     b2a:	8b 85       	ldd	r24, Y+11	; 0x0b
     b2c:	9c 85       	ldd	r25, Y+12	; 0x0c
     b2e:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
     b32:	4b 01       	movw	r8, r22
     b34:	5c 01       	movw	r10, r24
     b36:	a7 01       	movw	r20, r14
     b38:	96 01       	movw	r18, r12
     b3a:	6d 81       	ldd	r22, Y+5	; 0x05
     b3c:	7e 81       	ldd	r23, Y+6	; 0x06
     b3e:	8f 81       	ldd	r24, Y+7	; 0x07
     b40:	98 85       	ldd	r25, Y+8	; 0x08
     b42:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
     b46:	9b 01       	movw	r18, r22
     b48:	ac 01       	movw	r20, r24
     b4a:	c5 01       	movw	r24, r10
     b4c:	b4 01       	movw	r22, r8
     b4e:	0e 94 34 3c 	call	0x7868	; 0x7868 <__subsf3>
     b52:	6b 01       	movw	r12, r22
     b54:	7c 01       	movw	r14, r24
        count = 0;
     b56:	10 e0       	ldi	r17, 0x00	; 0
      }

      // Update arc_target location
      position[axis_0] = center_axis0 + r_axis0;
     b58:	2d 89       	ldd	r18, Y+21	; 0x15
     b5a:	3e 89       	ldd	r19, Y+22	; 0x16
     b5c:	4f 89       	ldd	r20, Y+23	; 0x17
     b5e:	58 8d       	ldd	r21, Y+24	; 0x18
     b60:	c3 01       	movw	r24, r6
     b62:	b2 01       	movw	r22, r4
     b64:	0e 94 35 3c 	call	0x786a	; 0x786a <__addsf3>
     b68:	eb 89       	ldd	r30, Y+19	; 0x13
     b6a:	fc 89       	ldd	r31, Y+20	; 0x14
     b6c:	60 83       	st	Z, r22
     b6e:	71 83       	std	Z+1, r23	; 0x01
     b70:	82 83       	std	Z+2, r24	; 0x02
     b72:	93 83       	std	Z+3, r25	; 0x03
      position[axis_1] = center_axis1 + r_axis1;
     b74:	2b 8d       	ldd	r18, Y+27	; 0x1b
     b76:	3c 8d       	ldd	r19, Y+28	; 0x1c
     b78:	4d 8d       	ldd	r20, Y+29	; 0x1d
     b7a:	5e 8d       	ldd	r21, Y+30	; 0x1e
     b7c:	c7 01       	movw	r24, r14
     b7e:	b6 01       	movw	r22, r12
     b80:	0e 94 35 3c 	call	0x786a	; 0x786a <__addsf3>
     b84:	a9 8d       	ldd	r26, Y+25	; 0x19
     b86:	ba 8d       	ldd	r27, Y+26	; 0x1a
     b88:	6d 93       	st	X+, r22
     b8a:	7d 93       	st	X+, r23
     b8c:	8d 93       	st	X+, r24
     b8e:	9c 93       	st	X, r25
     b90:	13 97       	sbiw	r26, 0x03	; 3
      position[axis_linear] += linear_per_segment;
     b92:	2f 8d       	ldd	r18, Y+31	; 0x1f
     b94:	38 a1       	ldd	r19, Y+32	; 0x20
     b96:	49 a1       	ldd	r20, Y+33	; 0x21
     b98:	5a a1       	ldd	r21, Y+34	; 0x22
     b9a:	e9 81       	ldd	r30, Y+1	; 0x01
     b9c:	fa 81       	ldd	r31, Y+2	; 0x02
     b9e:	60 81       	ld	r22, Z
     ba0:	71 81       	ldd	r23, Z+1	; 0x01
     ba2:	82 81       	ldd	r24, Z+2	; 0x02
     ba4:	93 81       	ldd	r25, Z+3	; 0x03
     ba6:	0e 94 35 3c 	call	0x786a	; 0x786a <__addsf3>
     baa:	a9 81       	ldd	r26, Y+1	; 0x01
     bac:	ba 81       	ldd	r27, Y+2	; 0x02
     bae:	6d 93       	st	X+, r22
     bb0:	7d 93       	st	X+, r23
     bb2:	8d 93       	st	X+, r24
     bb4:	9c 93       	st	X, r25
     bb6:	13 97       	sbiw	r26, 0x03	; 3

      mc_line(position, pl_data);
     bb8:	6f 85       	ldd	r22, Y+15	; 0x0f
     bba:	78 89       	ldd	r23, Y+16	; 0x10
     bbc:	8d 85       	ldd	r24, Y+13	; 0x0d
     bbe:	9e 85       	ldd	r25, Y+14	; 0x0e
     bc0:	0b dd       	rcall	.-1514   	; 0x5d8 <mc_line>

      // Bail mid-circle on system abort. Runtime command check already performed by mc_line.
      if (sys.abort) { return; }
     bc2:	80 91 12 0c 	lds	r24, 0x0C12	; 0x800c12 <sys+0x1>
     bc6:	81 11       	cpse	r24, r1
     bc8:	0e c0       	rjmp	.+28     	; 0xbe6 <mc_arc+0x596>
    float cos_Ti;
    float r_axisi;
    uint16_t i;
    uint8_t count = 0;

    for (i = 1; i<segments; i++) { // Increment (segments-1).
     bca:	bf ef       	ldi	r27, 0xFF	; 255
     bcc:	2b 1a       	sub	r2, r27
     bce:	3b 0a       	sbc	r3, r27
     bd0:	e9 89       	ldd	r30, Y+17	; 0x11
     bd2:	fa 89       	ldd	r31, Y+18	; 0x12
     bd4:	2e 16       	cp	r2, r30
     bd6:	3f 06       	cpc	r3, r31
     bd8:	08 f4       	brcc	.+2      	; 0xbdc <mc_arc+0x58c>
     bda:	1c cf       	rjmp	.-456    	; 0xa14 <mc_arc+0x3c4>
      // Bail mid-circle on system abort. Runtime command check already performed by mc_line.
      if (sys.abort) { return; }
    }
  }
  // Ensure last segment arrives at target location.
  mc_line(target, pl_data);
     bdc:	6f 85       	ldd	r22, Y+15	; 0x0f
     bde:	78 89       	ldd	r23, Y+16	; 0x10
     be0:	8b a9       	ldd	r24, Y+51	; 0x33
     be2:	9c a9       	ldd	r25, Y+52	; 0x34
     be4:	f9 dc       	rcall	.-1550   	; 0x5d8 <mc_line>
}
     be6:	e4 96       	adiw	r28, 0x34	; 52
     be8:	0f b6       	in	r0, 0x3f	; 63
     bea:	f8 94       	cli
     bec:	de bf       	out	0x3e, r29	; 62
     bee:	0f be       	out	0x3f, r0	; 63
     bf0:	cd bf       	out	0x3d, r28	; 61
     bf2:	df 91       	pop	r29
     bf4:	cf 91       	pop	r28
     bf6:	1f 91       	pop	r17
     bf8:	0f 91       	pop	r16
     bfa:	ff 90       	pop	r15
     bfc:	ef 90       	pop	r14
     bfe:	df 90       	pop	r13
     c00:	cf 90       	pop	r12
     c02:	bf 90       	pop	r11
     c04:	af 90       	pop	r10
     c06:	9f 90       	pop	r9
     c08:	8f 90       	pop	r8
     c0a:	7f 90       	pop	r7
     c0c:	6f 90       	pop	r6
     c0e:	5f 90       	pop	r5
     c10:	4f 90       	pop	r4
     c12:	3f 90       	pop	r3
     c14:	2f 90       	pop	r2
     c16:	08 95       	ret

00000c18 <mc_dwell>:


// Execute dwell in seconds.
void mc_dwell(float seconds)
{
     c18:	cf 92       	push	r12
     c1a:	df 92       	push	r13
     c1c:	ef 92       	push	r14
     c1e:	ff 92       	push	r15
  if (sys.state == STATE_CHECK_MODE) { return; }
     c20:	20 91 11 0c 	lds	r18, 0x0C11	; 0x800c11 <sys>
     c24:	22 30       	cpi	r18, 0x02	; 2
     c26:	49 f0       	breq	.+18     	; 0xc3a <mc_dwell+0x22>
     c28:	6b 01       	movw	r12, r22
     c2a:	7c 01       	movw	r14, r24
  protocol_buffer_synchronize();
     c2c:	0e 94 5a 18 	call	0x30b4	; 0x30b4 <protocol_buffer_synchronize>
  delay_sec(seconds, DELAY_MODE_DWELL);
     c30:	40 e0       	ldi	r20, 0x00	; 0
     c32:	c7 01       	movw	r24, r14
     c34:	b6 01       	movw	r22, r12
     c36:	0e 94 64 2d 	call	0x5ac8	; 0x5ac8 <delay_sec>
}
     c3a:	ff 90       	pop	r15
     c3c:	ef 90       	pop	r14
     c3e:	df 90       	pop	r13
     c40:	cf 90       	pop	r12
     c42:	08 95       	ret

00000c44 <mc_homing_cycle>:
      system_set_exec_alarm(EXEC_ALARM_HARD_LIMIT);
      return;
    }
  #endif

  limits_disable(); // Disable hard limits pin change register for cycle duration
     c44:	0e 94 a8 2e 	call	0x5d50	; 0x5d50 <limits_disable>
    if (cycle_mask) { limits_go_home(cycle_mask); } // Perform homing cycle based on mask.
    else
  #endif
  {
    // Search to engage all axes limit switches at faster homing seek rate.
    limits_go_home(HOMING_CYCLE_0);  // Homing cycle 0
     c48:	84 e0       	ldi	r24, 0x04	; 4
     c4a:	0e 94 24 2f 	call	0x5e48	; 0x5e48 <limits_go_home>
    #ifdef HOMING_CYCLE_1
      limits_go_home(HOMING_CYCLE_1);  // Homing cycle 1
     c4e:	83 e0       	ldi	r24, 0x03	; 3
     c50:	0e 94 24 2f 	call	0x5e48	; 0x5e48 <limits_go_home>
    #ifdef HOMING_CYCLE_2
      limits_go_home(HOMING_CYCLE_2);  // Homing cycle 2
    #endif
  }

  protocol_execute_realtime(); // Check for reset and set system abort.
     c54:	0e 94 b2 17 	call	0x2f64	; 0x2f64 <protocol_execute_realtime>
  if (sys.abort) { return; } // Did not complete. Alarm state set by mc_alarm.
     c58:	80 91 12 0c 	lds	r24, 0x0C12	; 0x800c12 <sys+0x1>
     c5c:	81 11       	cpse	r24, r1
     c5e:	05 c0       	rjmp	.+10     	; 0xc6a <mc_homing_cycle+0x26>

  // Homing cycle complete! Setup system for normal operation.
  // -------------------------------------------------------------------------------------

  // Sync gcode parser and planner positions to homed position.
  gc_sync_position();
     c60:	b1 d0       	rcall	.+354    	; 0xdc4 <gc_sync_position>
  plan_sync_position();
     c62:	0e 94 6f 2c 	call	0x58de	; 0x58de <plan_sync_position>

  // If hard limits feature enabled, re-enable hard limits pin change register after homing cycle.
  limits_init();
     c66:	0c 94 b3 2e 	jmp	0x5d66	; 0x5d66 <limits_init>
     c6a:	08 95       	ret

00000c6c <mc_probe_cycle>:


// Perform tool length probe cycle. Requires probe switch.
// NOTE: Upon probe failure, the program will be stopped and placed into ALARM state.
uint8_t mc_probe_cycle(float *target, plan_line_data_t *pl_data, uint8_t parser_flags)
{
     c6c:	ef 92       	push	r14
     c6e:	ff 92       	push	r15
     c70:	0f 93       	push	r16
     c72:	1f 93       	push	r17
     c74:	cf 93       	push	r28
     c76:	df 93       	push	r29
  // TODO: Need to update this cycle so it obeys a non-auto cycle start.
  if (sys.state == STATE_CHECK_MODE) { return(GC_PROBE_CHECK_MODE); }
     c78:	20 91 11 0c 	lds	r18, 0x0C11	; 0x800c11 <sys>
     c7c:	22 30       	cpi	r18, 0x02	; 2
     c7e:	09 f4       	brne	.+2      	; 0xc82 <mc_probe_cycle+0x16>
     c80:	5f c0       	rjmp	.+190    	; 0xd40 <mc_probe_cycle+0xd4>
     c82:	c4 2f       	mov	r28, r20
     c84:	7b 01       	movw	r14, r22
     c86:	8c 01       	movw	r16, r24

  // Finish all queued commands and empty planner buffer before starting probe cycle.
  protocol_buffer_synchronize();
     c88:	0e 94 5a 18 	call	0x30b4	; 0x30b4 <protocol_buffer_synchronize>
  if (sys.abort) { return(GC_PROBE_ABORT); } // Return if system reset has been issued.
     c8c:	80 91 12 0c 	lds	r24, 0x0C12	; 0x800c12 <sys+0x1>
     c90:	81 11       	cpse	r24, r1
     c92:	58 c0       	rjmp	.+176    	; 0xd44 <mc_probe_cycle+0xd8>
     c94:	dc 2f       	mov	r29, r28
     c96:	d0 71       	andi	r29, 0x10	; 16

  // Initialize probing control variables
  uint8_t is_probe_away = bit_istrue(parser_flags,GC_PARSER_PROBE_IS_AWAY);
  uint8_t is_no_error = bit_istrue(parser_flags,GC_PARSER_PROBE_IS_NO_ERROR);
  sys.probe_succeeded = false; // Re-initialize probe history before beginning cycle.
     c98:	10 92 16 0c 	sts	0x0C16, r1	; 0x800c16 <sys+0x5>
  probe_configure_invert_mask(is_probe_away);
     c9c:	c3 fb       	bst	r28, 3
     c9e:	88 27       	eor	r24, r24
     ca0:	80 f9       	bld	r24, 0
     ca2:	0e 94 e7 32 	call	0x65ce	; 0x65ce <probe_configure_invert_mask>

  // After syncing, check if probe is already triggered. If so, halt and issue alarm.
  // NOTE: This probe initialization error applies to all probing cycles.
  if ( probe_get_state() ) { // Check probe pin state.
     ca6:	0e 94 05 33 	call	0x660a	; 0x660a <probe_get_state>
     caa:	88 23       	and	r24, r24
     cac:	51 f0       	breq	.+20     	; 0xcc2 <mc_probe_cycle+0x56>
    system_set_exec_alarm(EXEC_ALARM_PROBE_FAIL_INITIAL);
     cae:	84 e0       	ldi	r24, 0x04	; 4
     cb0:	0e 94 a4 3b 	call	0x7748	; 0x7748 <system_set_exec_alarm>
    protocol_execute_realtime();
     cb4:	0e 94 b2 17 	call	0x2f64	; 0x2f64 <protocol_execute_realtime>
    probe_configure_invert_mask(false); // Re-initialize invert mask before returning.
     cb8:	80 e0       	ldi	r24, 0x00	; 0
     cba:	0e 94 e7 32 	call	0x65ce	; 0x65ce <probe_configure_invert_mask>
    return(GC_PROBE_FAIL_INIT); // Nothing else to do but bail.
     cbe:	82 e0       	ldi	r24, 0x02	; 2
     cc0:	44 c0       	rjmp	.+136    	; 0xd4a <mc_probe_cycle+0xde>
  }

  // Setup and queue probing motion. Auto cycle-start should not start the cycle.
  mc_line(target, pl_data);
     cc2:	b7 01       	movw	r22, r14
     cc4:	c8 01       	movw	r24, r16
     cc6:	88 dc       	rcall	.-1776   	; 0x5d8 <mc_line>

  // Activate the probing state monitor in the stepper module.
  sys_probe_state = PROBE_ACTIVE;
     cc8:	81 e0       	ldi	r24, 0x01	; 1
     cca:	80 93 24 0c 	sts	0x0C24, r24	; 0x800c24 <sys_probe_state>

  // Perform probing cycle. Wait here until probe is triggered or motion completes.
  system_set_exec_state_flag(EXEC_CYCLE_START);
     cce:	82 e0       	ldi	r24, 0x02	; 2
     cd0:	0e 94 4b 39 	call	0x7296	; 0x7296 <system_set_exec_state_flag>
  do {
    protocol_execute_realtime();
     cd4:	0e 94 b2 17 	call	0x2f64	; 0x2f64 <protocol_execute_realtime>
    if (sys.abort) { return(GC_PROBE_ABORT); } // Check for system abort
     cd8:	80 91 12 0c 	lds	r24, 0x0C12	; 0x800c12 <sys+0x1>
     cdc:	81 11       	cpse	r24, r1
     cde:	34 c0       	rjmp	.+104    	; 0xd48 <mc_probe_cycle+0xdc>
  } while (sys.state != STATE_IDLE);
     ce0:	80 91 11 0c 	lds	r24, 0x0C11	; 0x800c11 <sys>
     ce4:	81 11       	cpse	r24, r1
     ce6:	f6 cf       	rjmp	.-20     	; 0xcd4 <mc_probe_cycle+0x68>

  // Probing cycle complete!

  // Set state variables and error out, if the probe failed and cycle with error is enabled.
  if (sys_probe_state == PROBE_ACTIVE) {
     ce8:	80 91 24 0c 	lds	r24, 0x0C24	; 0x800c24 <sys_probe_state>
     cec:	81 30       	cpi	r24, 0x01	; 1
     cee:	81 f4       	brne	.+32     	; 0xd10 <mc_probe_cycle+0xa4>
    if (is_no_error) { memcpy(sys_probe_position, sys_position, sizeof(sys_position)); }
     cf0:	dd 23       	and	r29, r29
     cf2:	51 f0       	breq	.+20     	; 0xd08 <mc_probe_cycle+0x9c>
     cf4:	8c e0       	ldi	r24, 0x0C	; 12
     cf6:	e1 e3       	ldi	r30, 0x31	; 49
     cf8:	fc e0       	ldi	r31, 0x0C	; 12
     cfa:	a5 e2       	ldi	r26, 0x25	; 37
     cfc:	bc e0       	ldi	r27, 0x0C	; 12
     cfe:	01 90       	ld	r0, Z+
     d00:	0d 92       	st	X+, r0
     d02:	8a 95       	dec	r24
     d04:	e1 f7       	brne	.-8      	; 0xcfe <mc_probe_cycle+0x92>
     d06:	07 c0       	rjmp	.+14     	; 0xd16 <mc_probe_cycle+0xaa>
    else { system_set_exec_alarm(EXEC_ALARM_PROBE_FAIL_CONTACT); }
     d08:	85 e0       	ldi	r24, 0x05	; 5
     d0a:	0e 94 a4 3b 	call	0x7748	; 0x7748 <system_set_exec_alarm>
     d0e:	03 c0       	rjmp	.+6      	; 0xd16 <mc_probe_cycle+0xaa>
  } else {
    sys.probe_succeeded = true; // Indicate to system the probing cycle completed successfully.
     d10:	81 e0       	ldi	r24, 0x01	; 1
     d12:	80 93 16 0c 	sts	0x0C16, r24	; 0x800c16 <sys+0x5>
  }
  sys_probe_state = PROBE_OFF; // Ensure probe state monitor is disabled.
     d16:	10 92 24 0c 	sts	0x0C24, r1	; 0x800c24 <sys_probe_state>
  probe_configure_invert_mask(false); // Re-initialize invert mask.
     d1a:	80 e0       	ldi	r24, 0x00	; 0
     d1c:	0e 94 e7 32 	call	0x65ce	; 0x65ce <probe_configure_invert_mask>
  protocol_execute_realtime();   // Check and execute run-time commands
     d20:	0e 94 b2 17 	call	0x2f64	; 0x2f64 <protocol_execute_realtime>

  // Reset the stepper and planner buffers to remove the remainder of the probe motion.
  st_reset(); // Reset step segment buffer.
     d24:	0e 94 11 1b 	call	0x3622	; 0x3622 <st_reset>
  plan_reset(); // Reset planner buffer. Zero planner positions. Ensure probing motion is cleared.
     d28:	0e 94 9e 28 	call	0x513c	; 0x513c <plan_reset>
  plan_sync_position(); // Sync planner position to current machine position.
     d2c:	0e 94 6f 2c 	call	0x58de	; 0x58de <plan_sync_position>

  #ifdef MESSAGE_PROBE_COORDINATES
    // All done! Output the probe position as message.
    report_probe_parameters();
     d30:	0e 94 f2 34 	call	0x69e4	; 0x69e4 <report_probe_parameters>
  #endif

  if (sys.probe_succeeded) { return(GC_PROBE_FOUND); } // Successful probe cycle.
     d34:	80 91 16 0c 	lds	r24, 0x0C16	; 0x800c16 <sys+0x5>
     d38:	88 23       	and	r24, r24
     d3a:	39 f0       	breq	.+14     	; 0xd4a <mc_probe_cycle+0xde>
     d3c:	81 e0       	ldi	r24, 0x01	; 1
     d3e:	05 c0       	rjmp	.+10     	; 0xd4a <mc_probe_cycle+0xde>
// Perform tool length probe cycle. Requires probe switch.
// NOTE: Upon probe failure, the program will be stopped and placed into ALARM state.
uint8_t mc_probe_cycle(float *target, plan_line_data_t *pl_data, uint8_t parser_flags)
{
  // TODO: Need to update this cycle so it obeys a non-auto cycle start.
  if (sys.state == STATE_CHECK_MODE) { return(GC_PROBE_CHECK_MODE); }
     d40:	80 e0       	ldi	r24, 0x00	; 0
     d42:	03 c0       	rjmp	.+6      	; 0xd4a <mc_probe_cycle+0xde>

  // Finish all queued commands and empty planner buffer before starting probe cycle.
  protocol_buffer_synchronize();
  if (sys.abort) { return(GC_PROBE_ABORT); } // Return if system reset has been issued.
     d44:	82 e0       	ldi	r24, 0x02	; 2
     d46:	01 c0       	rjmp	.+2      	; 0xd4a <mc_probe_cycle+0xde>

  // Perform probing cycle. Wait here until probe is triggered or motion completes.
  system_set_exec_state_flag(EXEC_CYCLE_START);
  do {
    protocol_execute_realtime();
    if (sys.abort) { return(GC_PROBE_ABORT); } // Check for system abort
     d48:	82 e0       	ldi	r24, 0x02	; 2
    report_probe_parameters();
  #endif

  if (sys.probe_succeeded) { return(GC_PROBE_FOUND); } // Successful probe cycle.
  else { return(GC_PROBE_FAIL_END); } // Failed to trigger probe within travel. With or without error.
}
     d4a:	df 91       	pop	r29
     d4c:	cf 91       	pop	r28
     d4e:	1f 91       	pop	r17
     d50:	0f 91       	pop	r16
     d52:	ff 90       	pop	r15
     d54:	ef 90       	pop	r14
     d56:	08 95       	ret

00000d58 <mc_reset>:
// lost, since there was an abrupt uncontrolled deceleration. Called at an interrupt level by
// realtime abort command and hard limits. So, keep to a minimum.
void mc_reset()
{
  // Only this function can set the system reset. Helps prevent multiple kill calls.
  if (bit_isfalse(sys_rt_exec_state, EXEC_RESET)) {
     d58:	80 91 23 0c 	lds	r24, 0x0C23	; 0x800c23 <sys_rt_exec_state>
     d5c:	84 fd       	sbrc	r24, 4
     d5e:	1f c0       	rjmp	.+62     	; 0xd9e <mc_reset+0x46>
    system_set_exec_state_flag(EXEC_RESET);
     d60:	80 e1       	ldi	r24, 0x10	; 16
     d62:	0e 94 4b 39 	call	0x7296	; 0x7296 <system_set_exec_state_flag>

    // Kill spindle and coolant.
    spindle_stop();
     d66:	0e 94 47 12 	call	0x248e	; 0x248e <spindle_stop>
    coolant_stop();
     d6a:	0e 94 93 13 	call	0x2726	; 0x2726 <coolant_stop>

    // Kill steppers only if in any motion state, i.e. cycle, actively holding, or homing.
    // NOTE: If steppers are kept enabled via the step idle delay setting, this also keeps
    // the steppers enabled by avoiding the go_idle call altogether, unless the motion state is
    // violated, by which, all bets are off.
    if ((sys.state & (STATE_CYCLE | STATE_HOMING | STATE_JOG)) ||
     d6e:	80 91 11 0c 	lds	r24, 0x0C11	; 0x800c11 <sys>
     d72:	98 2f       	mov	r25, r24
     d74:	9c 72       	andi	r25, 0x2C	; 44
     d76:	21 f4       	brne	.+8      	; 0xd80 <mc_reset+0x28>
    		(sys.step_control & (STEP_CONTROL_EXECUTE_HOLD | STEP_CONTROL_EXECUTE_SYS_MOTION))) {
     d78:	90 91 15 0c 	lds	r25, 0x0C15	; 0x800c15 <sys+0x4>

    // Kill steppers only if in any motion state, i.e. cycle, actively holding, or homing.
    // NOTE: If steppers are kept enabled via the step idle delay setting, this also keeps
    // the steppers enabled by avoiding the go_idle call altogether, unless the motion state is
    // violated, by which, all bets are off.
    if ((sys.state & (STATE_CYCLE | STATE_HOMING | STATE_JOG)) ||
     d7c:	96 70       	andi	r25, 0x06	; 6
     d7e:	79 f0       	breq	.+30     	; 0xd9e <mc_reset+0x46>
    		(sys.step_control & (STEP_CONTROL_EXECUTE_HOLD | STEP_CONTROL_EXECUTE_SYS_MOTION))) {
      if (sys.state == STATE_HOMING) { 
     d80:	84 30       	cpi	r24, 0x04	; 4
     d82:	41 f4       	brne	.+16     	; 0xd94 <mc_reset+0x3c>
        if (!sys_rt_exec_alarm) {system_set_exec_alarm(EXEC_ALARM_HOMING_FAIL_RESET); }
     d84:	80 91 3d 0c 	lds	r24, 0x0C3D	; 0x800c3d <sys_rt_exec_alarm>
     d88:	81 11       	cpse	r24, r1
     d8a:	07 c0       	rjmp	.+14     	; 0xd9a <mc_reset+0x42>
     d8c:	86 e0       	ldi	r24, 0x06	; 6
     d8e:	0e 94 a4 3b 	call	0x7748	; 0x7748 <system_set_exec_alarm>
     d92:	03 c0       	rjmp	.+6      	; 0xd9a <mc_reset+0x42>
      } else { system_set_exec_alarm(EXEC_ALARM_ABORT_CYCLE); }
     d94:	83 e0       	ldi	r24, 0x03	; 3
     d96:	0e 94 a4 3b 	call	0x7748	; 0x7748 <system_set_exec_alarm>
      st_go_idle(); // Force kill steppers. Position has likely been lost.
     d9a:	0c 94 92 18 	jmp	0x3124	; 0x3124 <st_go_idle>
     d9e:	08 95       	ret

00000da0 <gc_init>:
#define FAIL(status) return(status);


void gc_init()
{
  memset(&gc_state, 0, sizeof(parser_state_t));
     da0:	80 e4       	ldi	r24, 0x40	; 64
     da2:	ef e3       	ldi	r30, 0x3F	; 63
     da4:	fc e0       	ldi	r31, 0x0C	; 12
     da6:	df 01       	movw	r26, r30
     da8:	1d 92       	st	X+, r1
     daa:	8a 95       	dec	r24
     dac:	e9 f7       	brne	.-6      	; 0xda8 <gc_init+0x8>

  // Load default G54 coordinate system.
  if (!(settings_read_coord_data(gc_state.modal.coord_select,gc_state.coord_system))) {
     dae:	63 e6       	ldi	r22, 0x63	; 99
     db0:	7c e0       	ldi	r23, 0x0C	; 12
     db2:	80 e0       	ldi	r24, 0x00	; 0
     db4:	0e 94 18 25 	call	0x4a30	; 0x4a30 <settings_read_coord_data>
     db8:	81 11       	cpse	r24, r1
     dba:	03 c0       	rjmp	.+6      	; 0xdc2 <gc_init+0x22>
    report_status_message(STATUS_SETTING_READ_FAIL);
     dbc:	87 e0       	ldi	r24, 0x07	; 7
     dbe:	0c 94 78 33 	jmp	0x66f0	; 0x66f0 <report_status_message>
     dc2:	08 95       	ret

00000dc4 <gc_sync_position>:

// Sets g-code parser position in mm. Input in steps. Called by the system abort and hard
// limit pull-off routines.
void gc_sync_position()
{
  system_convert_array_steps_to_mpos(gc_state.position,sys_position);
     dc4:	61 e3       	ldi	r22, 0x31	; 49
     dc6:	7c e0       	ldi	r23, 0x0C	; 12
     dc8:	87 e5       	ldi	r24, 0x57	; 87
     dca:	9c e0       	ldi	r25, 0x0C	; 12
     dcc:	0c 94 e6 38 	jmp	0x71cc	; 0x71cc <system_convert_array_steps_to_mpos>
     dd0:	08 95       	ret

00000dd2 <gc_execute_line>:
// characters and signed floating point values (no whitespace). Comments and block delete
// characters have been removed. In this function, all units and positions are converted and
// exported to grbl's internal functions in terms of (mm, mm/min) and absolute machine
// coordinates, respectively.
uint8_t gc_execute_line(char *line)
{
     dd2:	2f 92       	push	r2
     dd4:	3f 92       	push	r3
     dd6:	4f 92       	push	r4
     dd8:	5f 92       	push	r5
     dda:	6f 92       	push	r6
     ddc:	7f 92       	push	r7
     dde:	8f 92       	push	r8
     de0:	9f 92       	push	r9
     de2:	af 92       	push	r10
     de4:	bf 92       	push	r11
     de6:	cf 92       	push	r12
     de8:	df 92       	push	r13
     dea:	ef 92       	push	r14
     dec:	ff 92       	push	r15
     dee:	0f 93       	push	r16
     df0:	1f 93       	push	r17
     df2:	cf 93       	push	r28
     df4:	df 93       	push	r29
     df6:	cd b7       	in	r28, 0x3d	; 61
     df8:	de b7       	in	r29, 0x3e	; 62
     dfa:	e3 97       	sbiw	r28, 0x33	; 51
     dfc:	0f b6       	in	r0, 0x3f	; 63
     dfe:	f8 94       	cli
     e00:	de bf       	out	0x3e, r29	; 62
     e02:	0f be       	out	0x3f, r0	; 63
     e04:	cd bf       	out	0x3d, r28	; 61
     e06:	8c 01       	movw	r16, r24
     updates these modes and commands as the block line is parser and will only be used and
     executed after successful error-checking. The parser block struct also contains a block
     values struct, word tracking variables, and a non-modal commands tracker for the new
     block. This struct contains all of the necessary information to execute the block. */

  memset(&gc_block, 0, sizeof(parser_block_t)); // Initialize the parser block struct.
     e08:	8a e3       	ldi	r24, 0x3A	; 58
     e0a:	ef e7       	ldi	r30, 0x7F	; 127
     e0c:	fc e0       	ldi	r31, 0x0C	; 12
     e0e:	df 01       	movw	r26, r30
     e10:	1d 92       	st	X+, r1
     e12:	8a 95       	dec	r24
     e14:	e9 f7       	brne	.-6      	; 0xe10 <gc_execute_line+0x3e>
  memcpy(&gc_block.modal,&gc_state.modal,sizeof(gc_modal_t)); // Copy current modes
     e16:	8b e0       	ldi	r24, 0x0B	; 11
     e18:	ef e3       	ldi	r30, 0x3F	; 63
     e1a:	fc e0       	ldi	r31, 0x0C	; 12
     e1c:	a0 e8       	ldi	r26, 0x80	; 128
     e1e:	bc e0       	ldi	r27, 0x0C	; 12
     e20:	01 90       	ld	r0, Z+
     e22:	0d 92       	st	X+, r0
     e24:	8a 95       	dec	r24
     e26:	e1 f7       	brne	.-8      	; 0xe20 <gc_execute_line+0x4e>
  uint16_t command_words = 0; // Tracks G and M command words. Also used for modal group violations.
  uint16_t value_words = 0; // Tracks value words.
  uint8_t gc_parser_flags = GC_PARSER_NONE;

  // Determine if the line is a jogging motion or a normal g-code block.
  if (line[0] == '$') { // NOTE: `$J=` already parsed when passed to this function.
     e28:	f8 01       	movw	r30, r16
     e2a:	80 81       	ld	r24, Z
     e2c:	84 32       	cpi	r24, 0x24	; 36
     e2e:	41 f4       	brne	.+16     	; 0xe40 <gc_execute_line+0x6e>
    // Set G1 and G94 enforced modes to ensure accurate error checks.
    gc_parser_flags |= GC_PARSER_JOG_MOTION;
    gc_block.modal.motion = MOTION_MODE_LINEAR;
     e30:	ef e7       	ldi	r30, 0x7F	; 127
     e32:	fc e0       	ldi	r31, 0x0C	; 12
     e34:	81 e0       	ldi	r24, 0x01	; 1
     e36:	81 83       	std	Z+1, r24	; 0x01
    gc_block.modal.feed_rate = FEED_RATE_MODE_UNITS_PER_MIN;
     e38:	12 82       	std	Z+2, r1	; 0x02
  uint8_t gc_parser_flags = GC_PARSER_NONE;

  // Determine if the line is a jogging motion or a normal g-code block.
  if (line[0] == '$') { // NOTE: `$J=` already parsed when passed to this function.
    // Set G1 and G94 enforced modes to ensure accurate error checks.
    gc_parser_flags |= GC_PARSER_JOG_MOTION;
     e3a:	99 24       	eor	r9, r9
     e3c:	93 94       	inc	r9
     e3e:	01 c0       	rjmp	.+2      	; 0xe42 <gc_execute_line+0x70>
  uint8_t ijk_words = 0; // IJK tracking

  // Initialize command and value words and parser flags variables.
  uint16_t command_words = 0; // Tracks G and M command words. Also used for modal group violations.
  uint16_t value_words = 0; // Tracks value words.
  uint8_t gc_parser_flags = GC_PARSER_NONE;
     e40:	91 2c       	mov	r9, r1
  uint8_t char_counter;
  char letter;
  float value;
  uint8_t int_value = 0;
  uint16_t mantissa = 0;
  if (gc_parser_flags & GC_PARSER_JOG_MOTION) { char_counter = 3; } // Start parsing after `$J=`
     e42:	f9 2d       	mov	r31, r9
     e44:	f1 70       	andi	r31, 0x01	; 1
     e46:	3f 2e       	mov	r3, r31
     e48:	90 fe       	sbrs	r9, 0
     e4a:	0c c0       	rjmp	.+24     	; 0xe64 <gc_execute_line+0x92>
     e4c:	83 e0       	ldi	r24, 0x03	; 3
     e4e:	89 83       	std	Y+1, r24	; 0x01
						if (value > MAX_TOOL_NUMBER) { FAIL(STATUS_GCODE_MAX_VALUE_EXCEEDED); }
						gc_block.values.t = int_value;
						break;
          case 'X': word_bit = WORD_X; gc_block.values.xyz[X_AXIS] = value; axis_words |= (1<<X_AXIS); break;
          case 'Y': word_bit = WORD_Y; gc_block.values.xyz[Y_AXIS] = value; axis_words |= (1<<Y_AXIS); break;
          case 'Z': word_bit = WORD_Z; gc_block.values.xyz[Z_AXIS] = value; axis_words |= (1<<Z_AXIS); break;
     e50:	a1 2c       	mov	r10, r1
     e52:	b1 2c       	mov	r11, r1
     e54:	e1 2c       	mov	r14, r1
     e56:	f1 2c       	mov	r15, r1
     e58:	81 2c       	mov	r8, r1
     e5a:	19 a2       	std	Y+33, r1	; 0x21
     e5c:	1a a2       	std	Y+34, r1	; 0x22
     e5e:	18 a3       	std	Y+32, r17	; 0x20
     e60:	0f 8f       	std	Y+31, r16	; 0x1f
     e62:	42 c2       	rjmp	.+1156   	; 0x12e8 <__EEPROM_REGION_LENGTH__+0x2e8>
  char letter;
  float value;
  uint8_t int_value = 0;
  uint16_t mantissa = 0;
  if (gc_parser_flags & GC_PARSER_JOG_MOTION) { char_counter = 3; } // Start parsing after `$J=`
  else { char_counter = 0; }
     e64:	19 82       	std	Y+1, r1	; 0x01
     e66:	f4 cf       	rjmp	.-24     	; 0xe50 <gc_execute_line+0x7e>

  while (line[char_counter] != 0) { // Loop until no more g-code words in line.

    // Import the next g-code word, expecting a letter followed by a value. Otherwise, error out.
    letter = line[char_counter];
    if((letter < 'A') || (letter > 'Z')) { FAIL(STATUS_EXPECTED_COMMAND_LETTER); } // [Expected word letter]
     e68:	9f eb       	ldi	r25, 0xBF	; 191
     e6a:	91 0f       	add	r25, r17
     e6c:	9a 31       	cpi	r25, 0x1A	; 26
     e6e:	10 f0       	brcs	.+4      	; 0xe74 <gc_execute_line+0xa2>
     e70:	0c 94 b3 11 	jmp	0x2366	; 0x2366 <__stack+0x167>
    char_counter++;
     e74:	8f 5f       	subi	r24, 0xFF	; 255
     e76:	89 83       	std	Y+1, r24	; 0x01
    if (!read_float(line, &char_counter, &value)) { FAIL(STATUS_BAD_NUMBER_FORMAT); } // [Expected word value]
     e78:	ae 01       	movw	r20, r28
     e7a:	4e 5f       	subi	r20, 0xFE	; 254
     e7c:	5f 4f       	sbci	r21, 0xFF	; 255
     e7e:	be 01       	movw	r22, r28
     e80:	6f 5f       	subi	r22, 0xFF	; 255
     e82:	7f 4f       	sbci	r23, 0xFF	; 255
     e84:	8f 8d       	ldd	r24, Y+31	; 0x1f
     e86:	98 a1       	ldd	r25, Y+32	; 0x20
     e88:	0e 94 9d 2c 	call	0x593a	; 0x593a <read_float>
     e8c:	88 23       	and	r24, r24
     e8e:	11 f4       	brne	.+4      	; 0xe94 <gc_execute_line+0xc2>
     e90:	0c 94 b5 11 	jmp	0x236a	; 0x236a <__stack+0x16b>
    // accurate than the NIST gcode requirement of x10 when used for commands, but not quite
    // accurate enough for value words that require integers to within 0.0001. This should be
    // a good enough comprimise and catch most all non-integer errors. To make it compliant,
    // we would simply need to change the mantissa to int16, but this add compiled flash space.
    // Maybe update this later.
    int_value = trunc(value);
     e94:	4a 80       	ldd	r4, Y+2	; 0x02
     e96:	5b 80       	ldd	r5, Y+3	; 0x03
     e98:	6c 80       	ldd	r6, Y+4	; 0x04
     e9a:	7d 80       	ldd	r7, Y+5	; 0x05
     e9c:	c3 01       	movw	r24, r6
     e9e:	b2 01       	movw	r22, r4
     ea0:	0e 94 1a 40 	call	0x8034	; 0x8034 <trunc>
     ea4:	0e 94 82 3d 	call	0x7b04	; 0x7b04 <__fixunssfsi>
     ea8:	c6 2e       	mov	r12, r22
    mantissa =  round(100*(value - int_value)); // Compute mantissa for Gxx.x commands.
     eaa:	70 e0       	ldi	r23, 0x00	; 0
     eac:	80 e0       	ldi	r24, 0x00	; 0
     eae:	90 e0       	ldi	r25, 0x00	; 0
     eb0:	0e 94 b0 3d 	call	0x7b60	; 0x7b60 <__floatsisf>
     eb4:	9b 01       	movw	r18, r22
     eb6:	ac 01       	movw	r20, r24
     eb8:	c3 01       	movw	r24, r6
     eba:	b2 01       	movw	r22, r4
     ebc:	0e 94 34 3c 	call	0x7868	; 0x7868 <__subsf3>
     ec0:	20 e0       	ldi	r18, 0x00	; 0
     ec2:	30 e0       	ldi	r19, 0x00	; 0
     ec4:	48 ec       	ldi	r20, 0xC8	; 200
     ec6:	52 e4       	ldi	r21, 0x42	; 66
     ec8:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
     ecc:	0e 94 af 3f 	call	0x7f5e	; 0x7f5e <round>
     ed0:	0e 94 82 3d 	call	0x7b04	; 0x7b04 <__fixunssfsi>
     ed4:	86 2f       	mov	r24, r22
     ed6:	97 2f       	mov	r25, r23
     ed8:	9c 01       	movw	r18, r24
    // NOTE: Rounding must be used to catch small floating point errors.

    // Check if the g-code word is supported or errors due to modal group violations or has
    // been repeated in the g-code block. If ok, update the command or record its value.
    switch(letter) {
     eda:	17 34       	cpi	r17, 0x47	; 71
     edc:	21 f0       	breq	.+8      	; 0xee6 <gc_execute_line+0x114>
     ede:	1d 34       	cpi	r17, 0x4D	; 77
     ee0:	09 f4       	brne	.+2      	; 0xee4 <gc_execute_line+0x112>
     ee2:	cc c0       	rjmp	.+408    	; 0x107c <__EEPROM_REGION_LENGTH__+0x7c>
     ee4:	34 c1       	rjmp	.+616    	; 0x114e <__EEPROM_REGION_LENGTH__+0x14e>
      /* 'G' and 'M' Command Words: Parse commands and check for modal group violations.
         NOTE: Modal group numbers are defined in Table 4 of NIST RS274-NGC v3, pg.20 */

      case 'G':
        // Determine 'G' command and its modal group
        switch(int_value) {
     ee6:	8c 2d       	mov	r24, r12
     ee8:	90 e0       	ldi	r25, 0x00	; 0
     eea:	8f 35       	cpi	r24, 0x5F	; 95
     eec:	91 05       	cpc	r25, r1
     eee:	10 f0       	brcs	.+4      	; 0xef4 <gc_execute_line+0x122>
     ef0:	0c 94 b7 11 	jmp	0x236e	; 0x236e <__stack+0x16f>
     ef4:	fc 01       	movw	r30, r24
     ef6:	88 27       	eor	r24, r24
     ef8:	ee 58       	subi	r30, 0x8E	; 142
     efa:	ff 4f       	sbci	r31, 0xFF	; 255
     efc:	8f 4f       	sbci	r24, 0xFF	; 255
     efe:	0c 94 5b 40 	jmp	0x80b6	; 0x80b6 <__tablejump2__>
          case 10: case 28: case 30: case 92:
            // Check for G10/28/30/92 being called with G0/1/2/3/38 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (mantissa == 0) { // Ignore G28.1, G30.1, and G92.1
     f02:	21 15       	cp	r18, r1
     f04:	31 05       	cpc	r19, r1
     f06:	31 f4       	brne	.+12     	; 0xf14 <gc_execute_line+0x142>
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
     f08:	4a a1       	ldd	r20, Y+34	; 0x22
     f0a:	41 11       	cpse	r20, r1
     f0c:	0c 94 b9 11 	jmp	0x2372	; 0x2372 <__stack+0x173>
              axis_command = AXIS_COMMAND_NON_MODAL;
     f10:	51 e0       	ldi	r21, 0x01	; 1
     f12:	5a a3       	std	Y+34, r21	; 0x22
            }
            // No break. Continues to next line.
          case 4: case 53:
            word_bit = MODAL_GROUP_G0;
            gc_block.non_modal_command = int_value;
     f14:	c0 92 7f 0c 	sts	0x0C7F, r12	; 0x800c7f <gc_block>
            if ((int_value == 28) || (int_value == 30) || (int_value == 92)) {
     f18:	8c e1       	ldi	r24, 0x1C	; 28
     f1a:	c8 16       	cp	r12, r24
     f1c:	31 f0       	breq	.+12     	; 0xf2a <gc_execute_line+0x158>
     f1e:	9e e1       	ldi	r25, 0x1E	; 30
     f20:	c9 16       	cp	r12, r25
     f22:	19 f0       	breq	.+6      	; 0xf2a <gc_execute_line+0x158>
     f24:	ac e5       	ldi	r26, 0x5C	; 92
     f26:	ca 12       	cpse	r12, r26
     f28:	91 c0       	rjmp	.+290    	; 0x104c <__EEPROM_REGION_LENGTH__+0x4c>
              if (!((mantissa == 0) || (mantissa == 10))) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); }
     f2a:	21 15       	cp	r18, r1
     f2c:	31 05       	cpc	r19, r1
     f2e:	29 f0       	breq	.+10     	; 0xf3a <gc_execute_line+0x168>
     f30:	2a 30       	cpi	r18, 0x0A	; 10
     f32:	31 05       	cpc	r19, r1
     f34:	11 f0       	breq	.+4      	; 0xf3a <gc_execute_line+0x168>
     f36:	0c 94 bb 11 	jmp	0x2376	; 0x2376 <__stack+0x177>
              gc_block.non_modal_command += mantissa;
     f3a:	6c 0d       	add	r22, r12
     f3c:	60 93 7f 0c 	sts	0x0C7F, r22	; 0x800c7f <gc_block>
              mantissa = 0; // Set to zero to indicate valid non-integer G command.
     f40:	20 e0       	ldi	r18, 0x00	; 0
     f42:	30 e0       	ldi	r19, 0x00	; 0
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53:
            word_bit = MODAL_GROUP_G0;
     f44:	40 e0       	ldi	r20, 0x00	; 0
     f46:	85 c0       	rjmp	.+266    	; 0x1052 <__EEPROM_REGION_LENGTH__+0x52>
            }                
            break;
          case 0: case 1: case 2: case 3: case 38:
            // Check for G0/1/2/3/38 being called with G10/28/30/92 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
     f48:	ba a1       	ldd	r27, Y+34	; 0x22
     f4a:	b1 11       	cpse	r27, r1
     f4c:	0c 94 bd 11 	jmp	0x237a	; 0x237a <__stack+0x17b>
            axis_command = AXIS_COMMAND_MOTION_MODE;
     f50:	e2 e0       	ldi	r30, 0x02	; 2
     f52:	ea a3       	std	Y+34, r30	; 0x22
            // No break. Continues to next line.
          case 80:
            word_bit = MODAL_GROUP_G1;
            gc_block.modal.motion = int_value;
     f54:	c0 92 80 0c 	sts	0x0C80, r12	; 0x800c80 <gc_block+0x1>
            if (int_value == 38){
     f58:	f6 e2       	ldi	r31, 0x26	; 38
     f5a:	cf 12       	cpse	r12, r31
     f5c:	79 c0       	rjmp	.+242    	; 0x1050 <__EEPROM_REGION_LENGTH__+0x50>
              if (!((mantissa == 20) || (mantissa == 30) || (mantissa == 40) || (mantissa == 50))) {
     f5e:	24 31       	cpi	r18, 0x14	; 20
     f60:	31 05       	cpc	r19, r1
     f62:	59 f0       	breq	.+22     	; 0xf7a <gc_execute_line+0x1a8>
     f64:	2e 31       	cpi	r18, 0x1E	; 30
     f66:	31 05       	cpc	r19, r1
     f68:	41 f0       	breq	.+16     	; 0xf7a <gc_execute_line+0x1a8>
     f6a:	28 32       	cpi	r18, 0x28	; 40
     f6c:	31 05       	cpc	r19, r1
     f6e:	29 f0       	breq	.+10     	; 0xf7a <gc_execute_line+0x1a8>
     f70:	22 33       	cpi	r18, 0x32	; 50
     f72:	31 05       	cpc	r19, r1
     f74:	11 f0       	breq	.+4      	; 0xf7a <gc_execute_line+0x1a8>
     f76:	0c 94 bf 11 	jmp	0x237e	; 0x237e <__stack+0x17f>
                FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G38.x command]
              }
              gc_block.modal.motion += (mantissa/10)+100;
     f7a:	26 2f       	mov	r18, r22
     f7c:	37 2f       	mov	r19, r23
     f7e:	ad ec       	ldi	r26, 0xCD	; 205
     f80:	bc ec       	ldi	r27, 0xCC	; 204
     f82:	0e 94 63 40 	call	0x80c6	; 0x80c6 <__umulhisi3>
     f86:	96 95       	lsr	r25
     f88:	87 95       	ror	r24
     f8a:	96 95       	lsr	r25
     f8c:	87 95       	ror	r24
     f8e:	96 95       	lsr	r25
     f90:	87 95       	ror	r24
     f92:	8c 0d       	add	r24, r12
     f94:	8c 59       	subi	r24, 0x9C	; 156
     f96:	80 93 80 0c 	sts	0x0C80, r24	; 0x800c80 <gc_block+0x1>
              mantissa = 0; // Set to zero to indicate valid non-integer G command.
     f9a:	20 e0       	ldi	r18, 0x00	; 0
     f9c:	30 e0       	ldi	r19, 0x00	; 0
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE;
            // No break. Continues to next line.
          case 80:
            word_bit = MODAL_GROUP_G1;
     f9e:	41 e0       	ldi	r20, 0x01	; 1
     fa0:	58 c0       	rjmp	.+176    	; 0x1052 <__EEPROM_REGION_LENGTH__+0x52>
              mantissa = 0; // Set to zero to indicate valid non-integer G command.
            }  
            break;
          case 17: case 18: case 19:
            word_bit = MODAL_GROUP_G2;
            gc_block.modal.plane_select = int_value - 17;
     fa2:	8f ee       	ldi	r24, 0xEF	; 239
     fa4:	8c 0d       	add	r24, r12
     fa6:	80 93 84 0c 	sts	0x0C84, r24	; 0x800c84 <gc_block+0x5>
              gc_block.modal.motion += (mantissa/10)+100;
              mantissa = 0; // Set to zero to indicate valid non-integer G command.
            }  
            break;
          case 17: case 18: case 19:
            word_bit = MODAL_GROUP_G2;
     faa:	42 e0       	ldi	r20, 0x02	; 2
            gc_block.modal.plane_select = int_value - 17;
            break;
     fac:	52 c0       	rjmp	.+164    	; 0x1052 <__EEPROM_REGION_LENGTH__+0x52>
          case 90: case 91:
            if (mantissa == 0) {
     fae:	21 15       	cp	r18, r1
     fb0:	31 05       	cpc	r19, r1
     fb2:	31 f4       	brne	.+12     	; 0xfc0 <gc_execute_line+0x1ee>
              word_bit = MODAL_GROUP_G3;
              gc_block.modal.distance = int_value - 90;
     fb4:	86 ea       	ldi	r24, 0xA6	; 166
     fb6:	8c 0d       	add	r24, r12
     fb8:	80 93 83 0c 	sts	0x0C83, r24	; 0x800c83 <gc_block+0x4>
            word_bit = MODAL_GROUP_G2;
            gc_block.modal.plane_select = int_value - 17;
            break;
          case 90: case 91:
            if (mantissa == 0) {
              word_bit = MODAL_GROUP_G3;
     fbc:	43 e0       	ldi	r20, 0x03	; 3
     fbe:	49 c0       	rjmp	.+146    	; 0x1052 <__EEPROM_REGION_LENGTH__+0x52>
              gc_block.modal.distance = int_value - 90;
            } else {
              word_bit = MODAL_GROUP_G4;
              if ((mantissa != 10) || (int_value == 90)) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G90.1 not supported]
     fc0:	2a 30       	cpi	r18, 0x0A	; 10
     fc2:	31 05       	cpc	r19, r1
     fc4:	11 f0       	breq	.+4      	; 0xfca <gc_execute_line+0x1f8>
     fc6:	0c 94 c1 11 	jmp	0x2382	; 0x2382 <__stack+0x183>
     fca:	2a e5       	ldi	r18, 0x5A	; 90
     fcc:	c2 16       	cp	r12, r18
     fce:	11 f4       	brne	.+4      	; 0xfd4 <gc_execute_line+0x202>
     fd0:	0c 94 c3 11 	jmp	0x2386	; 0x2386 <__stack+0x187>
              mantissa = 0; // Set to zero to indicate valid non-integer G command.
     fd4:	20 e0       	ldi	r18, 0x00	; 0
     fd6:	30 e0       	ldi	r19, 0x00	; 0
          case 90: case 91:
            if (mantissa == 0) {
              word_bit = MODAL_GROUP_G3;
              gc_block.modal.distance = int_value - 90;
            } else {
              word_bit = MODAL_GROUP_G4;
     fd8:	44 e0       	ldi	r20, 0x04	; 4
     fda:	3b c0       	rjmp	.+118    	; 0x1052 <__EEPROM_REGION_LENGTH__+0x52>
              // Otherwise, arc IJK incremental mode is default. G91.1 does nothing.
            }
            break;
          case 93: case 94:
            word_bit = MODAL_GROUP_G5;
            gc_block.modal.feed_rate = 94 - int_value;
     fdc:	8e e5       	ldi	r24, 0x5E	; 94
     fde:	8c 19       	sub	r24, r12
     fe0:	80 93 81 0c 	sts	0x0C81, r24	; 0x800c81 <gc_block+0x2>
              mantissa = 0; // Set to zero to indicate valid non-integer G command.
              // Otherwise, arc IJK incremental mode is default. G91.1 does nothing.
            }
            break;
          case 93: case 94:
            word_bit = MODAL_GROUP_G5;
     fe4:	45 e0       	ldi	r20, 0x05	; 5
            gc_block.modal.feed_rate = 94 - int_value;
            break;
     fe6:	35 c0       	rjmp	.+106    	; 0x1052 <__EEPROM_REGION_LENGTH__+0x52>
          case 20: case 21:
            word_bit = MODAL_GROUP_G6;
            gc_block.modal.units = 21 - int_value;
     fe8:	85 e1       	ldi	r24, 0x15	; 21
     fea:	8c 19       	sub	r24, r12
     fec:	80 93 82 0c 	sts	0x0C82, r24	; 0x800c82 <gc_block+0x3>
          case 93: case 94:
            word_bit = MODAL_GROUP_G5;
            gc_block.modal.feed_rate = 94 - int_value;
            break;
          case 20: case 21:
            word_bit = MODAL_GROUP_G6;
     ff0:	46 e0       	ldi	r20, 0x06	; 6
            gc_block.modal.units = 21 - int_value;
            break;
     ff2:	2f c0       	rjmp	.+94     	; 0x1052 <__EEPROM_REGION_LENGTH__+0x52>
          case 43: case 49:
            word_bit = MODAL_GROUP_G8;
            // NOTE: The NIST g-code standard vaguely states that when a tool length offset is changed,
            // there cannot be any axis motion or coordinate offsets updated. Meaning G43, G43.1, and G49
            // all are explicit axis commands, regardless if they require axis words or not.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict] }
     ff4:	4a a1       	ldd	r20, Y+34	; 0x22
     ff6:	41 11       	cpse	r20, r1
     ff8:	0c 94 c5 11 	jmp	0x238a	; 0x238a <__stack+0x18b>
            axis_command = AXIS_COMMAND_TOOL_LENGTH_OFFSET;
            if (int_value == 49) { // G49
     ffc:	51 e3       	ldi	r21, 0x31	; 49
     ffe:	c5 12       	cpse	r12, r21
    1000:	08 c0       	rjmp	.+16     	; 0x1012 <__EEPROM_REGION_LENGTH__+0x12>
              gc_block.modal.tool_length = TOOL_LENGTH_OFFSET_CANCEL;
    1002:	10 92 85 0c 	sts	0x0C85, r1	; 0x800c85 <gc_block+0x6>
            } else if (mantissa == 10) { // G43.1
              gc_block.modal.tool_length = TOOL_LENGTH_OFFSET_ENABLE_DYNAMIC;
            } else { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [Unsupported G43.x command]
            mantissa = 0; // Set to zero to indicate valid non-integer G command.
    1006:	20 e0       	ldi	r18, 0x00	; 0
    1008:	30 e0       	ldi	r19, 0x00	; 0
            // NOTE: Not required since cutter radius compensation is always disabled. Only here
            // to support G40 commands that often appear in g-code program headers to setup defaults.
            // gc_block.modal.cutter_comp = CUTTER_COMP_DISABLE; // G40
            break;
          case 43: case 49:
            word_bit = MODAL_GROUP_G8;
    100a:	48 e0       	ldi	r20, 0x08	; 8
            // NOTE: The NIST g-code standard vaguely states that when a tool length offset is changed,
            // there cannot be any axis motion or coordinate offsets updated. Meaning G43, G43.1, and G49
            // all are explicit axis commands, regardless if they require axis words or not.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict] }
            axis_command = AXIS_COMMAND_TOOL_LENGTH_OFFSET;
    100c:	83 e0       	ldi	r24, 0x03	; 3
    100e:	8a a3       	std	Y+34, r24	; 0x22
    1010:	20 c0       	rjmp	.+64     	; 0x1052 <__EEPROM_REGION_LENGTH__+0x52>
            if (int_value == 49) { // G49
              gc_block.modal.tool_length = TOOL_LENGTH_OFFSET_CANCEL;
            } else if (mantissa == 10) { // G43.1
    1012:	2a 30       	cpi	r18, 0x0A	; 10
    1014:	31 05       	cpc	r19, r1
    1016:	11 f0       	breq	.+4      	; 0x101c <__EEPROM_REGION_LENGTH__+0x1c>
    1018:	0c 94 c7 11 	jmp	0x238e	; 0x238e <__stack+0x18f>
              gc_block.modal.tool_length = TOOL_LENGTH_OFFSET_ENABLE_DYNAMIC;
    101c:	81 e0       	ldi	r24, 0x01	; 1
    101e:	80 93 85 0c 	sts	0x0C85, r24	; 0x800c85 <gc_block+0x6>
            } else { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [Unsupported G43.x command]
            mantissa = 0; // Set to zero to indicate valid non-integer G command.
    1022:	20 e0       	ldi	r18, 0x00	; 0
    1024:	30 e0       	ldi	r19, 0x00	; 0
            // NOTE: Not required since cutter radius compensation is always disabled. Only here
            // to support G40 commands that often appear in g-code program headers to setup defaults.
            // gc_block.modal.cutter_comp = CUTTER_COMP_DISABLE; // G40
            break;
          case 43: case 49:
            word_bit = MODAL_GROUP_G8;
    1026:	48 e0       	ldi	r20, 0x08	; 8
            // NOTE: The NIST g-code standard vaguely states that when a tool length offset is changed,
            // there cannot be any axis motion or coordinate offsets updated. Meaning G43, G43.1, and G49
            // all are explicit axis commands, regardless if they require axis words or not.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict] }
            axis_command = AXIS_COMMAND_TOOL_LENGTH_OFFSET;
    1028:	93 e0       	ldi	r25, 0x03	; 3
    102a:	9a a3       	std	Y+34, r25	; 0x22
    102c:	12 c0       	rjmp	.+36     	; 0x1052 <__EEPROM_REGION_LENGTH__+0x52>
            mantissa = 0; // Set to zero to indicate valid non-integer G command.
            break;
          case 54: case 55: case 56: case 57: case 58: case 59:
            // NOTE: G59.x are not supported. (But their int_values would be 60, 61, and 62.)
            word_bit = MODAL_GROUP_G12;
            gc_block.modal.coord_select = int_value - 54; // Shift to array indexing.
    102e:	8a ec       	ldi	r24, 0xCA	; 202
    1030:	8c 0d       	add	r24, r12
    1032:	80 93 86 0c 	sts	0x0C86, r24	; 0x800c86 <gc_block+0x7>
            } else { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [Unsupported G43.x command]
            mantissa = 0; // Set to zero to indicate valid non-integer G command.
            break;
          case 54: case 55: case 56: case 57: case 58: case 59:
            // NOTE: G59.x are not supported. (But their int_values would be 60, 61, and 62.)
            word_bit = MODAL_GROUP_G12;
    1036:	49 e0       	ldi	r20, 0x09	; 9
            gc_block.modal.coord_select = int_value - 54; // Shift to array indexing.
            break;
    1038:	0c c0       	rjmp	.+24     	; 0x1052 <__EEPROM_REGION_LENGTH__+0x52>
          case 61:
            word_bit = MODAL_GROUP_G13;
            if (mantissa != 0) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G61.1 not supported]
    103a:	21 15       	cp	r18, r1
    103c:	31 05       	cpc	r19, r1
    103e:	11 f0       	breq	.+4      	; 0x1044 <__EEPROM_REGION_LENGTH__+0x44>
    1040:	0c 94 c9 11 	jmp	0x2392	; 0x2392 <__stack+0x193>
            // NOTE: G59.x are not supported. (But their int_values would be 60, 61, and 62.)
            word_bit = MODAL_GROUP_G12;
            gc_block.modal.coord_select = int_value - 54; // Shift to array indexing.
            break;
          case 61:
            word_bit = MODAL_GROUP_G13;
    1044:	4a e0       	ldi	r20, 0x0A	; 10
    1046:	05 c0       	rjmp	.+10     	; 0x1052 <__EEPROM_REGION_LENGTH__+0x52>
          case 20: case 21:
            word_bit = MODAL_GROUP_G6;
            gc_block.modal.units = 21 - int_value;
            break;
          case 40:
            word_bit = MODAL_GROUP_G7;
    1048:	47 e0       	ldi	r20, 0x07	; 7
    104a:	03 c0       	rjmp	.+6      	; 0x1052 <__EEPROM_REGION_LENGTH__+0x52>
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53:
            word_bit = MODAL_GROUP_G0;
    104c:	40 e0       	ldi	r20, 0x00	; 0
    104e:	01 c0       	rjmp	.+2      	; 0x1052 <__EEPROM_REGION_LENGTH__+0x52>
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE;
            // No break. Continues to next line.
          case 80:
            word_bit = MODAL_GROUP_G1;
    1050:	41 e0       	ldi	r20, 0x01	; 1
            if (mantissa != 0) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G61.1 not supported]
            // gc_block.modal.control = CONTROL_MODE_EXACT_PATH; // G61
            break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G command]
        }
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [Unsupported or invalid Gxx.x command]
    1052:	23 2b       	or	r18, r19
    1054:	11 f0       	breq	.+4      	; 0x105a <__EEPROM_REGION_LENGTH__+0x5a>
    1056:	0c 94 cb 11 	jmp	0x2396	; 0x2396 <__stack+0x197>
        // Check for more than one command per modal group violations in the current block
        // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
        if ( bit_istrue(command_words,bit(word_bit)) ) { FAIL(STATUS_GCODE_MODAL_GROUP_VIOLATION); }
    105a:	81 e0       	ldi	r24, 0x01	; 1
    105c:	90 e0       	ldi	r25, 0x00	; 0
    105e:	02 c0       	rjmp	.+4      	; 0x1064 <__EEPROM_REGION_LENGTH__+0x64>
    1060:	88 0f       	add	r24, r24
    1062:	99 1f       	adc	r25, r25
    1064:	4a 95       	dec	r20
    1066:	e2 f7       	brpl	.-8      	; 0x1060 <__EEPROM_REGION_LENGTH__+0x60>
    1068:	97 01       	movw	r18, r14
    106a:	28 23       	and	r18, r24
    106c:	39 23       	and	r19, r25
    106e:	23 2b       	or	r18, r19
    1070:	11 f0       	breq	.+4      	; 0x1076 <__EEPROM_REGION_LENGTH__+0x76>
    1072:	0c 94 cd 11 	jmp	0x239a	; 0x239a <__stack+0x19b>
        command_words |= bit(word_bit);
    1076:	e8 2a       	or	r14, r24
    1078:	f9 2a       	or	r15, r25
        break;
    107a:	36 c1       	rjmp	.+620    	; 0x12e8 <__EEPROM_REGION_LENGTH__+0x2e8>

      case 'M':

        // Determine 'M' command and its modal group
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [No Mxx.x commands]
    107c:	23 2b       	or	r18, r19
    107e:	11 f0       	breq	.+4      	; 0x1084 <__EEPROM_REGION_LENGTH__+0x84>
    1080:	0c 94 cf 11 	jmp	0x239e	; 0x239e <__stack+0x19f>
        switch(int_value) {
    1084:	8c 2d       	mov	r24, r12
    1086:	90 e0       	ldi	r25, 0x00	; 0
    1088:	8f 31       	cpi	r24, 0x1F	; 31
    108a:	91 05       	cpc	r25, r1
    108c:	10 f0       	brcs	.+4      	; 0x1092 <__EEPROM_REGION_LENGTH__+0x92>
    108e:	0c 94 d1 11 	jmp	0x23a2	; 0x23a2 <__stack+0x1a3>
    1092:	fc 01       	movw	r30, r24
    1094:	88 27       	eor	r24, r24
    1096:	ef 52       	subi	r30, 0x2F	; 47
    1098:	ff 4f       	sbci	r31, 0xFF	; 255
    109a:	8f 4f       	sbci	r24, 0xFF	; 255
    109c:	0c 94 5b 40 	jmp	0x80b6	; 0x80b6 <__tablejump2__>
          case 0: case 1: case 2: case 30:
            word_bit = MODAL_GROUP_M4;
            switch(int_value) {
    10a0:	cc 20       	and	r12, r12
    10a2:	21 f0       	breq	.+8      	; 0x10ac <__EEPROM_REGION_LENGTH__+0xac>
    10a4:	a1 e0       	ldi	r26, 0x01	; 1
    10a6:	ca 16       	cp	r12, r26
    10a8:	e1 f1       	breq	.+120    	; 0x1122 <__EEPROM_REGION_LENGTH__+0x122>
    10aa:	05 c0       	rjmp	.+10     	; 0x10b6 <__EEPROM_REGION_LENGTH__+0xb6>
              case 0: gc_block.modal.program_flow = PROGRAM_FLOW_PAUSED; break; // Program pause
    10ac:	83 e0       	ldi	r24, 0x03	; 3
    10ae:	80 93 87 0c 	sts	0x0C87, r24	; 0x800c87 <gc_block+0x8>

        // Determine 'M' command and its modal group
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [No Mxx.x commands]
        switch(int_value) {
          case 0: case 1: case 2: case 30:
            word_bit = MODAL_GROUP_M4;
    10b2:	2b e0       	ldi	r18, 0x0B	; 11
            switch(int_value) {
              case 0: gc_block.modal.program_flow = PROGRAM_FLOW_PAUSED; break; // Program pause
    10b4:	3b c0       	rjmp	.+118    	; 0x112c <__EEPROM_REGION_LENGTH__+0x12c>
              case 1: break; // Optional stop not supported. Ignore.
              default: gc_block.modal.program_flow = int_value; // Program end and reset
    10b6:	c0 92 87 0c 	sts	0x0C87, r12	; 0x800c87 <gc_block+0x8>

        // Determine 'M' command and its modal group
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [No Mxx.x commands]
        switch(int_value) {
          case 0: case 1: case 2: case 30:
            word_bit = MODAL_GROUP_M4;
    10ba:	2b e0       	ldi	r18, 0x0B	; 11
    10bc:	37 c0       	rjmp	.+110    	; 0x112c <__EEPROM_REGION_LENGTH__+0x12c>
              default: gc_block.modal.program_flow = int_value; // Program end and reset
            }
            break;
          case 3: case 4: case 5:
            word_bit = MODAL_GROUP_M7;
            switch(int_value) {
    10be:	b4 e0       	ldi	r27, 0x04	; 4
    10c0:	cb 16       	cp	r12, r27
    10c2:	59 f0       	breq	.+22     	; 0x10da <__EEPROM_REGION_LENGTH__+0xda>
    10c4:	e5 e0       	ldi	r30, 0x05	; 5
    10c6:	ce 16       	cp	r12, r30
    10c8:	69 f0       	breq	.+26     	; 0x10e4 <__EEPROM_REGION_LENGTH__+0xe4>
    10ca:	f3 e0       	ldi	r31, 0x03	; 3
    10cc:	cf 12       	cpse	r12, r31
    10ce:	2b c0       	rjmp	.+86     	; 0x1126 <__EEPROM_REGION_LENGTH__+0x126>
              case 3: gc_block.modal.spindle = SPINDLE_ENABLE_CW; break;
    10d0:	80 e1       	ldi	r24, 0x10	; 16
    10d2:	80 93 89 0c 	sts	0x0C89, r24	; 0x800c89 <gc_block+0xa>
              case 1: break; // Optional stop not supported. Ignore.
              default: gc_block.modal.program_flow = int_value; // Program end and reset
            }
            break;
          case 3: case 4: case 5:
            word_bit = MODAL_GROUP_M7;
    10d6:	2c e0       	ldi	r18, 0x0C	; 12
            switch(int_value) {
              case 3: gc_block.modal.spindle = SPINDLE_ENABLE_CW; break;
    10d8:	29 c0       	rjmp	.+82     	; 0x112c <__EEPROM_REGION_LENGTH__+0x12c>
              case 4: gc_block.modal.spindle = SPINDLE_ENABLE_CCW; break;
    10da:	80 e2       	ldi	r24, 0x20	; 32
    10dc:	80 93 89 0c 	sts	0x0C89, r24	; 0x800c89 <gc_block+0xa>
              case 1: break; // Optional stop not supported. Ignore.
              default: gc_block.modal.program_flow = int_value; // Program end and reset
            }
            break;
          case 3: case 4: case 5:
            word_bit = MODAL_GROUP_M7;
    10e0:	2c e0       	ldi	r18, 0x0C	; 12
            switch(int_value) {
              case 3: gc_block.modal.spindle = SPINDLE_ENABLE_CW; break;
              case 4: gc_block.modal.spindle = SPINDLE_ENABLE_CCW; break;
    10e2:	24 c0       	rjmp	.+72     	; 0x112c <__EEPROM_REGION_LENGTH__+0x12c>
              case 5: gc_block.modal.spindle = SPINDLE_DISABLE; break;
    10e4:	10 92 89 0c 	sts	0x0C89, r1	; 0x800c89 <gc_block+0xa>
              case 1: break; // Optional stop not supported. Ignore.
              default: gc_block.modal.program_flow = int_value; // Program end and reset
            }
            break;
          case 3: case 4: case 5:
            word_bit = MODAL_GROUP_M7;
    10e8:	2c e0       	ldi	r18, 0x0C	; 12
            switch(int_value) {
              case 3: gc_block.modal.spindle = SPINDLE_ENABLE_CW; break;
              case 4: gc_block.modal.spindle = SPINDLE_ENABLE_CCW; break;
              case 5: gc_block.modal.spindle = SPINDLE_DISABLE; break;
    10ea:	20 c0       	rjmp	.+64     	; 0x112c <__EEPROM_REGION_LENGTH__+0x12c>
            }
            break;            
          case 7: case 8: case 9:
            word_bit = MODAL_GROUP_M8; 
            switch(int_value) {      
    10ec:	28 e0       	ldi	r18, 0x08	; 8
    10ee:	c2 16       	cp	r12, r18
    10f0:	69 f0       	breq	.+26     	; 0x110c <__EEPROM_REGION_LENGTH__+0x10c>
    10f2:	39 e0       	ldi	r19, 0x09	; 9
    10f4:	c3 16       	cp	r12, r19
    10f6:	89 f0       	breq	.+34     	; 0x111a <__EEPROM_REGION_LENGTH__+0x11a>
    10f8:	47 e0       	ldi	r20, 0x07	; 7
    10fa:	c4 12       	cpse	r12, r20
    10fc:	16 c0       	rjmp	.+44     	; 0x112a <__EEPROM_REGION_LENGTH__+0x12a>
              case 7: gc_block.modal.coolant |= COOLANT_MIST_ENABLE; break;
    10fe:	ef e7       	ldi	r30, 0x7F	; 127
    1100:	fc e0       	ldi	r31, 0x0C	; 12
    1102:	81 85       	ldd	r24, Z+9	; 0x09
    1104:	80 68       	ori	r24, 0x80	; 128
    1106:	81 87       	std	Z+9, r24	; 0x09
              case 4: gc_block.modal.spindle = SPINDLE_ENABLE_CCW; break;
              case 5: gc_block.modal.spindle = SPINDLE_DISABLE; break;
            }
            break;            
          case 7: case 8: case 9:
            word_bit = MODAL_GROUP_M8; 
    1108:	2d e0       	ldi	r18, 0x0D	; 13
            switch(int_value) {      
              case 7: gc_block.modal.coolant |= COOLANT_MIST_ENABLE; break;
    110a:	10 c0       	rjmp	.+32     	; 0x112c <__EEPROM_REGION_LENGTH__+0x12c>
              case 8: gc_block.modal.coolant |= COOLANT_FLOOD_ENABLE; break;
    110c:	ef e7       	ldi	r30, 0x7F	; 127
    110e:	fc e0       	ldi	r31, 0x0C	; 12
    1110:	81 85       	ldd	r24, Z+9	; 0x09
    1112:	80 64       	ori	r24, 0x40	; 64
    1114:	81 87       	std	Z+9, r24	; 0x09
              case 4: gc_block.modal.spindle = SPINDLE_ENABLE_CCW; break;
              case 5: gc_block.modal.spindle = SPINDLE_DISABLE; break;
            }
            break;            
          case 7: case 8: case 9:
            word_bit = MODAL_GROUP_M8; 
    1116:	2d e0       	ldi	r18, 0x0D	; 13
            switch(int_value) {      
              case 7: gc_block.modal.coolant |= COOLANT_MIST_ENABLE; break;
              case 8: gc_block.modal.coolant |= COOLANT_FLOOD_ENABLE; break;
    1118:	09 c0       	rjmp	.+18     	; 0x112c <__EEPROM_REGION_LENGTH__+0x12c>
              case 9: gc_block.modal.coolant = COOLANT_DISABLE; break; // M9 disables both M7 and M8.
    111a:	10 92 88 0c 	sts	0x0C88, r1	; 0x800c88 <gc_block+0x9>
              case 4: gc_block.modal.spindle = SPINDLE_ENABLE_CCW; break;
              case 5: gc_block.modal.spindle = SPINDLE_DISABLE; break;
            }
            break;            
          case 7: case 8: case 9:
            word_bit = MODAL_GROUP_M8; 
    111e:	2d e0       	ldi	r18, 0x0D	; 13
            switch(int_value) {      
              case 7: gc_block.modal.coolant |= COOLANT_MIST_ENABLE; break;
              case 8: gc_block.modal.coolant |= COOLANT_FLOOD_ENABLE; break;
              case 9: gc_block.modal.coolant = COOLANT_DISABLE; break; // M9 disables both M7 and M8.
    1120:	05 c0       	rjmp	.+10     	; 0x112c <__EEPROM_REGION_LENGTH__+0x12c>

        // Determine 'M' command and its modal group
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [No Mxx.x commands]
        switch(int_value) {
          case 0: case 1: case 2: case 30:
            word_bit = MODAL_GROUP_M4;
    1122:	2b e0       	ldi	r18, 0x0B	; 11
    1124:	03 c0       	rjmp	.+6      	; 0x112c <__EEPROM_REGION_LENGTH__+0x12c>
              case 1: break; // Optional stop not supported. Ignore.
              default: gc_block.modal.program_flow = int_value; // Program end and reset
            }
            break;
          case 3: case 4: case 5:
            word_bit = MODAL_GROUP_M7;
    1126:	2c e0       	ldi	r18, 0x0C	; 12
    1128:	01 c0       	rjmp	.+2      	; 0x112c <__EEPROM_REGION_LENGTH__+0x12c>
              case 4: gc_block.modal.spindle = SPINDLE_ENABLE_CCW; break;
              case 5: gc_block.modal.spindle = SPINDLE_DISABLE; break;
            }
            break;            
          case 7: case 8: case 9:
            word_bit = MODAL_GROUP_M8; 
    112a:	2d e0       	ldi	r18, 0x0D	; 13
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported M command]
        }

        // Check for more than one command per modal group violations in the current block
        // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
        if ( bit_istrue(command_words,bit(word_bit)) ) { FAIL(STATUS_GCODE_MODAL_GROUP_VIOLATION); }
    112c:	81 e0       	ldi	r24, 0x01	; 1
    112e:	90 e0       	ldi	r25, 0x00	; 0
    1130:	02 c0       	rjmp	.+4      	; 0x1136 <__EEPROM_REGION_LENGTH__+0x136>
    1132:	88 0f       	add	r24, r24
    1134:	99 1f       	adc	r25, r25
    1136:	2a 95       	dec	r18
    1138:	e2 f7       	brpl	.-8      	; 0x1132 <__EEPROM_REGION_LENGTH__+0x132>
    113a:	97 01       	movw	r18, r14
    113c:	28 23       	and	r18, r24
    113e:	39 23       	and	r19, r25
    1140:	23 2b       	or	r18, r19
    1142:	11 f0       	breq	.+4      	; 0x1148 <__EEPROM_REGION_LENGTH__+0x148>
    1144:	0c 94 d3 11 	jmp	0x23a6	; 0x23a6 <__stack+0x1a7>
        command_words |= bit(word_bit);
    1148:	e8 2a       	or	r14, r24
    114a:	f9 2a       	or	r15, r25
        break;
    114c:	cd c0       	rjmp	.+410    	; 0x12e8 <__EEPROM_REGION_LENGTH__+0x2e8>
      default:

        /* Non-Command Words: This initial parsing phase only checks for repeats of the remaining
           legal g-code words and stores their value. Error-checking is performed later since some
           words (I,J,K,L,P,R) have multiple connotations and/or depend on the issued commands. */
        switch(letter){
    114e:	81 2f       	mov	r24, r17
    1150:	90 e0       	ldi	r25, 0x00	; 0
    1152:	fc 01       	movw	r30, r24
    1154:	e6 54       	subi	r30, 0x46	; 70
    1156:	f1 09       	sbc	r31, r1
    1158:	e5 31       	cpi	r30, 0x15	; 21
    115a:	f1 05       	cpc	r31, r1
    115c:	10 f0       	brcs	.+4      	; 0x1162 <__EEPROM_REGION_LENGTH__+0x162>
    115e:	0c 94 d5 11 	jmp	0x23aa	; 0x23aa <__stack+0x1ab>
    1162:	88 27       	eor	r24, r24
    1164:	e0 51       	subi	r30, 0x10	; 16
    1166:	ff 4f       	sbci	r31, 0xFF	; 255
    1168:	8f 4f       	sbci	r24, 0xFF	; 255
    116a:	0c 94 5b 40 	jmp	0x80b6	; 0x80b6 <__tablejump2__>
          // case 'A': // Not supported
          // case 'B': // Not supported
          // case 'C': // Not supported
          // case 'D': // Not supported
          case 'F': word_bit = WORD_F; gc_block.values.f = value; break;
    116e:	40 92 8b 0c 	sts	0x0C8B, r4	; 0x800c8b <gc_block+0xc>
    1172:	50 92 8c 0c 	sts	0x0C8C, r5	; 0x800c8c <gc_block+0xd>
    1176:	60 92 8d 0c 	sts	0x0C8D, r6	; 0x800c8d <gc_block+0xe>
    117a:	70 92 8e 0c 	sts	0x0C8E, r7	; 0x800c8e <gc_block+0xf>
    117e:	20 e0       	ldi	r18, 0x00	; 0
    1180:	8d c0       	rjmp	.+282    	; 0x129c <__EEPROM_REGION_LENGTH__+0x29c>
          // case 'H': // Not supported
          case 'I': word_bit = WORD_I; gc_block.values.ijk[X_AXIS] = value; ijk_words |= (1<<X_AXIS); break;
    1182:	40 92 8f 0c 	sts	0x0C8F, r4	; 0x800c8f <gc_block+0x10>
    1186:	50 92 90 0c 	sts	0x0C90, r5	; 0x800c90 <gc_block+0x11>
    118a:	60 92 91 0c 	sts	0x0C91, r6	; 0x800c91 <gc_block+0x12>
    118e:	70 92 92 0c 	sts	0x0C92, r7	; 0x800c92 <gc_block+0x13>
    1192:	58 2d       	mov	r21, r8
    1194:	51 60       	ori	r21, 0x01	; 1
    1196:	85 2e       	mov	r8, r21
    1198:	21 e0       	ldi	r18, 0x01	; 1
    119a:	80 c0       	rjmp	.+256    	; 0x129c <__EEPROM_REGION_LENGTH__+0x29c>
          case 'J': word_bit = WORD_J; gc_block.values.ijk[Y_AXIS] = value; ijk_words |= (1<<Y_AXIS); break;
    119c:	40 92 93 0c 	sts	0x0C93, r4	; 0x800c93 <gc_block+0x14>
    11a0:	50 92 94 0c 	sts	0x0C94, r5	; 0x800c94 <gc_block+0x15>
    11a4:	60 92 95 0c 	sts	0x0C95, r6	; 0x800c95 <gc_block+0x16>
    11a8:	70 92 96 0c 	sts	0x0C96, r7	; 0x800c96 <gc_block+0x17>
    11ac:	88 2d       	mov	r24, r8
    11ae:	82 60       	ori	r24, 0x02	; 2
    11b0:	88 2e       	mov	r8, r24
    11b2:	22 e0       	ldi	r18, 0x02	; 2
    11b4:	73 c0       	rjmp	.+230    	; 0x129c <__EEPROM_REGION_LENGTH__+0x29c>
          case 'K': word_bit = WORD_K; gc_block.values.ijk[Z_AXIS] = value; ijk_words |= (1<<Z_AXIS); break;
    11b6:	40 92 97 0c 	sts	0x0C97, r4	; 0x800c97 <gc_block+0x18>
    11ba:	50 92 98 0c 	sts	0x0C98, r5	; 0x800c98 <gc_block+0x19>
    11be:	60 92 99 0c 	sts	0x0C99, r6	; 0x800c99 <gc_block+0x1a>
    11c2:	70 92 9a 0c 	sts	0x0C9A, r7	; 0x800c9a <gc_block+0x1b>
    11c6:	98 2d       	mov	r25, r8
    11c8:	94 60       	ori	r25, 0x04	; 4
    11ca:	89 2e       	mov	r8, r25
    11cc:	23 e0       	ldi	r18, 0x03	; 3
    11ce:	66 c0       	rjmp	.+204    	; 0x129c <__EEPROM_REGION_LENGTH__+0x29c>
          case 'L': word_bit = WORD_L; gc_block.values.l = int_value; break;
    11d0:	c0 92 9b 0c 	sts	0x0C9B, r12	; 0x800c9b <gc_block+0x1c>
    11d4:	24 e0       	ldi	r18, 0x04	; 4
    11d6:	62 c0       	rjmp	.+196    	; 0x129c <__EEPROM_REGION_LENGTH__+0x29c>
          case 'N': word_bit = WORD_N; gc_block.values.n = trunc(value); break;
    11d8:	c3 01       	movw	r24, r6
    11da:	b2 01       	movw	r22, r4
    11dc:	0e 94 7d 3d 	call	0x7afa	; 0x7afa <__fixsfsi>
    11e0:	60 93 9c 0c 	sts	0x0C9C, r22	; 0x800c9c <gc_block+0x1d>
    11e4:	70 93 9d 0c 	sts	0x0C9D, r23	; 0x800c9d <gc_block+0x1e>
    11e8:	80 93 9e 0c 	sts	0x0C9E, r24	; 0x800c9e <gc_block+0x1f>
    11ec:	90 93 9f 0c 	sts	0x0C9F, r25	; 0x800c9f <gc_block+0x20>
    11f0:	25 e0       	ldi	r18, 0x05	; 5
    11f2:	54 c0       	rjmp	.+168    	; 0x129c <__EEPROM_REGION_LENGTH__+0x29c>
          case 'P': word_bit = WORD_P; gc_block.values.p = value; break;
    11f4:	40 92 a0 0c 	sts	0x0CA0, r4	; 0x800ca0 <gc_block+0x21>
    11f8:	50 92 a1 0c 	sts	0x0CA1, r5	; 0x800ca1 <gc_block+0x22>
    11fc:	60 92 a2 0c 	sts	0x0CA2, r6	; 0x800ca2 <gc_block+0x23>
    1200:	70 92 a3 0c 	sts	0x0CA3, r7	; 0x800ca3 <gc_block+0x24>
    1204:	26 e0       	ldi	r18, 0x06	; 6
    1206:	4a c0       	rjmp	.+148    	; 0x129c <__EEPROM_REGION_LENGTH__+0x29c>
          // NOTE: For certain commands, P value must be an integer, but none of these commands are supported.
          // case 'Q': // Not supported
          case 'R': word_bit = WORD_R; gc_block.values.r = value; break;
    1208:	40 92 a4 0c 	sts	0x0CA4, r4	; 0x800ca4 <gc_block+0x25>
    120c:	50 92 a5 0c 	sts	0x0CA5, r5	; 0x800ca5 <gc_block+0x26>
    1210:	60 92 a6 0c 	sts	0x0CA6, r6	; 0x800ca6 <gc_block+0x27>
    1214:	70 92 a7 0c 	sts	0x0CA7, r7	; 0x800ca7 <gc_block+0x28>
    1218:	27 e0       	ldi	r18, 0x07	; 7
    121a:	40 c0       	rjmp	.+128    	; 0x129c <__EEPROM_REGION_LENGTH__+0x29c>
          case 'S': word_bit = WORD_S; gc_block.values.s = value; break;
    121c:	40 92 a8 0c 	sts	0x0CA8, r4	; 0x800ca8 <gc_block+0x29>
    1220:	50 92 a9 0c 	sts	0x0CA9, r5	; 0x800ca9 <gc_block+0x2a>
    1224:	60 92 aa 0c 	sts	0x0CAA, r6	; 0x800caa <gc_block+0x2b>
    1228:	70 92 ab 0c 	sts	0x0CAB, r7	; 0x800cab <gc_block+0x2c>
    122c:	28 e0       	ldi	r18, 0x08	; 8
    122e:	36 c0       	rjmp	.+108    	; 0x129c <__EEPROM_REGION_LENGTH__+0x29c>
          case 'T': word_bit = WORD_T; 
						if (value > MAX_TOOL_NUMBER) { FAIL(STATUS_GCODE_MAX_VALUE_EXCEEDED); }
    1230:	20 e0       	ldi	r18, 0x00	; 0
    1232:	30 e0       	ldi	r19, 0x00	; 0
    1234:	4f e7       	ldi	r20, 0x7F	; 127
    1236:	53 e4       	ldi	r21, 0x43	; 67
    1238:	c3 01       	movw	r24, r6
    123a:	b2 01       	movw	r22, r4
    123c:	0e 94 11 3f 	call	0x7e22	; 0x7e22 <__gesf2>
    1240:	18 16       	cp	r1, r24
    1242:	14 f4       	brge	.+4      	; 0x1248 <__EEPROM_REGION_LENGTH__+0x248>
    1244:	0c 94 d7 11 	jmp	0x23ae	; 0x23ae <__stack+0x1af>
						gc_block.values.t = int_value;
    1248:	c0 92 ac 0c 	sts	0x0CAC, r12	; 0x800cac <gc_block+0x2d>
          case 'P': word_bit = WORD_P; gc_block.values.p = value; break;
          // NOTE: For certain commands, P value must be an integer, but none of these commands are supported.
          // case 'Q': // Not supported
          case 'R': word_bit = WORD_R; gc_block.values.r = value; break;
          case 'S': word_bit = WORD_S; gc_block.values.s = value; break;
          case 'T': word_bit = WORD_T; 
    124c:	29 e0       	ldi	r18, 0x09	; 9
						if (value > MAX_TOOL_NUMBER) { FAIL(STATUS_GCODE_MAX_VALUE_EXCEEDED); }
						gc_block.values.t = int_value;
						break;
    124e:	26 c0       	rjmp	.+76     	; 0x129c <__EEPROM_REGION_LENGTH__+0x29c>
          case 'X': word_bit = WORD_X; gc_block.values.xyz[X_AXIS] = value; axis_words |= (1<<X_AXIS); break;
    1250:	40 92 ad 0c 	sts	0x0CAD, r4	; 0x800cad <gc_block+0x2e>
    1254:	50 92 ae 0c 	sts	0x0CAE, r5	; 0x800cae <gc_block+0x2f>
    1258:	60 92 af 0c 	sts	0x0CAF, r6	; 0x800caf <gc_block+0x30>
    125c:	70 92 b0 0c 	sts	0x0CB0, r7	; 0x800cb0 <gc_block+0x31>
    1260:	a9 a1       	ldd	r26, Y+33	; 0x21
    1262:	a1 60       	ori	r26, 0x01	; 1
    1264:	a9 a3       	std	Y+33, r26	; 0x21
    1266:	2a e0       	ldi	r18, 0x0A	; 10
    1268:	19 c0       	rjmp	.+50     	; 0x129c <__EEPROM_REGION_LENGTH__+0x29c>
          case 'Y': word_bit = WORD_Y; gc_block.values.xyz[Y_AXIS] = value; axis_words |= (1<<Y_AXIS); break;
    126a:	40 92 b1 0c 	sts	0x0CB1, r4	; 0x800cb1 <gc_block+0x32>
    126e:	50 92 b2 0c 	sts	0x0CB2, r5	; 0x800cb2 <gc_block+0x33>
    1272:	60 92 b3 0c 	sts	0x0CB3, r6	; 0x800cb3 <gc_block+0x34>
    1276:	70 92 b4 0c 	sts	0x0CB4, r7	; 0x800cb4 <gc_block+0x35>
    127a:	b9 a1       	ldd	r27, Y+33	; 0x21
    127c:	b2 60       	ori	r27, 0x02	; 2
    127e:	b9 a3       	std	Y+33, r27	; 0x21
    1280:	2b e0       	ldi	r18, 0x0B	; 11
    1282:	0c c0       	rjmp	.+24     	; 0x129c <__EEPROM_REGION_LENGTH__+0x29c>
          case 'Z': word_bit = WORD_Z; gc_block.values.xyz[Z_AXIS] = value; axis_words |= (1<<Z_AXIS); break;
    1284:	40 92 b5 0c 	sts	0x0CB5, r4	; 0x800cb5 <gc_block+0x36>
    1288:	50 92 b6 0c 	sts	0x0CB6, r5	; 0x800cb6 <gc_block+0x37>
    128c:	60 92 b7 0c 	sts	0x0CB7, r6	; 0x800cb7 <gc_block+0x38>
    1290:	70 92 b8 0c 	sts	0x0CB8, r7	; 0x800cb8 <gc_block+0x39>
    1294:	e9 a1       	ldd	r30, Y+33	; 0x21
    1296:	e4 60       	ori	r30, 0x04	; 4
    1298:	e9 a3       	std	Y+33, r30	; 0x21
    129a:	2c e0       	ldi	r18, 0x0C	; 12
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND);
        }

        // NOTE: Variable 'word_bit' is always assigned, if the non-command letter is valid.
        if (bit_istrue(value_words,bit(word_bit))) { FAIL(STATUS_GCODE_WORD_REPEATED); } // [Word repeated]
    129c:	81 e0       	ldi	r24, 0x01	; 1
    129e:	90 e0       	ldi	r25, 0x00	; 0
    12a0:	6c 01       	movw	r12, r24
    12a2:	02 2e       	mov	r0, r18
    12a4:	02 c0       	rjmp	.+4      	; 0x12aa <__EEPROM_REGION_LENGTH__+0x2aa>
    12a6:	cc 0c       	add	r12, r12
    12a8:	dd 1c       	adc	r13, r13
    12aa:	0a 94       	dec	r0
    12ac:	e2 f7       	brpl	.-8      	; 0x12a6 <__EEPROM_REGION_LENGTH__+0x2a6>
    12ae:	c5 01       	movw	r24, r10
    12b0:	8c 21       	and	r24, r12
    12b2:	9d 21       	and	r25, r13
    12b4:	89 2b       	or	r24, r25
    12b6:	11 f0       	breq	.+4      	; 0x12bc <__EEPROM_REGION_LENGTH__+0x2bc>
    12b8:	0c 94 d9 11 	jmp	0x23b2	; 0x23b2 <__stack+0x1b3>
        // Check for invalid negative values for words F, N, P, T, and S.
        // NOTE: Negative value check is done here simply for code-efficiency.
        if ( bit(word_bit) & (bit(WORD_F)|bit(WORD_N)|bit(WORD_P)|bit(WORD_T)|bit(WORD_S)) ) {
    12bc:	81 e6       	ldi	r24, 0x61	; 97
    12be:	93 e0       	ldi	r25, 0x03	; 3
    12c0:	02 c0       	rjmp	.+4      	; 0x12c6 <__EEPROM_REGION_LENGTH__+0x2c6>
    12c2:	95 95       	asr	r25
    12c4:	87 95       	ror	r24
    12c6:	2a 95       	dec	r18
    12c8:	e2 f7       	brpl	.-8      	; 0x12c2 <__EEPROM_REGION_LENGTH__+0x2c2>
    12ca:	80 ff       	sbrs	r24, 0
    12cc:	0b c0       	rjmp	.+22     	; 0x12e4 <__EEPROM_REGION_LENGTH__+0x2e4>
          if (value < 0.0) { FAIL(STATUS_NEGATIVE_VALUE); } // [Word value cannot be negative]
    12ce:	20 e0       	ldi	r18, 0x00	; 0
    12d0:	30 e0       	ldi	r19, 0x00	; 0
    12d2:	a9 01       	movw	r20, r18
    12d4:	c3 01       	movw	r24, r6
    12d6:	b2 01       	movw	r22, r4
    12d8:	0e 94 0e 3d 	call	0x7a1c	; 0x7a1c <__cmpsf2>
    12dc:	88 23       	and	r24, r24
    12de:	14 f4       	brge	.+4      	; 0x12e4 <__EEPROM_REGION_LENGTH__+0x2e4>
    12e0:	0c 94 db 11 	jmp	0x23b6	; 0x23b6 <__stack+0x1b7>
        }
        value_words |= bit(word_bit); // Flag to indicate parameter assigned.
    12e4:	ac 28       	or	r10, r12
    12e6:	bd 28       	or	r11, r13
  uint8_t int_value = 0;
  uint16_t mantissa = 0;
  if (gc_parser_flags & GC_PARSER_JOG_MOTION) { char_counter = 3; } // Start parsing after `$J=`
  else { char_counter = 0; }

  while (line[char_counter] != 0) { // Loop until no more g-code words in line.
    12e8:	89 81       	ldd	r24, Y+1	; 0x01
    12ea:	ef 8d       	ldd	r30, Y+31	; 0x1f
    12ec:	f8 a1       	ldd	r31, Y+32	; 0x20
    12ee:	e8 0f       	add	r30, r24
    12f0:	f1 1d       	adc	r31, r1
    12f2:	10 81       	ld	r17, Z
    12f4:	11 11       	cpse	r17, r1
    12f6:	b8 cd       	rjmp	.-1168   	; 0xe68 <gc_execute_line+0x96>

  // [0. Non-specific/common error-checks and miscellaneous setup]:

  // Determine implicit axis command conditions. Axis words have been passed, but no explicit axis
  // command has been sent. If so, set axis command to current motion mode.
  if (axis_words) {
    12f8:	f9 a1       	ldd	r31, Y+33	; 0x21
    12fa:	ff 23       	and	r31, r31
    12fc:	29 f0       	breq	.+10     	; 0x1308 <__EEPROM_REGION_LENGTH__+0x308>
    if (!axis_command) { axis_command = AXIS_COMMAND_MOTION_MODE; } // Assign implicit motion-mode
    12fe:	2a a1       	ldd	r18, Y+34	; 0x22
    1300:	21 11       	cpse	r18, r1
    1302:	02 c0       	rjmp	.+4      	; 0x1308 <__EEPROM_REGION_LENGTH__+0x308>
    1304:	32 e0       	ldi	r19, 0x02	; 2
    1306:	3a a3       	std	Y+34, r19	; 0x22
  }

  // Check for valid line number N value.
  if (bit_istrue(value_words,bit(WORD_N))) {
    1308:	a5 fe       	sbrs	r10, 5
    130a:	0f c0       	rjmp	.+30     	; 0x132a <__EEPROM_REGION_LENGTH__+0x32a>
    // Line number value cannot be less than zero (done) or greater than max line number.
    if (gc_block.values.n > MAX_LINE_NUMBER) { FAIL(STATUS_GCODE_INVALID_LINE_NUMBER); } // [Exceeds max line number]
    130c:	80 91 9c 0c 	lds	r24, 0x0C9C	; 0x800c9c <gc_block+0x1d>
    1310:	90 91 9d 0c 	lds	r25, 0x0C9D	; 0x800c9d <gc_block+0x1e>
    1314:	a0 91 9e 0c 	lds	r26, 0x0C9E	; 0x800c9e <gc_block+0x1f>
    1318:	b0 91 9f 0c 	lds	r27, 0x0C9F	; 0x800c9f <gc_block+0x20>
    131c:	81 38       	cpi	r24, 0x81	; 129
    131e:	96 49       	sbci	r25, 0x96	; 150
    1320:	a8 49       	sbci	r26, 0x98	; 152
    1322:	b1 05       	cpc	r27, r1
    1324:	14 f0       	brlt	.+4      	; 0x132a <__EEPROM_REGION_LENGTH__+0x32a>
    1326:	0c 94 dd 11 	jmp	0x23ba	; 0x23ba <__stack+0x1bb>
  // [1. Comments ]: MSG's NOT SUPPORTED. Comment handling performed by protocol.

  // [2. Set feed rate mode ]: G93 F word missing with G1,G2/3 active, implicitly or explicitly. Feed rate
  //   is not defined after switching to G94 from G93.
  // NOTE: For jogging, ignore prior feed rate mode. Enforce G94 and check for required F word.
  if (gc_parser_flags & GC_PARSER_JOG_MOTION) {
    132a:	33 20       	and	r3, r3
    132c:	f1 f0       	breq	.+60     	; 0x136a <__EEPROM_REGION_LENGTH__+0x36a>
    if (bit_isfalse(value_words,bit(WORD_F))) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); }
    132e:	a0 fc       	sbrc	r10, 0
    1330:	02 c0       	rjmp	.+4      	; 0x1336 <__EEPROM_REGION_LENGTH__+0x336>
    1332:	0c 94 df 11 	jmp	0x23be	; 0x23be <__stack+0x1bf>
    if (gc_block.modal.units == UNITS_MODE_INCHES) { gc_block.values.f *= MM_PER_INCH; }
    1336:	80 91 82 0c 	lds	r24, 0x0C82	; 0x800c82 <gc_block+0x3>
    133a:	81 30       	cpi	r24, 0x01	; 1
    133c:	09 f0       	breq	.+2      	; 0x1340 <__EEPROM_REGION_LENGTH__+0x340>
    133e:	56 c0       	rjmp	.+172    	; 0x13ec <__EEPROM_REGION_LENGTH__+0x3ec>
    1340:	0f e7       	ldi	r16, 0x7F	; 127
    1342:	1c e0       	ldi	r17, 0x0C	; 12
    1344:	23 e3       	ldi	r18, 0x33	; 51
    1346:	33 e3       	ldi	r19, 0x33	; 51
    1348:	4b ec       	ldi	r20, 0xCB	; 203
    134a:	51 e4       	ldi	r21, 0x41	; 65
    134c:	d8 01       	movw	r26, r16
    134e:	1c 96       	adiw	r26, 0x0c	; 12
    1350:	6d 91       	ld	r22, X+
    1352:	7d 91       	ld	r23, X+
    1354:	8d 91       	ld	r24, X+
    1356:	9c 91       	ld	r25, X
    1358:	1f 97       	sbiw	r26, 0x0f	; 15
    135a:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
    135e:	f8 01       	movw	r30, r16
    1360:	64 87       	std	Z+12, r22	; 0x0c
    1362:	75 87       	std	Z+13, r23	; 0x0d
    1364:	86 87       	std	Z+14, r24	; 0x0e
    1366:	97 87       	std	Z+15, r25	; 0x0f
    1368:	41 c0       	rjmp	.+130    	; 0x13ec <__EEPROM_REGION_LENGTH__+0x3ec>
  } else {
    if (gc_block.modal.feed_rate == FEED_RATE_MODE_INVERSE_TIME) { // = G93
    136a:	80 91 81 0c 	lds	r24, 0x0C81	; 0x800c81 <gc_block+0x2>
    136e:	81 30       	cpi	r24, 0x01	; 1
    1370:	71 f4       	brne	.+28     	; 0x138e <__EEPROM_REGION_LENGTH__+0x38e>
      // NOTE: G38 can also operate in inverse time, but is undefined as an error. Missing F word check added here.
      if (axis_command == AXIS_COMMAND_MOTION_MODE) {
    1372:	fa a1       	ldd	r31, Y+34	; 0x22
    1374:	f2 30       	cpi	r31, 0x02	; 2
    1376:	d1 f5       	brne	.+116    	; 0x13ec <__EEPROM_REGION_LENGTH__+0x3ec>
        if ((gc_block.modal.motion != MOTION_MODE_NONE) && (gc_block.modal.motion != MOTION_MODE_SEEK)) {
    1378:	80 91 80 0c 	lds	r24, 0x0C80	; 0x800c80 <gc_block+0x1>
    137c:	80 35       	cpi	r24, 0x50	; 80
    137e:	b1 f1       	breq	.+108    	; 0x13ec <__EEPROM_REGION_LENGTH__+0x3ec>
    1380:	88 23       	and	r24, r24
    1382:	a1 f1       	breq	.+104    	; 0x13ec <__EEPROM_REGION_LENGTH__+0x3ec>
          if (bit_isfalse(value_words,bit(WORD_F))) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); } // [F word missing]
    1384:	a0 fc       	sbrc	r10, 0
    1386:	02 c0       	rjmp	.+4      	; 0x138c <__EEPROM_REGION_LENGTH__+0x38c>
    1388:	0c 94 e1 11 	jmp	0x23c2	; 0x23c2 <__stack+0x1c3>
    138c:	2f c0       	rjmp	.+94     	; 0x13ec <__EEPROM_REGION_LENGTH__+0x3ec>
      // value in the block. If no F word is passed with a motion command that requires a feed rate, this will error
      // out in the motion modes error-checking. However, if no F word is passed with NO motion command that requires
      // a feed rate, we simply move on and the state feed rate value gets updated to zero and remains undefined.
    } else { // = G94
      // - In units per mm mode: If F word passed, ensure value is in mm/min, otherwise push last state value.
      if (gc_state.modal.feed_rate == FEED_RATE_MODE_UNITS_PER_MIN) { // Last state is also G94
    138e:	80 91 40 0c 	lds	r24, 0x0C40	; 0x800c40 <gc_state+0x1>
    1392:	81 11       	cpse	r24, r1
    1394:	2b c0       	rjmp	.+86     	; 0x13ec <__EEPROM_REGION_LENGTH__+0x3ec>
        if (bit_istrue(value_words,bit(WORD_F))) {
    1396:	a0 fe       	sbrs	r10, 0
    1398:	19 c0       	rjmp	.+50     	; 0x13cc <__EEPROM_REGION_LENGTH__+0x3cc>
          if (gc_block.modal.units == UNITS_MODE_INCHES) { gc_block.values.f *= MM_PER_INCH; }
    139a:	80 91 82 0c 	lds	r24, 0x0C82	; 0x800c82 <gc_block+0x3>
    139e:	81 30       	cpi	r24, 0x01	; 1
    13a0:	29 f5       	brne	.+74     	; 0x13ec <__EEPROM_REGION_LENGTH__+0x3ec>
    13a2:	0f e7       	ldi	r16, 0x7F	; 127
    13a4:	1c e0       	ldi	r17, 0x0C	; 12
    13a6:	23 e3       	ldi	r18, 0x33	; 51
    13a8:	33 e3       	ldi	r19, 0x33	; 51
    13aa:	4b ec       	ldi	r20, 0xCB	; 203
    13ac:	51 e4       	ldi	r21, 0x41	; 65
    13ae:	d8 01       	movw	r26, r16
    13b0:	1c 96       	adiw	r26, 0x0c	; 12
    13b2:	6d 91       	ld	r22, X+
    13b4:	7d 91       	ld	r23, X+
    13b6:	8d 91       	ld	r24, X+
    13b8:	9c 91       	ld	r25, X
    13ba:	1f 97       	sbiw	r26, 0x0f	; 15
    13bc:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
    13c0:	f8 01       	movw	r30, r16
    13c2:	64 87       	std	Z+12, r22	; 0x0c
    13c4:	75 87       	std	Z+13, r23	; 0x0d
    13c6:	86 87       	std	Z+14, r24	; 0x0e
    13c8:	97 87       	std	Z+15, r25	; 0x0f
    13ca:	10 c0       	rjmp	.+32     	; 0x13ec <__EEPROM_REGION_LENGTH__+0x3ec>
        } else {
          gc_block.values.f = gc_state.feed_rate; // Push last state feed rate
    13cc:	80 91 4e 0c 	lds	r24, 0x0C4E	; 0x800c4e <gc_state+0xf>
    13d0:	90 91 4f 0c 	lds	r25, 0x0C4F	; 0x800c4f <gc_state+0x10>
    13d4:	a0 91 50 0c 	lds	r26, 0x0C50	; 0x800c50 <gc_state+0x11>
    13d8:	b0 91 51 0c 	lds	r27, 0x0C51	; 0x800c51 <gc_state+0x12>
    13dc:	80 93 8b 0c 	sts	0x0C8B, r24	; 0x800c8b <gc_block+0xc>
    13e0:	90 93 8c 0c 	sts	0x0C8C, r25	; 0x800c8c <gc_block+0xd>
    13e4:	a0 93 8d 0c 	sts	0x0C8D, r26	; 0x800c8d <gc_block+0xe>
    13e8:	b0 93 8e 0c 	sts	0x0C8E, r27	; 0x800c8e <gc_block+0xf>
    }
  }
  // bit_false(value_words,bit(WORD_F)); // NOTE: Single-meaning value word. Set at end of error-checking.

  // [4. Set spindle speed ]: S is negative (done.)
  if (bit_isfalse(value_words,bit(WORD_S))) { gc_block.values.s = gc_state.spindle_speed; }
    13ec:	b0 fc       	sbrc	r11, 0
    13ee:	10 c0       	rjmp	.+32     	; 0x1410 <__EEPROM_REGION_LENGTH__+0x410>
    13f0:	80 91 4a 0c 	lds	r24, 0x0C4A	; 0x800c4a <gc_state+0xb>
    13f4:	90 91 4b 0c 	lds	r25, 0x0C4B	; 0x800c4b <gc_state+0xc>
    13f8:	a0 91 4c 0c 	lds	r26, 0x0C4C	; 0x800c4c <gc_state+0xd>
    13fc:	b0 91 4d 0c 	lds	r27, 0x0C4D	; 0x800c4d <gc_state+0xe>
    1400:	80 93 a8 0c 	sts	0x0CA8, r24	; 0x800ca8 <gc_block+0x29>
    1404:	90 93 a9 0c 	sts	0x0CA9, r25	; 0x800ca9 <gc_block+0x2a>
    1408:	a0 93 aa 0c 	sts	0x0CAA, r26	; 0x800caa <gc_block+0x2b>
    140c:	b0 93 ab 0c 	sts	0x0CAB, r27	; 0x800cab <gc_block+0x2c>
      }
    }
  #endif

  // [10. Dwell ]: P value missing. P is negative (done.) NOTE: See below.
  if (gc_block.non_modal_command == NON_MODAL_DWELL) {
    1410:	80 91 7f 0c 	lds	r24, 0x0C7F	; 0x800c7f <gc_block>
    1414:	84 30       	cpi	r24, 0x04	; 4
    1416:	21 f4       	brne	.+8      	; 0x1420 <__EEPROM_REGION_LENGTH__+0x420>
    if (bit_isfalse(value_words,bit(WORD_P))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSING); } // [P word missing]
    1418:	a6 fe       	sbrs	r10, 6
    141a:	d5 c7       	rjmp	.+4010   	; 0x23c6 <__stack+0x1c7>
    bit_false(value_words,bit(WORD_P));
    141c:	e8 94       	clt
    141e:	a6 f8       	bld	r10, 6
  }

  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    1420:	80 91 84 0c 	lds	r24, 0x0C84	; 0x800c84 <gc_block+0x5>
    1424:	88 23       	and	r24, r24
    1426:	19 f0       	breq	.+6      	; 0x142e <__EEPROM_REGION_LENGTH__+0x42e>
    1428:	81 30       	cpi	r24, 0x01	; 1
    142a:	69 f0       	breq	.+26     	; 0x1446 <__EEPROM_REGION_LENGTH__+0x446>
    142c:	06 c0       	rjmp	.+12     	; 0x143a <__EEPROM_REGION_LENGTH__+0x43a>
    case PLANE_SELECT_XY:
      axis_0 = X_AXIS;
      axis_1 = Y_AXIS;
      axis_linear = Z_AXIS;
    142e:	f2 e0       	ldi	r31, 0x02	; 2
    1430:	fb a7       	std	Y+43, r31	; 0x2b

  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    case PLANE_SELECT_XY:
      axis_0 = X_AXIS;
      axis_1 = Y_AXIS;
    1432:	21 e0       	ldi	r18, 0x01	; 1
    1434:	2f 8f       	std	Y+31, r18	; 0x1f
  }

  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    case PLANE_SELECT_XY:
      axis_0 = X_AXIS;
    1436:	41 2c       	mov	r4, r1
    1438:	0c c0       	rjmp	.+24     	; 0x1452 <__EEPROM_REGION_LENGTH__+0x452>
      axis_linear = Y_AXIS;
      break;
    default: // case PLANE_SELECT_YZ:
      axis_0 = Y_AXIS;
      axis_1 = Z_AXIS;
      axis_linear = X_AXIS;
    143a:	1b a6       	std	Y+43, r1	; 0x2b
      axis_1 = X_AXIS;
      axis_linear = Y_AXIS;
      break;
    default: // case PLANE_SELECT_YZ:
      axis_0 = Y_AXIS;
      axis_1 = Z_AXIS;
    143c:	32 e0       	ldi	r19, 0x02	; 2
    143e:	3f 8f       	std	Y+31, r19	; 0x1f
      axis_0 = Z_AXIS;
      axis_1 = X_AXIS;
      axis_linear = Y_AXIS;
      break;
    default: // case PLANE_SELECT_YZ:
      axis_0 = Y_AXIS;
    1440:	44 24       	eor	r4, r4
    1442:	43 94       	inc	r4
    1444:	06 c0       	rjmp	.+12     	; 0x1452 <__EEPROM_REGION_LENGTH__+0x452>
      axis_linear = Z_AXIS;
      break;
    case PLANE_SELECT_ZX:
      axis_0 = Z_AXIS;
      axis_1 = X_AXIS;
      axis_linear = Y_AXIS;
    1446:	41 e0       	ldi	r20, 0x01	; 1
    1448:	4b a7       	std	Y+43, r20	; 0x2b
      axis_1 = Y_AXIS;
      axis_linear = Z_AXIS;
      break;
    case PLANE_SELECT_ZX:
      axis_0 = Z_AXIS;
      axis_1 = X_AXIS;
    144a:	1f 8e       	std	Y+31, r1	; 0x1f
      axis_0 = X_AXIS;
      axis_1 = Y_AXIS;
      axis_linear = Z_AXIS;
      break;
    case PLANE_SELECT_ZX:
      axis_0 = Z_AXIS;
    144c:	68 94       	set
    144e:	44 24       	eor	r4, r4
    1450:	41 f8       	bld	r4, 1
  }

  // [12. Set length units ]: N/A
  // Pre-convert XYZ coordinate values to millimeters, if applicable.
  uint8_t idx;
  if (gc_block.modal.units == UNITS_MODE_INCHES) {
    1452:	80 91 82 0c 	lds	r24, 0x0C82	; 0x800c82 <gc_block+0x3>
    1456:	81 30       	cpi	r24, 0x01	; 1
    1458:	71 f5       	brne	.+92     	; 0x14b6 <__EEPROM_REGION_LENGTH__+0x4b6>
    145a:	28 c0       	rjmp	.+80     	; 0x14ac <__EEPROM_REGION_LENGTH__+0x4ac>
    for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
      if (bit_istrue(axis_words,bit(idx)) ) {
    145c:	c1 2e       	mov	r12, r17
    145e:	d1 2c       	mov	r13, r1
    1460:	80 2f       	mov	r24, r16
    1462:	90 e0       	ldi	r25, 0x00	; 0
    1464:	01 2e       	mov	r0, r17
    1466:	02 c0       	rjmp	.+4      	; 0x146c <__EEPROM_REGION_LENGTH__+0x46c>
    1468:	95 95       	asr	r25
    146a:	87 95       	ror	r24
    146c:	0a 94       	dec	r0
    146e:	e2 f7       	brpl	.-8      	; 0x1468 <__EEPROM_REGION_LENGTH__+0x468>
    1470:	80 ff       	sbrs	r24, 0
    1472:	1a c0       	rjmp	.+52     	; 0x14a8 <__EEPROM_REGION_LENGTH__+0x4a8>
        gc_block.values.xyz[idx] *= MM_PER_INCH;
    1474:	c6 01       	movw	r24, r12
    1476:	88 0f       	add	r24, r24
    1478:	99 1f       	adc	r25, r25
    147a:	88 0f       	add	r24, r24
    147c:	99 1f       	adc	r25, r25
    147e:	dc 01       	movw	r26, r24
    1480:	a1 58       	subi	r26, 0x81	; 129
    1482:	b3 4f       	sbci	r27, 0xF3	; 243
    1484:	6d 01       	movw	r12, r26
    1486:	23 e3       	ldi	r18, 0x33	; 51
    1488:	33 e3       	ldi	r19, 0x33	; 51
    148a:	4b ec       	ldi	r20, 0xCB	; 203
    148c:	51 e4       	ldi	r21, 0x41	; 65
    148e:	9e 96       	adiw	r26, 0x2e	; 46
    1490:	6d 91       	ld	r22, X+
    1492:	7d 91       	ld	r23, X+
    1494:	8d 91       	ld	r24, X+
    1496:	9c 91       	ld	r25, X
    1498:	d1 97       	sbiw	r26, 0x31	; 49
    149a:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
    149e:	f6 01       	movw	r30, r12
    14a0:	66 a7       	std	Z+46, r22	; 0x2e
    14a2:	77 a7       	std	Z+47, r23	; 0x2f
    14a4:	80 ab       	std	Z+48, r24	; 0x30
    14a6:	91 ab       	std	Z+49, r25	; 0x31

  // [12. Set length units ]: N/A
  // Pre-convert XYZ coordinate values to millimeters, if applicable.
  uint8_t idx;
  if (gc_block.modal.units == UNITS_MODE_INCHES) {
    for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
    14a8:	1f 5f       	subi	r17, 0xFF	; 255
    14aa:	03 c0       	rjmp	.+6      	; 0x14b2 <__EEPROM_REGION_LENGTH__+0x4b2>
    14ac:	d1 2c       	mov	r13, r1
    14ae:	09 a1       	ldd	r16, Y+33	; 0x21
    14b0:	1d 2d       	mov	r17, r13
    14b2:	13 30       	cpi	r17, 0x03	; 3
    14b4:	98 f2       	brcs	.-90     	; 0x145c <__EEPROM_REGION_LENGTH__+0x45c>
  // [14. Cutter length compensation ]: G43 NOT SUPPORTED, but G43.1 and G49 are.
  // [G43.1 Errors]: Motion command in same line.
  //   NOTE: Although not explicitly stated so, G43.1 should be applied to only one valid
  //   axis that is configured (in config.h). There should be an error if the configured axis
  //   is absent or if any of the other axis words are present.
  if (axis_command == AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // Indicates called in block.
    14b6:	fa a1       	ldd	r31, Y+34	; 0x22
    14b8:	f3 30       	cpi	r31, 0x03	; 3
    14ba:	41 f4       	brne	.+16     	; 0x14cc <__EEPROM_REGION_LENGTH__+0x4cc>
    if (gc_block.modal.tool_length == TOOL_LENGTH_OFFSET_ENABLE_DYNAMIC) {
    14bc:	80 91 85 0c 	lds	r24, 0x0C85	; 0x800c85 <gc_block+0x6>
    14c0:	81 30       	cpi	r24, 0x01	; 1
    14c2:	21 f4       	brne	.+8      	; 0x14cc <__EEPROM_REGION_LENGTH__+0x4cc>
      if (axis_words ^ (1<<TOOL_LENGTH_OFFSET_AXIS)) { FAIL(STATUS_GCODE_G43_DYNAMIC_AXIS_ERROR); }
    14c4:	29 a1       	ldd	r18, Y+33	; 0x21
    14c6:	24 30       	cpi	r18, 0x04	; 4
    14c8:	09 f0       	breq	.+2      	; 0x14cc <__EEPROM_REGION_LENGTH__+0x4cc>
    14ca:	7f c7       	rjmp	.+3838   	; 0x23ca <__stack+0x1cb>
  // TODO: An EEPROM read of the coordinate data may require a buffer sync when the cycle
  // is active. The read pauses the processor temporarily and may cause a rare crash. For
  // future versions on processors with enough memory, all coordinate data should be stored
  // in memory and written to EEPROM only when there is not a cycle active.
  float block_coord_system[N_AXIS];
  memcpy(block_coord_system,gc_state.coord_system,sizeof(gc_state.coord_system));
    14cc:	8c e0       	ldi	r24, 0x0C	; 12
    14ce:	e3 e6       	ldi	r30, 0x63	; 99
    14d0:	fc e0       	ldi	r31, 0x0C	; 12
    14d2:	de 01       	movw	r26, r28
    14d4:	16 96       	adiw	r26, 0x06	; 6
    14d6:	01 90       	ld	r0, Z+
    14d8:	0d 92       	st	X+, r0
    14da:	8a 95       	dec	r24
    14dc:	e1 f7       	brne	.-8      	; 0x14d6 <__EEPROM_REGION_LENGTH__+0x4d6>
  if ( bit_istrue(command_words,bit(MODAL_GROUP_G12)) ) { // Check if called in block
    14de:	f1 fe       	sbrs	r15, 1
    14e0:	11 c0       	rjmp	.+34     	; 0x1504 <__EEPROM_REGION_LENGTH__+0x504>
    if (gc_block.modal.coord_select > N_COORDINATE_SYSTEM) { FAIL(STATUS_GCODE_UNSUPPORTED_COORD_SYS); } // [Greater than N sys]
    14e2:	80 91 86 0c 	lds	r24, 0x0C86	; 0x800c86 <gc_block+0x7>
    14e6:	87 30       	cpi	r24, 0x07	; 7
    14e8:	08 f0       	brcs	.+2      	; 0x14ec <__EEPROM_REGION_LENGTH__+0x4ec>
    14ea:	71 c7       	rjmp	.+3810   	; 0x23ce <__stack+0x1cf>
    if (gc_state.modal.coord_select != gc_block.modal.coord_select) {
    14ec:	90 91 45 0c 	lds	r25, 0x0C45	; 0x800c45 <gc_state+0x6>
    14f0:	89 17       	cp	r24, r25
    14f2:	41 f0       	breq	.+16     	; 0x1504 <__EEPROM_REGION_LENGTH__+0x504>
      if (!(settings_read_coord_data(gc_block.modal.coord_select,block_coord_system))) { FAIL(STATUS_SETTING_READ_FAIL); }
    14f4:	be 01       	movw	r22, r28
    14f6:	6a 5f       	subi	r22, 0xFA	; 250
    14f8:	7f 4f       	sbci	r23, 0xFF	; 255
    14fa:	0e 94 18 25 	call	0x4a30	; 0x4a30 <settings_read_coord_data>
    14fe:	88 23       	and	r24, r24
    1500:	09 f4       	brne	.+2      	; 0x1504 <__EEPROM_REGION_LENGTH__+0x504>
    1502:	67 c7       	rjmp	.+3790   	; 0x23d2 <__stack+0x1d3>
  // [19. Remaining non-modal actions ]: Check go to predefined position, set G10, or set axis offsets.
  // NOTE: We need to separate the non-modal commands that are axis word-using (G10/G28/G30/G92), as these
  // commands all treat axis words differently. G10 as absolute offsets or computes current position as
  // the axis value, G92 similarly to G10 L20, and G28/30 as an intermediate target position that observes
  // all the current coordinate system and G92 offsets.
  switch (gc_block.non_modal_command) {
    1504:	70 90 7f 0c 	lds	r7, 0x0C7F	; 0x800c7f <gc_block>
    1508:	3a e0       	ldi	r19, 0x0A	; 10
    150a:	73 16       	cp	r7, r19
    150c:	29 f0       	breq	.+10     	; 0x1518 <__EEPROM_REGION_LENGTH__+0x518>
    150e:	4c e5       	ldi	r20, 0x5C	; 92
    1510:	74 16       	cp	r7, r20
    1512:	09 f4       	brne	.+2      	; 0x1516 <__EEPROM_REGION_LENGTH__+0x516>
    1514:	ad c0       	rjmp	.+346    	; 0x1670 <__EEPROM_REGION_LENGTH__+0x670>
    1516:	21 c1       	rjmp	.+578    	; 0x175a <__EEPROM_REGION_LENGTH__+0x75a>
    case NON_MODAL_SET_COORDINATE_DATA:
      // [G10 Errors]: L missing and is not 2 or 20. P word missing. (Negative P value done.)
      // [G10 L2 Errors]: R word NOT SUPPORTED. P value not 0 to nCoordSys(max 9). Axis words missing.
      // [G10 L20 Errors]: P must be 0 to nCoordSys(max 9). Axis words missing.
      if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS) }; // [No axis words]
    1518:	59 a1       	ldd	r21, Y+33	; 0x21
    151a:	55 23       	and	r21, r21
    151c:	09 f4       	brne	.+2      	; 0x1520 <__EEPROM_REGION_LENGTH__+0x520>
    151e:	5b c7       	rjmp	.+3766   	; 0x23d6 <__stack+0x1d7>
      if (bit_isfalse(value_words,((1<<WORD_P)|(1<<WORD_L)))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSING); } // [P/L word missing]
    1520:	c5 01       	movw	r24, r10
    1522:	80 75       	andi	r24, 0x50	; 80
    1524:	99 27       	eor	r25, r25
    1526:	89 2b       	or	r24, r25
    1528:	09 f4       	brne	.+2      	; 0x152c <__EEPROM_REGION_LENGTH__+0x52c>
    152a:	57 c7       	rjmp	.+3758   	; 0x23da <__stack+0x1db>
      coord_select = trunc(gc_block.values.p); // Convert p value to int.
    152c:	60 91 a0 0c 	lds	r22, 0x0CA0	; 0x800ca0 <gc_block+0x21>
    1530:	70 91 a1 0c 	lds	r23, 0x0CA1	; 0x800ca1 <gc_block+0x22>
    1534:	80 91 a2 0c 	lds	r24, 0x0CA2	; 0x800ca2 <gc_block+0x23>
    1538:	90 91 a3 0c 	lds	r25, 0x0CA3	; 0x800ca3 <gc_block+0x24>
    153c:	0e 94 1a 40 	call	0x8034	; 0x8034 <trunc>
    1540:	0e 94 82 3d 	call	0x7b04	; 0x7b04 <__fixunssfsi>
      if (coord_select > N_COORDINATE_SYSTEM) { FAIL(STATUS_GCODE_UNSUPPORTED_COORD_SYS); } // [Greater than N sys]
    1544:	67 30       	cpi	r22, 0x07	; 7
    1546:	08 f0       	brcs	.+2      	; 0x154a <__EEPROM_REGION_LENGTH__+0x54a>
    1548:	4a c7       	rjmp	.+3732   	; 0x23de <__stack+0x1df>
      if (gc_block.values.l != 20) {
    154a:	80 91 9b 0c 	lds	r24, 0x0C9B	; 0x800c9b <gc_block+0x1c>
    154e:	84 31       	cpi	r24, 0x14	; 20
    1550:	29 f0       	breq	.+10     	; 0x155c <__EEPROM_REGION_LENGTH__+0x55c>
        if (gc_block.values.l == 2) {
    1552:	82 30       	cpi	r24, 0x02	; 2
    1554:	09 f0       	breq	.+2      	; 0x1558 <__EEPROM_REGION_LENGTH__+0x558>
    1556:	45 c7       	rjmp	.+3722   	; 0x23e2 <__stack+0x1e3>
          if (bit_istrue(value_words,bit(WORD_R))) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G10 L2 R not supported]
    1558:	a7 fc       	sbrc	r10, 7
    155a:	45 c7       	rjmp	.+3722   	; 0x23e6 <__stack+0x1e7>
        } else { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [Unsupported L]
      }
      bit_false(value_words,(bit(WORD_L)|bit(WORD_P)));
    155c:	8f ea       	ldi	r24, 0xAF	; 175
    155e:	a8 22       	and	r10, r24

      // Determine coordinate system to change and try to load from EEPROM.
      if (coord_select > 0) { coord_select--; } // Adjust P1-P6 index to EEPROM coordinate data indexing.
    1560:	66 23       	and	r22, r22
    1562:	21 f0       	breq	.+8      	; 0x156c <__EEPROM_REGION_LENGTH__+0x56c>
    1564:	55 24       	eor	r5, r5
    1566:	5a 94       	dec	r5
    1568:	56 0e       	add	r5, r22
    156a:	02 c0       	rjmp	.+4      	; 0x1570 <__EEPROM_REGION_LENGTH__+0x570>
      else { coord_select = gc_block.modal.coord_select; } // Index P0 as the active coordinate system
    156c:	50 90 86 0c 	lds	r5, 0x0C86	; 0x800c86 <gc_block+0x7>
      
      // NOTE: Store parameter data in IJK values. By rule, they are not in use with this command.
      if (!settings_read_coord_data(coord_select,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); } // [EEPROM read fail]
    1570:	6f e8       	ldi	r22, 0x8F	; 143
    1572:	7c e0       	ldi	r23, 0x0C	; 12
    1574:	85 2d       	mov	r24, r5
    1576:	0e 94 18 25 	call	0x4a30	; 0x4a30 <settings_read_coord_data>
    157a:	88 23       	and	r24, r24
    157c:	09 f4       	brne	.+2      	; 0x1580 <__EEPROM_REGION_LENGTH__+0x580>
    157e:	35 c7       	rjmp	.+3690   	; 0x23ea <__stack+0x1eb>
    1580:	d1 2c       	mov	r13, r1
    1582:	71 c0       	rjmp	.+226    	; 0x1666 <__EEPROM_REGION_LENGTH__+0x666>

      // Pre-calculate the coordinate data changes.
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
        // Update axes defined only in block. Always in machine coordinates. Can change non-active system.
        if (bit_istrue(axis_words,bit(idx)) ) {
    1584:	0d 2d       	mov	r16, r13
    1586:	10 e0       	ldi	r17, 0x00	; 0
    1588:	a9 a1       	ldd	r26, Y+33	; 0x21
    158a:	8a 2f       	mov	r24, r26
    158c:	90 e0       	ldi	r25, 0x00	; 0
    158e:	0d 2c       	mov	r0, r13
    1590:	02 c0       	rjmp	.+4      	; 0x1596 <__EEPROM_REGION_LENGTH__+0x596>
    1592:	95 95       	asr	r25
    1594:	87 95       	ror	r24
    1596:	0a 94       	dec	r0
    1598:	e2 f7       	brpl	.-8      	; 0x1592 <__EEPROM_REGION_LENGTH__+0x592>
    159a:	80 ff       	sbrs	r24, 0
    159c:	63 c0       	rjmp	.+198    	; 0x1664 <__EEPROM_REGION_LENGTH__+0x664>
          if (gc_block.values.l == 20) {
    159e:	80 91 9b 0c 	lds	r24, 0x0C9B	; 0x800c9b <gc_block+0x1c>
    15a2:	84 31       	cpi	r24, 0x14	; 20
    15a4:	09 f0       	breq	.+2      	; 0x15a8 <__EEPROM_REGION_LENGTH__+0x5a8>
    15a6:	47 c0       	rjmp	.+142    	; 0x1636 <__EEPROM_REGION_LENGTH__+0x636>
            // L20: Update coordinate system axis at current position (with modifiers) with programmed value
            // WPos = MPos - WCS - G92 - TLO  ->  WCS = MPos - G92 - TLO - WPos
            gc_block.values.ijk[idx] = gc_state.position[idx]-gc_state.coord_offset[idx]-gc_block.values.xyz[idx];
    15a8:	f8 01       	movw	r30, r16
    15aa:	36 96       	adiw	r30, 0x06	; 6
    15ac:	ee 0f       	add	r30, r30
    15ae:	ff 1f       	adc	r31, r31
    15b0:	ee 0f       	add	r30, r30
    15b2:	ff 1f       	adc	r31, r31
    15b4:	e1 5c       	subi	r30, 0xC1	; 193
    15b6:	f3 4f       	sbci	r31, 0xF3	; 243
    15b8:	60 81       	ld	r22, Z
    15ba:	71 81       	ldd	r23, Z+1	; 0x01
    15bc:	82 81       	ldd	r24, Z+2	; 0x02
    15be:	93 81       	ldd	r25, Z+3	; 0x03
    15c0:	f8 01       	movw	r30, r16
    15c2:	3c 96       	adiw	r30, 0x0c	; 12
    15c4:	ee 0f       	add	r30, r30
    15c6:	ff 1f       	adc	r31, r31
    15c8:	ee 0f       	add	r30, r30
    15ca:	ff 1f       	adc	r31, r31
    15cc:	e1 5c       	subi	r30, 0xC1	; 193
    15ce:	f3 4f       	sbci	r31, 0xF3	; 243
    15d0:	20 81       	ld	r18, Z
    15d2:	31 81       	ldd	r19, Z+1	; 0x01
    15d4:	42 81       	ldd	r20, Z+2	; 0x02
    15d6:	53 81       	ldd	r21, Z+3	; 0x03
    15d8:	0e 94 34 3c 	call	0x7868	; 0x7868 <__subsf3>
    15dc:	f8 01       	movw	r30, r16
    15de:	ee 0f       	add	r30, r30
    15e0:	ff 1f       	adc	r31, r31
    15e2:	ee 0f       	add	r30, r30
    15e4:	ff 1f       	adc	r31, r31
    15e6:	e1 58       	subi	r30, 0x81	; 129
    15e8:	f3 4f       	sbci	r31, 0xF3	; 243
    15ea:	26 a5       	ldd	r18, Z+46	; 0x2e
    15ec:	37 a5       	ldd	r19, Z+47	; 0x2f
    15ee:	40 a9       	ldd	r20, Z+48	; 0x30
    15f0:	51 a9       	ldd	r21, Z+49	; 0x31
    15f2:	0e 94 34 3c 	call	0x7868	; 0x7868 <__subsf3>
    15f6:	f8 01       	movw	r30, r16
    15f8:	34 96       	adiw	r30, 0x04	; 4
    15fa:	ee 0f       	add	r30, r30
    15fc:	ff 1f       	adc	r31, r31
    15fe:	ee 0f       	add	r30, r30
    1600:	ff 1f       	adc	r31, r31
    1602:	e1 58       	subi	r30, 0x81	; 129
    1604:	f3 4f       	sbci	r31, 0xF3	; 243
    1606:	60 83       	st	Z, r22
    1608:	71 83       	std	Z+1, r23	; 0x01
    160a:	82 83       	std	Z+2, r24	; 0x02
    160c:	93 83       	std	Z+3, r25	; 0x03
            if (idx == TOOL_LENGTH_OFFSET_AXIS) { gc_block.values.ijk[idx] -= gc_state.tool_length_offset; }
    160e:	b2 e0       	ldi	r27, 0x02	; 2
    1610:	db 12       	cpse	r13, r27
    1612:	28 c0       	rjmp	.+80     	; 0x1664 <__EEPROM_REGION_LENGTH__+0x664>
    1614:	20 91 7b 0c 	lds	r18, 0x0C7B	; 0x800c7b <gc_state+0x3c>
    1618:	30 91 7c 0c 	lds	r19, 0x0C7C	; 0x800c7c <gc_state+0x3d>
    161c:	40 91 7d 0c 	lds	r20, 0x0C7D	; 0x800c7d <gc_state+0x3e>
    1620:	50 91 7e 0c 	lds	r21, 0x0C7E	; 0x800c7e <gc_state+0x3f>
    1624:	8f 01       	movw	r16, r30
    1626:	0e 94 34 3c 	call	0x7868	; 0x7868 <__subsf3>
    162a:	f8 01       	movw	r30, r16
    162c:	60 83       	st	Z, r22
    162e:	71 83       	std	Z+1, r23	; 0x01
    1630:	82 83       	std	Z+2, r24	; 0x02
    1632:	93 83       	std	Z+3, r25	; 0x03
    1634:	17 c0       	rjmp	.+46     	; 0x1664 <__EEPROM_REGION_LENGTH__+0x664>
          } else {
            // L2: Update coordinate system axis to programmed value.
            gc_block.values.ijk[idx] = gc_block.values.xyz[idx];
    1636:	f8 01       	movw	r30, r16
    1638:	ee 0f       	add	r30, r30
    163a:	ff 1f       	adc	r31, r31
    163c:	ee 0f       	add	r30, r30
    163e:	ff 1f       	adc	r31, r31
    1640:	e1 58       	subi	r30, 0x81	; 129
    1642:	f3 4f       	sbci	r31, 0xF3	; 243
    1644:	86 a5       	ldd	r24, Z+46	; 0x2e
    1646:	97 a5       	ldd	r25, Z+47	; 0x2f
    1648:	a0 a9       	ldd	r26, Z+48	; 0x30
    164a:	b1 a9       	ldd	r27, Z+49	; 0x31
    164c:	f8 01       	movw	r30, r16
    164e:	34 96       	adiw	r30, 0x04	; 4
    1650:	ee 0f       	add	r30, r30
    1652:	ff 1f       	adc	r31, r31
    1654:	ee 0f       	add	r30, r30
    1656:	ff 1f       	adc	r31, r31
    1658:	e1 58       	subi	r30, 0x81	; 129
    165a:	f3 4f       	sbci	r31, 0xF3	; 243
    165c:	80 83       	st	Z, r24
    165e:	91 83       	std	Z+1, r25	; 0x01
    1660:	a2 83       	std	Z+2, r26	; 0x02
    1662:	b3 83       	std	Z+3, r27	; 0x03
      
      // NOTE: Store parameter data in IJK values. By rule, they are not in use with this command.
      if (!settings_read_coord_data(coord_select,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); } // [EEPROM read fail]

      // Pre-calculate the coordinate data changes.
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
    1664:	d3 94       	inc	r13
    1666:	f2 e0       	ldi	r31, 0x02	; 2
    1668:	fd 15       	cp	r31, r13
    166a:	08 f0       	brcs	.+2      	; 0x166e <__EEPROM_REGION_LENGTH__+0x66e>
    166c:	8b cf       	rjmp	.-234    	; 0x1584 <__EEPROM_REGION_LENGTH__+0x584>
    166e:	6d c1       	rjmp	.+730    	; 0x194a <__EEPROM_REGION_LENGTH__+0x94a>
        } // Else, keep current stored value.
      }
      break;
    case NON_MODAL_SET_COORDINATE_OFFSET:
      // [G92 Errors]: No axis words.
      if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    1670:	29 a1       	ldd	r18, Y+33	; 0x21
    1672:	22 23       	and	r18, r18
    1674:	09 f4       	brne	.+2      	; 0x1678 <__EEPROM_REGION_LENGTH__+0x678>
    1676:	bb c6       	rjmp	.+3446   	; 0x23ee <__stack+0x1ef>
    1678:	71 2c       	mov	r7, r1
    167a:	69 c0       	rjmp	.+210    	; 0x174e <__EEPROM_REGION_LENGTH__+0x74e>

      // Update axes defined only in block. Offsets current system to defined value. Does not update when
      // active coordinate system is selected, but is still active unless G92.1 disables it.
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
        if (bit_istrue(axis_words,bit(idx)) ) {
    167c:	07 2d       	mov	r16, r7
    167e:	10 e0       	ldi	r17, 0x00	; 0
    1680:	39 a1       	ldd	r19, Y+33	; 0x21
    1682:	83 2f       	mov	r24, r19
    1684:	90 e0       	ldi	r25, 0x00	; 0
    1686:	07 2c       	mov	r0, r7
    1688:	02 c0       	rjmp	.+4      	; 0x168e <__EEPROM_REGION_LENGTH__+0x68e>
    168a:	95 95       	asr	r25
    168c:	87 95       	ror	r24
    168e:	0a 94       	dec	r0
    1690:	e2 f7       	brpl	.-8      	; 0x168a <__EEPROM_REGION_LENGTH__+0x68a>
    1692:	80 ff       	sbrs	r24, 0
    1694:	44 c0       	rjmp	.+136    	; 0x171e <__EEPROM_REGION_LENGTH__+0x71e>
          // WPos = MPos - WCS - G92 - TLO  ->  G92 = MPos - WCS - TLO - WPos
          gc_block.values.xyz[idx] = gc_state.position[idx]-block_coord_system[idx]-gc_block.values.xyz[idx];
    1696:	f8 01       	movw	r30, r16
    1698:	36 96       	adiw	r30, 0x06	; 6
    169a:	ee 0f       	add	r30, r30
    169c:	ff 1f       	adc	r31, r31
    169e:	ee 0f       	add	r30, r30
    16a0:	ff 1f       	adc	r31, r31
    16a2:	e1 5c       	subi	r30, 0xC1	; 193
    16a4:	f3 4f       	sbci	r31, 0xF3	; 243
    16a6:	60 81       	ld	r22, Z
    16a8:	71 81       	ldd	r23, Z+1	; 0x01
    16aa:	82 81       	ldd	r24, Z+2	; 0x02
    16ac:	93 81       	ldd	r25, Z+3	; 0x03
    16ae:	68 01       	movw	r12, r16
    16b0:	cc 0c       	add	r12, r12
    16b2:	dd 1c       	adc	r13, r13
    16b4:	cc 0c       	add	r12, r12
    16b6:	dd 1c       	adc	r13, r13
    16b8:	e1 e0       	ldi	r30, 0x01	; 1
    16ba:	f0 e0       	ldi	r31, 0x00	; 0
    16bc:	ec 0f       	add	r30, r28
    16be:	fd 1f       	adc	r31, r29
    16c0:	ec 0d       	add	r30, r12
    16c2:	fd 1d       	adc	r31, r13
    16c4:	25 81       	ldd	r18, Z+5	; 0x05
    16c6:	36 81       	ldd	r19, Z+6	; 0x06
    16c8:	47 81       	ldd	r20, Z+7	; 0x07
    16ca:	50 85       	ldd	r21, Z+8	; 0x08
    16cc:	0e 94 34 3c 	call	0x7868	; 0x7868 <__subsf3>
    16d0:	a6 01       	movw	r20, r12
    16d2:	41 58       	subi	r20, 0x81	; 129
    16d4:	53 4f       	sbci	r21, 0xF3	; 243
    16d6:	6a 01       	movw	r12, r20
    16d8:	da 01       	movw	r26, r20
    16da:	9e 96       	adiw	r26, 0x2e	; 46
    16dc:	2d 91       	ld	r18, X+
    16de:	3d 91       	ld	r19, X+
    16e0:	4d 91       	ld	r20, X+
    16e2:	5c 91       	ld	r21, X
    16e4:	d1 97       	sbiw	r26, 0x31	; 49
    16e6:	0e 94 34 3c 	call	0x7868	; 0x7868 <__subsf3>
    16ea:	f6 01       	movw	r30, r12
    16ec:	66 a7       	std	Z+46, r22	; 0x2e
    16ee:	77 a7       	std	Z+47, r23	; 0x2f
    16f0:	80 ab       	std	Z+48, r24	; 0x30
    16f2:	91 ab       	std	Z+49, r25	; 0x31
          if (idx == TOOL_LENGTH_OFFSET_AXIS) { gc_block.values.xyz[idx] -= gc_state.tool_length_offset; }
    16f4:	f2 e0       	ldi	r31, 0x02	; 2
    16f6:	7f 12       	cpse	r7, r31
    16f8:	29 c0       	rjmp	.+82     	; 0x174c <__EEPROM_REGION_LENGTH__+0x74c>
    16fa:	20 91 7b 0c 	lds	r18, 0x0C7B	; 0x800c7b <gc_state+0x3c>
    16fe:	30 91 7c 0c 	lds	r19, 0x0C7C	; 0x800c7c <gc_state+0x3d>
    1702:	40 91 7d 0c 	lds	r20, 0x0C7D	; 0x800c7d <gc_state+0x3e>
    1706:	50 91 7e 0c 	lds	r21, 0x0C7E	; 0x800c7e <gc_state+0x3f>
    170a:	0e 94 34 3c 	call	0x7868	; 0x7868 <__subsf3>
    170e:	d6 01       	movw	r26, r12
    1710:	9e 96       	adiw	r26, 0x2e	; 46
    1712:	6d 93       	st	X+, r22
    1714:	7d 93       	st	X+, r23
    1716:	8d 93       	st	X+, r24
    1718:	9c 93       	st	X, r25
    171a:	d1 97       	sbiw	r26, 0x31	; 49
    171c:	17 c0       	rjmp	.+46     	; 0x174c <__EEPROM_REGION_LENGTH__+0x74c>
        } else {
          gc_block.values.xyz[idx] = gc_state.coord_offset[idx];
    171e:	f8 01       	movw	r30, r16
    1720:	3c 96       	adiw	r30, 0x0c	; 12
    1722:	ee 0f       	add	r30, r30
    1724:	ff 1f       	adc	r31, r31
    1726:	ee 0f       	add	r30, r30
    1728:	ff 1f       	adc	r31, r31
    172a:	e1 5c       	subi	r30, 0xC1	; 193
    172c:	f3 4f       	sbci	r31, 0xF3	; 243
    172e:	80 81       	ld	r24, Z
    1730:	91 81       	ldd	r25, Z+1	; 0x01
    1732:	a2 81       	ldd	r26, Z+2	; 0x02
    1734:	b3 81       	ldd	r27, Z+3	; 0x03
    1736:	f8 01       	movw	r30, r16
    1738:	ee 0f       	add	r30, r30
    173a:	ff 1f       	adc	r31, r31
    173c:	ee 0f       	add	r30, r30
    173e:	ff 1f       	adc	r31, r31
    1740:	e1 58       	subi	r30, 0x81	; 129
    1742:	f3 4f       	sbci	r31, 0xF3	; 243
    1744:	86 a7       	std	Z+46, r24	; 0x2e
    1746:	97 a7       	std	Z+47, r25	; 0x2f
    1748:	a0 ab       	std	Z+48, r26	; 0x30
    174a:	b1 ab       	std	Z+49, r27	; 0x31
      // [G92 Errors]: No axis words.
      if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]

      // Update axes defined only in block. Offsets current system to defined value. Does not update when
      // active coordinate system is selected, but is still active unless G92.1 disables it.
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
    174c:	73 94       	inc	r7
    174e:	b2 e0       	ldi	r27, 0x02	; 2
    1750:	b7 15       	cp	r27, r7
    1752:	08 f0       	brcs	.+2      	; 0x1756 <__EEPROM_REGION_LENGTH__+0x756>
    1754:	93 cf       	rjmp	.-218    	; 0x167c <__EEPROM_REGION_LENGTH__+0x67c>
  memset(&gc_block, 0, sizeof(parser_block_t)); // Initialize the parser block struct.
  memcpy(&gc_block.modal,&gc_state.modal,sizeof(gc_modal_t)); // Copy current modes

  uint8_t axis_command = AXIS_COMMAND_NONE;
  uint8_t axis_0, axis_1, axis_linear;
  uint8_t coord_select = 0; // Tracks G10 P coordinate selection for execution
    1756:	51 2c       	mov	r5, r1
    1758:	f8 c0       	rjmp	.+496    	; 0x194a <__EEPROM_REGION_LENGTH__+0x94a>

      // At this point, the rest of the explicit axis commands treat the axis values as the traditional
      // target position with the coordinate system offsets, G92 offsets, absolute override, and distance
      // modes applied. This includes the motion mode commands. We can now pre-compute the target position.
      // NOTE: Tool offsets may be appended to these conversions when/if this feature is added.
      if (axis_command != AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // TLO block any axis command.
    175a:	ea a1       	ldd	r30, Y+34	; 0x22
    175c:	e3 30       	cpi	r30, 0x03	; 3
    175e:	09 f4       	brne	.+2      	; 0x1762 <__EEPROM_REGION_LENGTH__+0x762>
    1760:	9c c0       	rjmp	.+312    	; 0x189a <__EEPROM_REGION_LENGTH__+0x89a>
        if (axis_words) {
    1762:	f9 a1       	ldd	r31, Y+33	; 0x21
    1764:	f1 11       	cpse	r31, r1
    1766:	94 c0       	rjmp	.+296    	; 0x1890 <__EEPROM_REGION_LENGTH__+0x890>
    1768:	98 c0       	rjmp	.+304    	; 0x189a <__EEPROM_REGION_LENGTH__+0x89a>
          for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used to save flash space.
            if ( bit_isfalse(axis_words,bit(idx)) ) {
    176a:	06 2d       	mov	r16, r6
    176c:	10 e0       	ldi	r17, 0x00	; 0
    176e:	29 a1       	ldd	r18, Y+33	; 0x21
    1770:	82 2f       	mov	r24, r18
    1772:	90 e0       	ldi	r25, 0x00	; 0
    1774:	06 2c       	mov	r0, r6
    1776:	02 c0       	rjmp	.+4      	; 0x177c <__EEPROM_REGION_LENGTH__+0x77c>
    1778:	95 95       	asr	r25
    177a:	87 95       	ror	r24
    177c:	0a 94       	dec	r0
    177e:	e2 f7       	brpl	.-8      	; 0x1778 <__EEPROM_REGION_LENGTH__+0x778>
    1780:	80 fd       	sbrc	r24, 0
    1782:	18 c0       	rjmp	.+48     	; 0x17b4 <__EEPROM_REGION_LENGTH__+0x7b4>
              gc_block.values.xyz[idx] = gc_state.position[idx]; // No axis word in block. Keep same axis position.
    1784:	f8 01       	movw	r30, r16
    1786:	36 96       	adiw	r30, 0x06	; 6
    1788:	ee 0f       	add	r30, r30
    178a:	ff 1f       	adc	r31, r31
    178c:	ee 0f       	add	r30, r30
    178e:	ff 1f       	adc	r31, r31
    1790:	e1 5c       	subi	r30, 0xC1	; 193
    1792:	f3 4f       	sbci	r31, 0xF3	; 243
    1794:	80 81       	ld	r24, Z
    1796:	91 81       	ldd	r25, Z+1	; 0x01
    1798:	a2 81       	ldd	r26, Z+2	; 0x02
    179a:	b3 81       	ldd	r27, Z+3	; 0x03
    179c:	f8 01       	movw	r30, r16
    179e:	ee 0f       	add	r30, r30
    17a0:	ff 1f       	adc	r31, r31
    17a2:	ee 0f       	add	r30, r30
    17a4:	ff 1f       	adc	r31, r31
    17a6:	e1 58       	subi	r30, 0x81	; 129
    17a8:	f3 4f       	sbci	r31, 0xF3	; 243
    17aa:	86 a7       	std	Z+46, r24	; 0x2e
    17ac:	97 a7       	std	Z+47, r25	; 0x2f
    17ae:	a0 ab       	std	Z+48, r26	; 0x30
    17b0:	b1 ab       	std	Z+49, r27	; 0x31
    17b2:	6c c0       	rjmp	.+216    	; 0x188c <__EEPROM_REGION_LENGTH__+0x88c>
            } else {
              // Update specified value according to distance mode or ignore if absolute override is active.
              // NOTE: G53 is never active with G28/30 since they are in the same modal group.
              if (gc_block.non_modal_command != NON_MODAL_ABSOLUTE_OVERRIDE) {
    17b4:	35 e3       	ldi	r19, 0x35	; 53
    17b6:	73 16       	cp	r7, r19
    17b8:	09 f4       	brne	.+2      	; 0x17bc <__EEPROM_REGION_LENGTH__+0x7bc>
    17ba:	68 c0       	rjmp	.+208    	; 0x188c <__EEPROM_REGION_LENGTH__+0x88c>
                // Apply coordinate offsets based on distance mode.
                if (gc_block.modal.distance == DISTANCE_MODE_ABSOLUTE) {
    17bc:	80 91 83 0c 	lds	r24, 0x0C83	; 0x800c83 <gc_block+0x4>
    17c0:	81 11       	cpse	r24, r1
    17c2:	44 c0       	rjmp	.+136    	; 0x184c <__EEPROM_REGION_LENGTH__+0x84c>
                  gc_block.values.xyz[idx] += block_coord_system[idx] + gc_state.coord_offset[idx];
    17c4:	68 01       	movw	r12, r16
    17c6:	cc 0c       	add	r12, r12
    17c8:	dd 1c       	adc	r13, r13
    17ca:	cc 0c       	add	r12, r12
    17cc:	dd 1c       	adc	r13, r13
    17ce:	e1 e0       	ldi	r30, 0x01	; 1
    17d0:	f0 e0       	ldi	r31, 0x00	; 0
    17d2:	ec 0f       	add	r30, r28
    17d4:	fd 1f       	adc	r31, r29
    17d6:	ec 0d       	add	r30, r12
    17d8:	fd 1d       	adc	r31, r13
    17da:	65 81       	ldd	r22, Z+5	; 0x05
    17dc:	76 81       	ldd	r23, Z+6	; 0x06
    17de:	87 81       	ldd	r24, Z+7	; 0x07
    17e0:	90 85       	ldd	r25, Z+8	; 0x08
    17e2:	f8 01       	movw	r30, r16
    17e4:	3c 96       	adiw	r30, 0x0c	; 12
    17e6:	ee 0f       	add	r30, r30
    17e8:	ff 1f       	adc	r31, r31
    17ea:	ee 0f       	add	r30, r30
    17ec:	ff 1f       	adc	r31, r31
    17ee:	e1 5c       	subi	r30, 0xC1	; 193
    17f0:	f3 4f       	sbci	r31, 0xF3	; 243
    17f2:	20 81       	ld	r18, Z
    17f4:	31 81       	ldd	r19, Z+1	; 0x01
    17f6:	42 81       	ldd	r20, Z+2	; 0x02
    17f8:	53 81       	ldd	r21, Z+3	; 0x03
    17fa:	0e 94 35 3c 	call	0x786a	; 0x786a <__addsf3>
    17fe:	a6 01       	movw	r20, r12
    1800:	41 58       	subi	r20, 0x81	; 129
    1802:	53 4f       	sbci	r21, 0xF3	; 243
    1804:	6a 01       	movw	r12, r20
    1806:	da 01       	movw	r26, r20
    1808:	9e 96       	adiw	r26, 0x2e	; 46
    180a:	2d 91       	ld	r18, X+
    180c:	3d 91       	ld	r19, X+
    180e:	4d 91       	ld	r20, X+
    1810:	5c 91       	ld	r21, X
    1812:	d1 97       	sbiw	r26, 0x31	; 49
    1814:	0e 94 35 3c 	call	0x786a	; 0x786a <__addsf3>
    1818:	f6 01       	movw	r30, r12
    181a:	66 a7       	std	Z+46, r22	; 0x2e
    181c:	77 a7       	std	Z+47, r23	; 0x2f
    181e:	80 ab       	std	Z+48, r24	; 0x30
    1820:	91 ab       	std	Z+49, r25	; 0x31
                  if (idx == TOOL_LENGTH_OFFSET_AXIS) { gc_block.values.xyz[idx] += gc_state.tool_length_offset; }
    1822:	f2 e0       	ldi	r31, 0x02	; 2
    1824:	6f 12       	cpse	r6, r31
    1826:	32 c0       	rjmp	.+100    	; 0x188c <__EEPROM_REGION_LENGTH__+0x88c>
    1828:	20 91 7b 0c 	lds	r18, 0x0C7B	; 0x800c7b <gc_state+0x3c>
    182c:	30 91 7c 0c 	lds	r19, 0x0C7C	; 0x800c7c <gc_state+0x3d>
    1830:	40 91 7d 0c 	lds	r20, 0x0C7D	; 0x800c7d <gc_state+0x3e>
    1834:	50 91 7e 0c 	lds	r21, 0x0C7E	; 0x800c7e <gc_state+0x3f>
    1838:	0e 94 35 3c 	call	0x786a	; 0x786a <__addsf3>
    183c:	d6 01       	movw	r26, r12
    183e:	9e 96       	adiw	r26, 0x2e	; 46
    1840:	6d 93       	st	X+, r22
    1842:	7d 93       	st	X+, r23
    1844:	8d 93       	st	X+, r24
    1846:	9c 93       	st	X, r25
    1848:	d1 97       	sbiw	r26, 0x31	; 49
    184a:	20 c0       	rjmp	.+64     	; 0x188c <__EEPROM_REGION_LENGTH__+0x88c>
                } else {  // Incremental mode
                  gc_block.values.xyz[idx] += gc_state.position[idx];
    184c:	f8 01       	movw	r30, r16
    184e:	36 96       	adiw	r30, 0x06	; 6
    1850:	ee 0f       	add	r30, r30
    1852:	ff 1f       	adc	r31, r31
    1854:	ee 0f       	add	r30, r30
    1856:	ff 1f       	adc	r31, r31
    1858:	e1 5c       	subi	r30, 0xC1	; 193
    185a:	f3 4f       	sbci	r31, 0xF3	; 243
    185c:	20 81       	ld	r18, Z
    185e:	31 81       	ldd	r19, Z+1	; 0x01
    1860:	42 81       	ldd	r20, Z+2	; 0x02
    1862:	53 81       	ldd	r21, Z+3	; 0x03
    1864:	00 0f       	add	r16, r16
    1866:	11 1f       	adc	r17, r17
    1868:	00 0f       	add	r16, r16
    186a:	11 1f       	adc	r17, r17
    186c:	01 58       	subi	r16, 0x81	; 129
    186e:	13 4f       	sbci	r17, 0xF3	; 243
    1870:	f8 01       	movw	r30, r16
    1872:	66 a5       	ldd	r22, Z+46	; 0x2e
    1874:	77 a5       	ldd	r23, Z+47	; 0x2f
    1876:	80 a9       	ldd	r24, Z+48	; 0x30
    1878:	91 a9       	ldd	r25, Z+49	; 0x31
    187a:	0e 94 35 3c 	call	0x786a	; 0x786a <__addsf3>
    187e:	d8 01       	movw	r26, r16
    1880:	9e 96       	adiw	r26, 0x2e	; 46
    1882:	6d 93       	st	X+, r22
    1884:	7d 93       	st	X+, r23
    1886:	8d 93       	st	X+, r24
    1888:	9c 93       	st	X, r25
    188a:	d1 97       	sbiw	r26, 0x31	; 49
      // target position with the coordinate system offsets, G92 offsets, absolute override, and distance
      // modes applied. This includes the motion mode commands. We can now pre-compute the target position.
      // NOTE: Tool offsets may be appended to these conversions when/if this feature is added.
      if (axis_command != AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // TLO block any axis command.
        if (axis_words) {
          for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used to save flash space.
    188c:	63 94       	inc	r6
    188e:	01 c0       	rjmp	.+2      	; 0x1892 <__EEPROM_REGION_LENGTH__+0x892>
    1890:	61 2c       	mov	r6, r1
    1892:	b2 e0       	ldi	r27, 0x02	; 2
    1894:	b6 15       	cp	r27, r6
    1896:	08 f0       	brcs	.+2      	; 0x189a <__EEPROM_REGION_LENGTH__+0x89a>
    1898:	68 cf       	rjmp	.-304    	; 0x176a <__EEPROM_REGION_LENGTH__+0x76a>
          }
        }
      }

      // Check remaining non-modal commands for errors.
      switch (gc_block.non_modal_command) {
    189a:	ee e1       	ldi	r30, 0x1E	; 30
    189c:	7e 16       	cp	r7, r30
    189e:	39 f0       	breq	.+14     	; 0x18ae <__EEPROM_REGION_LENGTH__+0x8ae>
    18a0:	f5 e3       	ldi	r31, 0x35	; 53
    18a2:	7f 16       	cp	r7, r31
    18a4:	09 f4       	brne	.+2      	; 0x18a8 <__EEPROM_REGION_LENGTH__+0x8a8>
    18a6:	49 c0       	rjmp	.+146    	; 0x193a <__EEPROM_REGION_LENGTH__+0x93a>
    18a8:	2c e1       	ldi	r18, 0x1C	; 28
    18aa:	72 12       	cpse	r7, r18
    18ac:	4d c0       	rjmp	.+154    	; 0x1948 <__EEPROM_REGION_LENGTH__+0x948>
        case NON_MODAL_GO_HOME_0: // G28
        case NON_MODAL_GO_HOME_1: // G30
          // [G28/30 Errors]: Cutter compensation is enabled.
          // Retreive G28/30 go-home position data (in machine coordinates) from EEPROM
          // NOTE: Store parameter data in IJK values. By rule, they are not in use with this command.
          if (gc_block.non_modal_command == NON_MODAL_GO_HOME_0) {
    18ae:	3c e1       	ldi	r19, 0x1C	; 28
    18b0:	73 12       	cpse	r7, r19
    18b2:	09 c0       	rjmp	.+18     	; 0x18c6 <__EEPROM_REGION_LENGTH__+0x8c6>
            if (!settings_read_coord_data(SETTING_INDEX_G28,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); }
    18b4:	6f e8       	ldi	r22, 0x8F	; 143
    18b6:	7c e0       	ldi	r23, 0x0C	; 12
    18b8:	86 e0       	ldi	r24, 0x06	; 6
    18ba:	0e 94 18 25 	call	0x4a30	; 0x4a30 <settings_read_coord_data>
    18be:	88 23       	and	r24, r24
    18c0:	09 f4       	brne	.+2      	; 0x18c4 <__EEPROM_REGION_LENGTH__+0x8c4>
    18c2:	97 c5       	rjmp	.+2862   	; 0x23f2 <__stack+0x1f3>
    18c4:	08 c0       	rjmp	.+16     	; 0x18d6 <__EEPROM_REGION_LENGTH__+0x8d6>
          } else { // == NON_MODAL_GO_HOME_1
            if (!settings_read_coord_data(SETTING_INDEX_G30,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); }
    18c6:	6f e8       	ldi	r22, 0x8F	; 143
    18c8:	7c e0       	ldi	r23, 0x0C	; 12
    18ca:	87 e0       	ldi	r24, 0x07	; 7
    18cc:	0e 94 18 25 	call	0x4a30	; 0x4a30 <settings_read_coord_data>
    18d0:	88 23       	and	r24, r24
    18d2:	09 f4       	brne	.+2      	; 0x18d6 <__EEPROM_REGION_LENGTH__+0x8d6>
    18d4:	90 c5       	rjmp	.+2848   	; 0x23f6 <__stack+0x1f7>
          }
          if (axis_words) {
    18d6:	49 a1       	ldd	r20, Y+33	; 0x21
    18d8:	41 11       	cpse	r20, r1
    18da:	2a c0       	rjmp	.+84     	; 0x1930 <__EEPROM_REGION_LENGTH__+0x930>
  memset(&gc_block, 0, sizeof(parser_block_t)); // Initialize the parser block struct.
  memcpy(&gc_block.modal,&gc_state.modal,sizeof(gc_modal_t)); // Copy current modes

  uint8_t axis_command = AXIS_COMMAND_NONE;
  uint8_t axis_0, axis_1, axis_linear;
  uint8_t coord_select = 0; // Tracks G10 P coordinate selection for execution
    18dc:	51 2c       	mov	r5, r1
            // Move only the axes specified in secondary move.
            for (idx=0; idx<N_AXIS; idx++) {
              if (!(axis_words & (1<<idx))) { gc_block.values.ijk[idx] = gc_state.position[idx]; }
            }
          } else {
            axis_command = AXIS_COMMAND_NONE; // Set to none if no intermediate motion.
    18de:	1a a2       	std	Y+34, r1	; 0x22
    18e0:	34 c0       	rjmp	.+104    	; 0x194a <__EEPROM_REGION_LENGTH__+0x94a>
            if (!settings_read_coord_data(SETTING_INDEX_G30,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); }
          }
          if (axis_words) {
            // Move only the axes specified in secondary move.
            for (idx=0; idx<N_AXIS; idx++) {
              if (!(axis_words & (1<<idx))) { gc_block.values.ijk[idx] = gc_state.position[idx]; }
    18e2:	82 2f       	mov	r24, r18
    18e4:	90 e0       	ldi	r25, 0x00	; 0
    18e6:	a9 a1       	ldd	r26, Y+33	; 0x21
    18e8:	4a 2f       	mov	r20, r26
    18ea:	50 e0       	ldi	r21, 0x00	; 0
    18ec:	02 2e       	mov	r0, r18
    18ee:	02 c0       	rjmp	.+4      	; 0x18f4 <__EEPROM_REGION_LENGTH__+0x8f4>
    18f0:	55 95       	asr	r21
    18f2:	47 95       	ror	r20
    18f4:	0a 94       	dec	r0
    18f6:	e2 f7       	brpl	.-8      	; 0x18f0 <__EEPROM_REGION_LENGTH__+0x8f0>
    18f8:	40 fd       	sbrc	r20, 0
    18fa:	18 c0       	rjmp	.+48     	; 0x192c <__EEPROM_REGION_LENGTH__+0x92c>
    18fc:	fc 01       	movw	r30, r24
    18fe:	36 96       	adiw	r30, 0x06	; 6
    1900:	ee 0f       	add	r30, r30
    1902:	ff 1f       	adc	r31, r31
    1904:	ee 0f       	add	r30, r30
    1906:	ff 1f       	adc	r31, r31
    1908:	e1 5c       	subi	r30, 0xC1	; 193
    190a:	f3 4f       	sbci	r31, 0xF3	; 243
    190c:	40 81       	ld	r20, Z
    190e:	51 81       	ldd	r21, Z+1	; 0x01
    1910:	62 81       	ldd	r22, Z+2	; 0x02
    1912:	73 81       	ldd	r23, Z+3	; 0x03
    1914:	fc 01       	movw	r30, r24
    1916:	34 96       	adiw	r30, 0x04	; 4
    1918:	ee 0f       	add	r30, r30
    191a:	ff 1f       	adc	r31, r31
    191c:	ee 0f       	add	r30, r30
    191e:	ff 1f       	adc	r31, r31
    1920:	e1 58       	subi	r30, 0x81	; 129
    1922:	f3 4f       	sbci	r31, 0xF3	; 243
    1924:	40 83       	st	Z, r20
    1926:	51 83       	std	Z+1, r21	; 0x01
    1928:	62 83       	std	Z+2, r22	; 0x02
    192a:	73 83       	std	Z+3, r23	; 0x03
          } else { // == NON_MODAL_GO_HOME_1
            if (!settings_read_coord_data(SETTING_INDEX_G30,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); }
          }
          if (axis_words) {
            // Move only the axes specified in secondary move.
            for (idx=0; idx<N_AXIS; idx++) {
    192c:	2f 5f       	subi	r18, 0xFF	; 255
    192e:	01 c0       	rjmp	.+2      	; 0x1932 <__EEPROM_REGION_LENGTH__+0x932>
    1930:	20 e0       	ldi	r18, 0x00	; 0
    1932:	23 30       	cpi	r18, 0x03	; 3
    1934:	b0 f2       	brcs	.-84     	; 0x18e2 <__EEPROM_REGION_LENGTH__+0x8e2>
  memset(&gc_block, 0, sizeof(parser_block_t)); // Initialize the parser block struct.
  memcpy(&gc_block.modal,&gc_state.modal,sizeof(gc_modal_t)); // Copy current modes

  uint8_t axis_command = AXIS_COMMAND_NONE;
  uint8_t axis_0, axis_1, axis_linear;
  uint8_t coord_select = 0; // Tracks G10 P coordinate selection for execution
    1936:	51 2c       	mov	r5, r1
    1938:	08 c0       	rjmp	.+16     	; 0x194a <__EEPROM_REGION_LENGTH__+0x94a>
          // NOTE: If axis words are passed here, they are interpreted as an implicit motion mode.
          break;
        case NON_MODAL_ABSOLUTE_OVERRIDE:
          // [G53 Errors]: G0 and G1 are not active. Cutter compensation is enabled.
          // NOTE: All explicit axis word commands are in this modal group. So no implicit check necessary.
          if (!(gc_block.modal.motion == MOTION_MODE_SEEK || gc_block.modal.motion == MOTION_MODE_LINEAR)) {
    193a:	80 91 80 0c 	lds	r24, 0x0C80	; 0x800c80 <gc_block+0x1>
    193e:	82 30       	cpi	r24, 0x02	; 2
    1940:	08 f0       	brcs	.+2      	; 0x1944 <__EEPROM_REGION_LENGTH__+0x944>
    1942:	5b c5       	rjmp	.+2742   	; 0x23fa <__stack+0x1fb>
  memset(&gc_block, 0, sizeof(parser_block_t)); // Initialize the parser block struct.
  memcpy(&gc_block.modal,&gc_state.modal,sizeof(gc_modal_t)); // Copy current modes

  uint8_t axis_command = AXIS_COMMAND_NONE;
  uint8_t axis_0, axis_1, axis_linear;
  uint8_t coord_select = 0; // Tracks G10 P coordinate selection for execution
    1944:	51 2c       	mov	r5, r1
    1946:	01 c0       	rjmp	.+2      	; 0x194a <__EEPROM_REGION_LENGTH__+0x94a>
    1948:	51 2c       	mov	r5, r1
          break;
      }
  }

  // [20. Motion modes ]:
  if (gc_block.modal.motion == MOTION_MODE_NONE) {
    194a:	10 91 80 0c 	lds	r17, 0x0C80	; 0x800c80 <gc_block+0x1>
    194e:	10 35       	cpi	r17, 0x50	; 80
    1950:	21 f4       	brne	.+8      	; 0x195a <__EEPROM_REGION_LENGTH__+0x95a>
    // [G80 Errors]: Axis word are programmed while G80 is active.
    // NOTE: Even non-modal commands or TLO that use axis words will throw this strict error.
    if (axis_words) { FAIL(STATUS_GCODE_AXIS_WORDS_EXIST); } // [No axis words allowed]
    1952:	b9 a1       	ldd	r27, Y+33	; 0x21
    1954:	b1 11       	cpse	r27, r1
    1956:	53 c5       	rjmp	.+2726   	; 0x23fe <__stack+0x1ff>
    1958:	93 c2       	rjmp	.+1318   	; 0x1e80 <__EEPROM_REGION_LENGTH__+0xe80>

  // Check remaining motion modes, if axis word are implicit (exist and not used by G10/28/30/92), or
  // was explicitly commanded in the g-code block.
  } else if ( axis_command == AXIS_COMMAND_MOTION_MODE ) {
    195a:	ea a1       	ldd	r30, Y+34	; 0x22
    195c:	e2 30       	cpi	r30, 0x02	; 2
    195e:	09 f0       	breq	.+2      	; 0x1962 <__EEPROM_REGION_LENGTH__+0x962>
    1960:	8f c2       	rjmp	.+1310   	; 0x1e80 <__EEPROM_REGION_LENGTH__+0xe80>

    if (gc_block.modal.motion == MOTION_MODE_SEEK) {
    1962:	11 11       	cpse	r17, r1
    1964:	05 c0       	rjmp	.+10     	; 0x1970 <__EEPROM_REGION_LENGTH__+0x970>
      // [G0 Errors]: Axis letter not configured or without real value (done.)
      // Axis words are optional. If missing, set axis command flag to ignore execution.
      if (!axis_words) { axis_command = AXIS_COMMAND_NONE; }
    1966:	f9 a1       	ldd	r31, Y+33	; 0x21
    1968:	ff 23       	and	r31, r31
    196a:	09 f4       	brne	.+2      	; 0x196e <__EEPROM_REGION_LENGTH__+0x96e>
    196c:	86 c2       	rjmp	.+1292   	; 0x1e7a <__EEPROM_REGION_LENGTH__+0xe7a>
    196e:	88 c2       	rjmp	.+1296   	; 0x1e80 <__EEPROM_REGION_LENGTH__+0xe80>

    // All remaining motion modes (all but G0 and G80), require a valid feed rate value. In units per mm mode,
    // the value must be positive. In inverse time mode, a positive value must be passed with each block.
    } else {
      // Check if feed rate is defined for the motion modes that require it.
      if (gc_block.values.f == 0.0) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); } // [Feed rate undefined]
    1970:	60 91 8b 0c 	lds	r22, 0x0C8B	; 0x800c8b <gc_block+0xc>
    1974:	70 91 8c 0c 	lds	r23, 0x0C8C	; 0x800c8c <gc_block+0xd>
    1978:	80 91 8d 0c 	lds	r24, 0x0C8D	; 0x800c8d <gc_block+0xe>
    197c:	90 91 8e 0c 	lds	r25, 0x0C8E	; 0x800c8e <gc_block+0xf>
    1980:	20 e0       	ldi	r18, 0x00	; 0
    1982:	30 e0       	ldi	r19, 0x00	; 0
    1984:	a9 01       	movw	r20, r18
    1986:	0e 94 0e 3d 	call	0x7a1c	; 0x7a1c <__cmpsf2>
    198a:	88 23       	and	r24, r24
    198c:	09 f4       	brne	.+2      	; 0x1990 <__EEPROM_REGION_LENGTH__+0x990>
    198e:	39 c5       	rjmp	.+2674   	; 0x2402 <__stack+0x203>

      switch (gc_block.modal.motion) {
    1990:	1c 38       	cpi	r17, 0x8C	; 140
    1992:	09 f4       	brne	.+2      	; 0x1996 <__EEPROM_REGION_LENGTH__+0x996>
    1994:	5c c2       	rjmp	.+1208   	; 0x1e4e <__EEPROM_REGION_LENGTH__+0xe4e>
    1996:	40 f4       	brcc	.+16     	; 0x19a8 <__EEPROM_REGION_LENGTH__+0x9a8>
    1998:	12 30       	cpi	r17, 0x02	; 2
    199a:	a1 f0       	breq	.+40     	; 0x19c4 <__EEPROM_REGION_LENGTH__+0x9c4>
    199c:	13 30       	cpi	r17, 0x03	; 3
    199e:	a9 f0       	breq	.+42     	; 0x19ca <__EEPROM_REGION_LENGTH__+0x9ca>
    19a0:	11 30       	cpi	r17, 0x01	; 1
    19a2:	09 f0       	breq	.+2      	; 0x19a6 <__EEPROM_REGION_LENGTH__+0x9a6>
    19a4:	6d c2       	rjmp	.+1242   	; 0x1e80 <__EEPROM_REGION_LENGTH__+0xe80>
    19a6:	09 c0       	rjmp	.+18     	; 0x19ba <__EEPROM_REGION_LENGTH__+0x9ba>
    19a8:	1e 38       	cpi	r17, 0x8E	; 142
    19aa:	09 f4       	brne	.+2      	; 0x19ae <__EEPROM_REGION_LENGTH__+0x9ae>
    19ac:	50 c2       	rjmp	.+1184   	; 0x1e4e <__EEPROM_REGION_LENGTH__+0xe4e>
    19ae:	08 f4       	brcc	.+2      	; 0x19b2 <__EEPROM_REGION_LENGTH__+0x9b2>
    19b0:	4b c2       	rjmp	.+1174   	; 0x1e48 <__EEPROM_REGION_LENGTH__+0xe48>
    19b2:	1f 38       	cpi	r17, 0x8F	; 143
    19b4:	09 f4       	brne	.+2      	; 0x19b8 <__EEPROM_REGION_LENGTH__+0x9b8>
    19b6:	48 c2       	rjmp	.+1168   	; 0x1e48 <__EEPROM_REGION_LENGTH__+0xe48>
    19b8:	63 c2       	rjmp	.+1222   	; 0x1e80 <__EEPROM_REGION_LENGTH__+0xe80>
        case MOTION_MODE_LINEAR:
          // [G1 Errors]: Feed rate undefined. Axis letter not configured or without real value.
          // Axis words are optional. If missing, set axis command flag to ignore execution.
          if (!axis_words) { axis_command = AXIS_COMMAND_NONE; }
    19ba:	29 a1       	ldd	r18, Y+33	; 0x21
    19bc:	22 23       	and	r18, r18
    19be:	09 f4       	brne	.+2      	; 0x19c2 <__EEPROM_REGION_LENGTH__+0x9c2>
    19c0:	5e c2       	rjmp	.+1212   	; 0x1e7e <__EEPROM_REGION_LENGTH__+0xe7e>
    19c2:	5e c2       	rjmp	.+1212   	; 0x1e80 <__EEPROM_REGION_LENGTH__+0xe80>
          break;
        case MOTION_MODE_CW_ARC: 
          gc_parser_flags |= GC_PARSER_ARC_IS_CLOCKWISE; // No break intentional.
    19c4:	39 2d       	mov	r19, r9
    19c6:	34 60       	ori	r19, 0x04	; 4
    19c8:	93 2e       	mov	r9, r19
          // [G2/3 Offset-Mode Errors]: No axis words and/or offsets in selected plane. The radius to the current
          //   point and the radius to the target point differs more than 0.002mm (EMC def. 0.5mm OR 0.005mm and 0.1% radius).
          // [G2/3 Full-Circle-Mode Errors]: NOT SUPPORTED. Axis words exist. No offsets programmed. P must be an integer.
          // NOTE: Both radius and offsets are required for arc tracing and are pre-computed with the error-checking.

          if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    19ca:	49 a1       	ldd	r20, Y+33	; 0x21
    19cc:	44 23       	and	r20, r20
    19ce:	09 f4       	brne	.+2      	; 0x19d2 <__EEPROM_REGION_LENGTH__+0x9d2>
    19d0:	1a c5       	rjmp	.+2612   	; 0x2406 <__stack+0x207>
          if (!(axis_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_AXIS_WORDS_IN_PLANE); } // [No axis words in plane]
    19d2:	64 2c       	mov	r6, r4
    19d4:	71 2c       	mov	r7, r1
    19d6:	81 e0       	ldi	r24, 0x01	; 1
    19d8:	90 e0       	ldi	r25, 0x00	; 0
    19da:	8c 01       	movw	r16, r24
    19dc:	04 2c       	mov	r0, r4
    19de:	02 c0       	rjmp	.+4      	; 0x19e4 <__EEPROM_REGION_LENGTH__+0x9e4>
    19e0:	00 0f       	add	r16, r16
    19e2:	11 1f       	adc	r17, r17
    19e4:	0a 94       	dec	r0
    19e6:	e2 f7       	brpl	.-8      	; 0x19e0 <__EEPROM_REGION_LENGTH__+0x9e0>
    19e8:	5f 8d       	ldd	r21, Y+31	; 0x1f
    19ea:	25 2e       	mov	r2, r21
    19ec:	31 2c       	mov	r3, r1
    19ee:	02 c0       	rjmp	.+4      	; 0x19f4 <__EEPROM_REGION_LENGTH__+0x9f4>
    19f0:	88 0f       	add	r24, r24
    19f2:	99 1f       	adc	r25, r25
    19f4:	5a 95       	dec	r21
    19f6:	e2 f7       	brpl	.-8      	; 0x19f0 <__EEPROM_REGION_LENGTH__+0x9f0>
    19f8:	08 2b       	or	r16, r24
    19fa:	19 2b       	or	r17, r25
    19fc:	84 2f       	mov	r24, r20
    19fe:	90 e0       	ldi	r25, 0x00	; 0
    1a00:	80 23       	and	r24, r16
    1a02:	91 23       	and	r25, r17
    1a04:	89 2b       	or	r24, r25
    1a06:	09 f4       	brne	.+2      	; 0x1a0a <__EEPROM_REGION_LENGTH__+0xa0a>
    1a08:	00 c5       	rjmp	.+2560   	; 0x240a <__stack+0x20b>

          // Calculate the change in position along each selected axis
          float x,y;
          x = gc_block.values.xyz[axis_0]-gc_state.position[axis_0]; // Delta x between current position and target
    1a0a:	f3 01       	movw	r30, r6
    1a0c:	ee 0f       	add	r30, r30
    1a0e:	ff 1f       	adc	r31, r31
    1a10:	ee 0f       	add	r30, r30
    1a12:	ff 1f       	adc	r31, r31
    1a14:	e1 58       	subi	r30, 0x81	; 129
    1a16:	f3 4f       	sbci	r31, 0xF3	; 243
    1a18:	66 a5       	ldd	r22, Z+46	; 0x2e
    1a1a:	77 a5       	ldd	r23, Z+47	; 0x2f
    1a1c:	80 a9       	ldd	r24, Z+48	; 0x30
    1a1e:	91 a9       	ldd	r25, Z+49	; 0x31
    1a20:	f3 01       	movw	r30, r6
    1a22:	36 96       	adiw	r30, 0x06	; 6
    1a24:	ee 0f       	add	r30, r30
    1a26:	ff 1f       	adc	r31, r31
    1a28:	ee 0f       	add	r30, r30
    1a2a:	ff 1f       	adc	r31, r31
    1a2c:	e1 5c       	subi	r30, 0xC1	; 193
    1a2e:	f3 4f       	sbci	r31, 0xF3	; 243
    1a30:	20 81       	ld	r18, Z
    1a32:	31 81       	ldd	r19, Z+1	; 0x01
    1a34:	42 81       	ldd	r20, Z+2	; 0x02
    1a36:	53 81       	ldd	r21, Z+3	; 0x03
    1a38:	0e 94 34 3c 	call	0x7868	; 0x7868 <__subsf3>
    1a3c:	6f a3       	std	Y+39, r22	; 0x27
    1a3e:	78 a7       	std	Y+40, r23	; 0x28
    1a40:	89 a7       	std	Y+41, r24	; 0x29
    1a42:	9a a7       	std	Y+42, r25	; 0x2a
          y = gc_block.values.xyz[axis_1]-gc_state.position[axis_1]; // Delta y between current position and target
    1a44:	f1 01       	movw	r30, r2
    1a46:	ee 0f       	add	r30, r30
    1a48:	ff 1f       	adc	r31, r31
    1a4a:	ee 0f       	add	r30, r30
    1a4c:	ff 1f       	adc	r31, r31
    1a4e:	e1 58       	subi	r30, 0x81	; 129
    1a50:	f3 4f       	sbci	r31, 0xF3	; 243
    1a52:	66 a5       	ldd	r22, Z+46	; 0x2e
    1a54:	77 a5       	ldd	r23, Z+47	; 0x2f
    1a56:	80 a9       	ldd	r24, Z+48	; 0x30
    1a58:	91 a9       	ldd	r25, Z+49	; 0x31
    1a5a:	f1 01       	movw	r30, r2
    1a5c:	36 96       	adiw	r30, 0x06	; 6
    1a5e:	ee 0f       	add	r30, r30
    1a60:	ff 1f       	adc	r31, r31
    1a62:	ee 0f       	add	r30, r30
    1a64:	ff 1f       	adc	r31, r31
    1a66:	e1 5c       	subi	r30, 0xC1	; 193
    1a68:	f3 4f       	sbci	r31, 0xF3	; 243
    1a6a:	20 81       	ld	r18, Z
    1a6c:	31 81       	ldd	r19, Z+1	; 0x01
    1a6e:	42 81       	ldd	r20, Z+2	; 0x02
    1a70:	53 81       	ldd	r21, Z+3	; 0x03
    1a72:	0e 94 34 3c 	call	0x7868	; 0x7868 <__subsf3>
    1a76:	6c a7       	std	Y+44, r22	; 0x2c
    1a78:	7d a7       	std	Y+45, r23	; 0x2d
    1a7a:	8e a7       	std	Y+46, r24	; 0x2e
    1a7c:	9f a7       	std	Y+47, r25	; 0x2f

          if (value_words & bit(WORD_R)) { // Arc Radius Mode
    1a7e:	a7 fe       	sbrs	r10, 7
    1a80:	1d c1       	rjmp	.+570    	; 0x1cbc <__EEPROM_REGION_LENGTH__+0xcbc>
            bit_false(value_words,bit(WORD_R));
    1a82:	e8 94       	clt
    1a84:	a7 f8       	bld	r10, 7
            if (isequal_position_vector(gc_state.position, gc_block.values.xyz)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Invalid target]
    1a86:	4c e0       	ldi	r20, 0x0C	; 12
    1a88:	50 e0       	ldi	r21, 0x00	; 0
    1a8a:	6d ea       	ldi	r22, 0xAD	; 173
    1a8c:	7c e0       	ldi	r23, 0x0C	; 12
    1a8e:	87 e5       	ldi	r24, 0x57	; 87
    1a90:	9c e0       	ldi	r25, 0x0C	; 12
    1a92:	0e 94 72 40 	call	0x80e4	; 0x80e4 <memcmp>
    1a96:	89 2b       	or	r24, r25
    1a98:	09 f4       	brne	.+2      	; 0x1a9c <__EEPROM_REGION_LENGTH__+0xa9c>
    1a9a:	b9 c4       	rjmp	.+2418   	; 0x240e <__stack+0x20f>

            // Convert radius value to proper units.
            if (gc_block.modal.units == UNITS_MODE_INCHES) { gc_block.values.r *= MM_PER_INCH; }
    1a9c:	80 91 82 0c 	lds	r24, 0x0C82	; 0x800c82 <gc_block+0x3>
    1aa0:	81 30       	cpi	r24, 0x01	; 1
    1aa2:	a1 f4       	brne	.+40     	; 0x1acc <__EEPROM_REGION_LENGTH__+0xacc>
    1aa4:	0f e7       	ldi	r16, 0x7F	; 127
    1aa6:	1c e0       	ldi	r17, 0x0C	; 12
    1aa8:	23 e3       	ldi	r18, 0x33	; 51
    1aaa:	33 e3       	ldi	r19, 0x33	; 51
    1aac:	4b ec       	ldi	r20, 0xCB	; 203
    1aae:	51 e4       	ldi	r21, 0x41	; 65
    1ab0:	d8 01       	movw	r26, r16
    1ab2:	95 96       	adiw	r26, 0x25	; 37
    1ab4:	6d 91       	ld	r22, X+
    1ab6:	7d 91       	ld	r23, X+
    1ab8:	8d 91       	ld	r24, X+
    1aba:	9c 91       	ld	r25, X
    1abc:	98 97       	sbiw	r26, 0x28	; 40
    1abe:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
    1ac2:	f8 01       	movw	r30, r16
    1ac4:	65 a3       	std	Z+37, r22	; 0x25
    1ac6:	76 a3       	std	Z+38, r23	; 0x26
    1ac8:	87 a3       	std	Z+39, r24	; 0x27
    1aca:	90 a7       	std	Z+40, r25	; 0x28
                j = (y + (x * h_x2_div_d))/2
            */

            // First, use h_x2_div_d to compute 4*h^2 to check if it is negative or r is smaller
            // than d. If so, the sqrt of a negative number is complex and error out.
            float h_x2_div_d = 4.0 * gc_block.values.r*gc_block.values.r - x*x - y*y;
    1acc:	20 91 a4 0c 	lds	r18, 0x0CA4	; 0x800ca4 <gc_block+0x25>
    1ad0:	30 91 a5 0c 	lds	r19, 0x0CA5	; 0x800ca5 <gc_block+0x26>
    1ad4:	40 91 a6 0c 	lds	r20, 0x0CA6	; 0x800ca6 <gc_block+0x27>
    1ad8:	50 91 a7 0c 	lds	r21, 0x0CA7	; 0x800ca7 <gc_block+0x28>
    1adc:	2b a3       	std	Y+35, r18	; 0x23
    1ade:	3c a3       	std	Y+36, r19	; 0x24
    1ae0:	4d a3       	std	Y+37, r20	; 0x25
    1ae2:	5e a3       	std	Y+38, r21	; 0x26
    1ae4:	20 e0       	ldi	r18, 0x00	; 0
    1ae6:	30 e0       	ldi	r19, 0x00	; 0
    1ae8:	40 e8       	ldi	r20, 0x80	; 128
    1aea:	50 e4       	ldi	r21, 0x40	; 64
    1aec:	6b a1       	ldd	r22, Y+35	; 0x23
    1aee:	7c a1       	ldd	r23, Y+36	; 0x24
    1af0:	8d a1       	ldd	r24, Y+37	; 0x25
    1af2:	9e a1       	ldd	r25, Y+38	; 0x26
    1af4:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
    1af8:	9b 01       	movw	r18, r22
    1afa:	ac 01       	movw	r20, r24
    1afc:	6b a1       	ldd	r22, Y+35	; 0x23
    1afe:	7c a1       	ldd	r23, Y+36	; 0x24
    1b00:	8d a1       	ldd	r24, Y+37	; 0x25
    1b02:	9e a1       	ldd	r25, Y+38	; 0x26
    1b04:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
    1b08:	6b a3       	std	Y+35, r22	; 0x23
    1b0a:	7c a3       	std	Y+36, r23	; 0x24
    1b0c:	8d a3       	std	Y+37, r24	; 0x25
    1b0e:	9e a3       	std	Y+38, r25	; 0x26
    1b10:	2f a1       	ldd	r18, Y+39	; 0x27
    1b12:	38 a5       	ldd	r19, Y+40	; 0x28
    1b14:	49 a5       	ldd	r20, Y+41	; 0x29
    1b16:	5a a5       	ldd	r21, Y+42	; 0x2a
    1b18:	ca 01       	movw	r24, r20
    1b1a:	b9 01       	movw	r22, r18
    1b1c:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
    1b20:	9b 01       	movw	r18, r22
    1b22:	ac 01       	movw	r20, r24
    1b24:	6b a1       	ldd	r22, Y+35	; 0x23
    1b26:	7c a1       	ldd	r23, Y+36	; 0x24
    1b28:	8d a1       	ldd	r24, Y+37	; 0x25
    1b2a:	9e a1       	ldd	r25, Y+38	; 0x26
    1b2c:	0e 94 34 3c 	call	0x7868	; 0x7868 <__subsf3>
    1b30:	6b a3       	std	Y+35, r22	; 0x23
    1b32:	7c a3       	std	Y+36, r23	; 0x24
    1b34:	8d a3       	std	Y+37, r24	; 0x25
    1b36:	9e a3       	std	Y+38, r25	; 0x26
    1b38:	2c a5       	ldd	r18, Y+44	; 0x2c
    1b3a:	3d a5       	ldd	r19, Y+45	; 0x2d
    1b3c:	4e a5       	ldd	r20, Y+46	; 0x2e
    1b3e:	5f a5       	ldd	r21, Y+47	; 0x2f
    1b40:	ca 01       	movw	r24, r20
    1b42:	b9 01       	movw	r22, r18
    1b44:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
    1b48:	9b 01       	movw	r18, r22
    1b4a:	ac 01       	movw	r20, r24
    1b4c:	6b a1       	ldd	r22, Y+35	; 0x23
    1b4e:	7c a1       	ldd	r23, Y+36	; 0x24
    1b50:	8d a1       	ldd	r24, Y+37	; 0x25
    1b52:	9e a1       	ldd	r25, Y+38	; 0x26
    1b54:	0e 94 34 3c 	call	0x7868	; 0x7868 <__subsf3>
    1b58:	6b a3       	std	Y+35, r22	; 0x23
    1b5a:	7c a3       	std	Y+36, r23	; 0x24
    1b5c:	8d a3       	std	Y+37, r24	; 0x25
    1b5e:	9e a3       	std	Y+38, r25	; 0x26

            if (h_x2_div_d < 0) { FAIL(STATUS_GCODE_ARC_RADIUS_ERROR); } // [Arc radius error]
    1b60:	20 e0       	ldi	r18, 0x00	; 0
    1b62:	30 e0       	ldi	r19, 0x00	; 0
    1b64:	a9 01       	movw	r20, r18
    1b66:	0e 94 0e 3d 	call	0x7a1c	; 0x7a1c <__cmpsf2>
    1b6a:	88 23       	and	r24, r24
    1b6c:	0c f4       	brge	.+2      	; 0x1b70 <__EEPROM_REGION_LENGTH__+0xb70>
    1b6e:	51 c4       	rjmp	.+2210   	; 0x2412 <__stack+0x213>

            // Finish computing h_x2_div_d.
            h_x2_div_d = -sqrt(h_x2_div_d)/hypot_f(x,y); // == -(h * 2 / d)
    1b70:	6b a1       	ldd	r22, Y+35	; 0x23
    1b72:	7c a1       	ldd	r23, Y+36	; 0x24
    1b74:	8d a1       	ldd	r24, Y+37	; 0x25
    1b76:	9e a1       	ldd	r25, Y+38	; 0x26
    1b78:	0e 94 d9 3f 	call	0x7fb2	; 0x7fb2 <sqrt>
    1b7c:	9b 01       	movw	r18, r22
    1b7e:	ac 01       	movw	r20, r24
    1b80:	50 58       	subi	r21, 0x80	; 128
    1b82:	2b a3       	std	Y+35, r18	; 0x23
    1b84:	3c a3       	std	Y+36, r19	; 0x24
    1b86:	4d a3       	std	Y+37, r20	; 0x25
    1b88:	5e a3       	std	Y+38, r21	; 0x26
    1b8a:	2c a5       	ldd	r18, Y+44	; 0x2c
    1b8c:	3d a5       	ldd	r19, Y+45	; 0x2d
    1b8e:	4e a5       	ldd	r20, Y+46	; 0x2e
    1b90:	5f a5       	ldd	r21, Y+47	; 0x2f
    1b92:	6f a1       	ldd	r22, Y+39	; 0x27
    1b94:	78 a5       	ldd	r23, Y+40	; 0x28
    1b96:	89 a5       	ldd	r24, Y+41	; 0x29
    1b98:	9a a5       	ldd	r25, Y+42	; 0x2a
    1b9a:	0e 94 a2 2d 	call	0x5b44	; 0x5b44 <hypot_f>
    1b9e:	9b 01       	movw	r18, r22
    1ba0:	ac 01       	movw	r20, r24
    1ba2:	6b a1       	ldd	r22, Y+35	; 0x23
    1ba4:	7c a1       	ldd	r23, Y+36	; 0x24
    1ba6:	8d a1       	ldd	r24, Y+37	; 0x25
    1ba8:	9e a1       	ldd	r25, Y+38	; 0x26
    1baa:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <__divsf3>
    1bae:	6b a3       	std	Y+35, r22	; 0x23
    1bb0:	7c a3       	std	Y+36, r23	; 0x24
    1bb2:	8d a3       	std	Y+37, r24	; 0x25
    1bb4:	9e a3       	std	Y+38, r25	; 0x26
            // Invert the sign of h_x2_div_d if the circle is counter clockwise (see sketch below)
            if (gc_block.modal.motion == MOTION_MODE_CCW_ARC) { h_x2_div_d = -h_x2_div_d; }
    1bb6:	80 91 80 0c 	lds	r24, 0x0C80	; 0x800c80 <gc_block+0x1>
    1bba:	83 30       	cpi	r24, 0x03	; 3
    1bbc:	49 f4       	brne	.+18     	; 0x1bd0 <__EEPROM_REGION_LENGTH__+0xbd0>
    1bbe:	8b a1       	ldd	r24, Y+35	; 0x23
    1bc0:	9c a1       	ldd	r25, Y+36	; 0x24
    1bc2:	ad a1       	ldd	r26, Y+37	; 0x25
    1bc4:	be a1       	ldd	r27, Y+38	; 0x26
    1bc6:	b0 58       	subi	r27, 0x80	; 128
    1bc8:	8b a3       	std	Y+35, r24	; 0x23
    1bca:	9c a3       	std	Y+36, r25	; 0x24
    1bcc:	ad a3       	std	Y+37, r26	; 0x25
    1bce:	be a3       	std	Y+38, r27	; 0x26
            */
            // Negative R is g-code-alese for "I want a circle with more than 180 degrees of travel" (go figure!),
            // even though it is advised against ever generating such circles in a single line of g-code. By
            // inverting the sign of h_x2_div_d the center of the circles is placed on the opposite side of the line of
            // travel and thus we get the unadvisably long arcs as prescribed.
            if (gc_block.values.r < 0) {
    1bd0:	20 91 a4 0c 	lds	r18, 0x0CA4	; 0x800ca4 <gc_block+0x25>
    1bd4:	30 91 a5 0c 	lds	r19, 0x0CA5	; 0x800ca5 <gc_block+0x26>
    1bd8:	40 91 a6 0c 	lds	r20, 0x0CA6	; 0x800ca6 <gc_block+0x27>
    1bdc:	50 91 a7 0c 	lds	r21, 0x0CA7	; 0x800ca7 <gc_block+0x28>
    1be0:	28 ab       	std	Y+48, r18	; 0x30
    1be2:	39 ab       	std	Y+49, r19	; 0x31
    1be4:	4a ab       	std	Y+50, r20	; 0x32
    1be6:	5b ab       	std	Y+51, r21	; 0x33
    1be8:	20 e0       	ldi	r18, 0x00	; 0
    1bea:	30 e0       	ldi	r19, 0x00	; 0
    1bec:	a9 01       	movw	r20, r18
    1bee:	68 a9       	ldd	r22, Y+48	; 0x30
    1bf0:	79 a9       	ldd	r23, Y+49	; 0x31
    1bf2:	8a a9       	ldd	r24, Y+50	; 0x32
    1bf4:	9b a9       	ldd	r25, Y+51	; 0x33
    1bf6:	0e 94 0e 3d 	call	0x7a1c	; 0x7a1c <__cmpsf2>
    1bfa:	88 23       	and	r24, r24
    1bfc:	b4 f4       	brge	.+44     	; 0x1c2a <__EEPROM_REGION_LENGTH__+0xc2a>
                h_x2_div_d = -h_x2_div_d;
    1bfe:	8b a1       	ldd	r24, Y+35	; 0x23
    1c00:	9c a1       	ldd	r25, Y+36	; 0x24
    1c02:	ad a1       	ldd	r26, Y+37	; 0x25
    1c04:	be a1       	ldd	r27, Y+38	; 0x26
    1c06:	b0 58       	subi	r27, 0x80	; 128
    1c08:	8b a3       	std	Y+35, r24	; 0x23
    1c0a:	9c a3       	std	Y+36, r25	; 0x24
    1c0c:	ad a3       	std	Y+37, r26	; 0x25
    1c0e:	be a3       	std	Y+38, r27	; 0x26
                gc_block.values.r = -gc_block.values.r; // Finished with r. Set to positive for mc_arc
    1c10:	88 a9       	ldd	r24, Y+48	; 0x30
    1c12:	99 a9       	ldd	r25, Y+49	; 0x31
    1c14:	aa a9       	ldd	r26, Y+50	; 0x32
    1c16:	bb a9       	ldd	r27, Y+51	; 0x33
    1c18:	b0 58       	subi	r27, 0x80	; 128
    1c1a:	80 93 a4 0c 	sts	0x0CA4, r24	; 0x800ca4 <gc_block+0x25>
    1c1e:	90 93 a5 0c 	sts	0x0CA5, r25	; 0x800ca5 <gc_block+0x26>
    1c22:	a0 93 a6 0c 	sts	0x0CA6, r26	; 0x800ca6 <gc_block+0x27>
    1c26:	b0 93 a7 0c 	sts	0x0CA7, r27	; 0x800ca7 <gc_block+0x28>
            }
            // Complete the operation by calculating the actual center of the arc
            gc_block.values.ijk[axis_0] = 0.5*(x-(y*h_x2_div_d));
    1c2a:	2c a5       	ldd	r18, Y+44	; 0x2c
    1c2c:	3d a5       	ldd	r19, Y+45	; 0x2d
    1c2e:	4e a5       	ldd	r20, Y+46	; 0x2e
    1c30:	5f a5       	ldd	r21, Y+47	; 0x2f
    1c32:	6b a1       	ldd	r22, Y+35	; 0x23
    1c34:	7c a1       	ldd	r23, Y+36	; 0x24
    1c36:	8d a1       	ldd	r24, Y+37	; 0x25
    1c38:	9e a1       	ldd	r25, Y+38	; 0x26
    1c3a:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
    1c3e:	9b 01       	movw	r18, r22
    1c40:	ac 01       	movw	r20, r24
    1c42:	6f a1       	ldd	r22, Y+39	; 0x27
    1c44:	78 a5       	ldd	r23, Y+40	; 0x28
    1c46:	89 a5       	ldd	r24, Y+41	; 0x29
    1c48:	9a a5       	ldd	r25, Y+42	; 0x2a
    1c4a:	0e 94 34 3c 	call	0x7868	; 0x7868 <__subsf3>
    1c4e:	20 e0       	ldi	r18, 0x00	; 0
    1c50:	30 e0       	ldi	r19, 0x00	; 0
    1c52:	40 e0       	ldi	r20, 0x00	; 0
    1c54:	5f e3       	ldi	r21, 0x3F	; 63
    1c56:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
    1c5a:	f3 01       	movw	r30, r6
    1c5c:	34 96       	adiw	r30, 0x04	; 4
    1c5e:	ee 0f       	add	r30, r30
    1c60:	ff 1f       	adc	r31, r31
    1c62:	ee 0f       	add	r30, r30
    1c64:	ff 1f       	adc	r31, r31
    1c66:	e1 58       	subi	r30, 0x81	; 129
    1c68:	f3 4f       	sbci	r31, 0xF3	; 243
    1c6a:	60 83       	st	Z, r22
    1c6c:	71 83       	std	Z+1, r23	; 0x01
    1c6e:	82 83       	std	Z+2, r24	; 0x02
    1c70:	93 83       	std	Z+3, r25	; 0x03
            gc_block.values.ijk[axis_1] = 0.5*(y+(x*h_x2_div_d));
    1c72:	2f a1       	ldd	r18, Y+39	; 0x27
    1c74:	38 a5       	ldd	r19, Y+40	; 0x28
    1c76:	49 a5       	ldd	r20, Y+41	; 0x29
    1c78:	5a a5       	ldd	r21, Y+42	; 0x2a
    1c7a:	6b a1       	ldd	r22, Y+35	; 0x23
    1c7c:	7c a1       	ldd	r23, Y+36	; 0x24
    1c7e:	8d a1       	ldd	r24, Y+37	; 0x25
    1c80:	9e a1       	ldd	r25, Y+38	; 0x26
    1c82:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
    1c86:	9b 01       	movw	r18, r22
    1c88:	ac 01       	movw	r20, r24
    1c8a:	6c a5       	ldd	r22, Y+44	; 0x2c
    1c8c:	7d a5       	ldd	r23, Y+45	; 0x2d
    1c8e:	8e a5       	ldd	r24, Y+46	; 0x2e
    1c90:	9f a5       	ldd	r25, Y+47	; 0x2f
    1c92:	0e 94 35 3c 	call	0x786a	; 0x786a <__addsf3>
    1c96:	20 e0       	ldi	r18, 0x00	; 0
    1c98:	30 e0       	ldi	r19, 0x00	; 0
    1c9a:	40 e0       	ldi	r20, 0x00	; 0
    1c9c:	5f e3       	ldi	r21, 0x3F	; 63
    1c9e:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
    1ca2:	f1 01       	movw	r30, r2
    1ca4:	34 96       	adiw	r30, 0x04	; 4
    1ca6:	ee 0f       	add	r30, r30
    1ca8:	ff 1f       	adc	r31, r31
    1caa:	ee 0f       	add	r30, r30
    1cac:	ff 1f       	adc	r31, r31
    1cae:	e1 58       	subi	r30, 0x81	; 129
    1cb0:	f3 4f       	sbci	r31, 0xF3	; 243
    1cb2:	60 83       	st	Z, r22
    1cb4:	71 83       	std	Z+1, r23	; 0x01
    1cb6:	82 83       	std	Z+2, r24	; 0x02
    1cb8:	93 83       	std	Z+3, r25	; 0x03
    1cba:	e2 c0       	rjmp	.+452    	; 0x1e80 <__EEPROM_REGION_LENGTH__+0xe80>

          } else { // Arc Center Format Offset Mode
            if (!(ijk_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_OFFSETS_IN_PLANE); } // [No offsets in plane]
    1cbc:	c8 2c       	mov	r12, r8
    1cbe:	d1 2c       	mov	r13, r1
    1cc0:	0c 21       	and	r16, r12
    1cc2:	1d 21       	and	r17, r13
    1cc4:	01 2b       	or	r16, r17
    1cc6:	09 f4       	brne	.+2      	; 0x1cca <__EEPROM_REGION_LENGTH__+0xcca>
    1cc8:	a6 c3       	rjmp	.+1868   	; 0x2416 <__stack+0x217>
            bit_false(value_words,(bit(WORD_I)|bit(WORD_J)|bit(WORD_K)));
    1cca:	91 ef       	ldi	r25, 0xF1	; 241
    1ccc:	a9 22       	and	r10, r25

            // Convert IJK values to proper units.
            if (gc_block.modal.units == UNITS_MODE_INCHES) {
    1cce:	80 91 82 0c 	lds	r24, 0x0C82	; 0x800c82 <gc_block+0x3>
    1cd2:	81 30       	cpi	r24, 0x01	; 1
    1cd4:	51 f5       	brne	.+84     	; 0x1d2a <__EEPROM_REGION_LENGTH__+0xd2a>
    1cd6:	25 c0       	rjmp	.+74     	; 0x1d22 <__EEPROM_REGION_LENGTH__+0xd22>
              for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used to save flash space.
                if (ijk_words & bit(idx)) { gc_block.values.ijk[idx] *= MM_PER_INCH; }
    1cd8:	08 2d       	mov	r16, r8
    1cda:	10 e0       	ldi	r17, 0x00	; 0
    1cdc:	c6 01       	movw	r24, r12
    1cde:	08 2c       	mov	r0, r8
    1ce0:	02 c0       	rjmp	.+4      	; 0x1ce6 <__EEPROM_REGION_LENGTH__+0xce6>
    1ce2:	95 95       	asr	r25
    1ce4:	87 95       	ror	r24
    1ce6:	0a 94       	dec	r0
    1ce8:	e2 f7       	brpl	.-8      	; 0x1ce2 <__EEPROM_REGION_LENGTH__+0xce2>
    1cea:	80 ff       	sbrs	r24, 0
    1cec:	18 c0       	rjmp	.+48     	; 0x1d1e <__EEPROM_REGION_LENGTH__+0xd1e>
    1cee:	0c 5f       	subi	r16, 0xFC	; 252
    1cf0:	1f 4f       	sbci	r17, 0xFF	; 255
    1cf2:	00 0f       	add	r16, r16
    1cf4:	11 1f       	adc	r17, r17
    1cf6:	00 0f       	add	r16, r16
    1cf8:	11 1f       	adc	r17, r17
    1cfa:	01 58       	subi	r16, 0x81	; 129
    1cfc:	13 4f       	sbci	r17, 0xF3	; 243
    1cfe:	23 e3       	ldi	r18, 0x33	; 51
    1d00:	33 e3       	ldi	r19, 0x33	; 51
    1d02:	4b ec       	ldi	r20, 0xCB	; 203
    1d04:	51 e4       	ldi	r21, 0x41	; 65
    1d06:	d8 01       	movw	r26, r16
    1d08:	6d 91       	ld	r22, X+
    1d0a:	7d 91       	ld	r23, X+
    1d0c:	8d 91       	ld	r24, X+
    1d0e:	9c 91       	ld	r25, X
    1d10:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
    1d14:	f8 01       	movw	r30, r16
    1d16:	60 83       	st	Z, r22
    1d18:	71 83       	std	Z+1, r23	; 0x01
    1d1a:	82 83       	std	Z+2, r24	; 0x02
    1d1c:	93 83       	std	Z+3, r25	; 0x03
            if (!(ijk_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_OFFSETS_IN_PLANE); } // [No offsets in plane]
            bit_false(value_words,(bit(WORD_I)|bit(WORD_J)|bit(WORD_K)));

            // Convert IJK values to proper units.
            if (gc_block.modal.units == UNITS_MODE_INCHES) {
              for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used to save flash space.
    1d1e:	83 94       	inc	r8
    1d20:	01 c0       	rjmp	.+2      	; 0x1d24 <__EEPROM_REGION_LENGTH__+0xd24>
    1d22:	81 2c       	mov	r8, r1
    1d24:	f2 e0       	ldi	r31, 0x02	; 2
    1d26:	f8 15       	cp	r31, r8
    1d28:	b8 f6       	brcc	.-82     	; 0x1cd8 <__EEPROM_REGION_LENGTH__+0xcd8>
                if (ijk_words & bit(idx)) { gc_block.values.ijk[idx] *= MM_PER_INCH; }
              }
            }

            // Arc radius from center to target
            x -= gc_block.values.ijk[axis_0]; // Delta x between circle center and target
    1d2a:	83 01       	movw	r16, r6
    1d2c:	0c 5f       	subi	r16, 0xFC	; 252
    1d2e:	1f 4f       	sbci	r17, 0xFF	; 255
    1d30:	00 0f       	add	r16, r16
    1d32:	11 1f       	adc	r17, r17
    1d34:	00 0f       	add	r16, r16
    1d36:	11 1f       	adc	r17, r17
    1d38:	01 58       	subi	r16, 0x81	; 129
    1d3a:	13 4f       	sbci	r17, 0xF3	; 243
    1d3c:	d8 01       	movw	r26, r16
    1d3e:	2d 91       	ld	r18, X+
    1d40:	3d 91       	ld	r19, X+
    1d42:	4d 91       	ld	r20, X+
    1d44:	5c 91       	ld	r21, X
    1d46:	6f a1       	ldd	r22, Y+39	; 0x27
    1d48:	78 a5       	ldd	r23, Y+40	; 0x28
    1d4a:	89 a5       	ldd	r24, Y+41	; 0x29
    1d4c:	9a a5       	ldd	r25, Y+42	; 0x2a
    1d4e:	0e 94 34 3c 	call	0x7868	; 0x7868 <__subsf3>
    1d52:	6b a3       	std	Y+35, r22	; 0x23
    1d54:	7c a3       	std	Y+36, r23	; 0x24
    1d56:	8d a3       	std	Y+37, r24	; 0x25
    1d58:	9e a3       	std	Y+38, r25	; 0x26
            y -= gc_block.values.ijk[axis_1]; // Delta y between circle center and target
    1d5a:	c1 01       	movw	r24, r2
    1d5c:	04 96       	adiw	r24, 0x04	; 4
    1d5e:	88 0f       	add	r24, r24
    1d60:	99 1f       	adc	r25, r25
    1d62:	88 0f       	add	r24, r24
    1d64:	99 1f       	adc	r25, r25
    1d66:	fc 01       	movw	r30, r24
    1d68:	e1 58       	subi	r30, 0x81	; 129
    1d6a:	f3 4f       	sbci	r31, 0xF3	; 243
    1d6c:	6f 01       	movw	r12, r30
    1d6e:	20 81       	ld	r18, Z
    1d70:	31 81       	ldd	r19, Z+1	; 0x01
    1d72:	42 81       	ldd	r20, Z+2	; 0x02
    1d74:	53 81       	ldd	r21, Z+3	; 0x03
    1d76:	6c a5       	ldd	r22, Y+44	; 0x2c
    1d78:	7d a5       	ldd	r23, Y+45	; 0x2d
    1d7a:	8e a5       	ldd	r24, Y+46	; 0x2e
    1d7c:	9f a5       	ldd	r25, Y+47	; 0x2f
    1d7e:	0e 94 34 3c 	call	0x7868	; 0x7868 <__subsf3>
    1d82:	9b 01       	movw	r18, r22
    1d84:	ac 01       	movw	r20, r24
            float target_r = hypot_f(x,y);
    1d86:	6b a1       	ldd	r22, Y+35	; 0x23
    1d88:	7c a1       	ldd	r23, Y+36	; 0x24
    1d8a:	8d a1       	ldd	r24, Y+37	; 0x25
    1d8c:	9e a1       	ldd	r25, Y+38	; 0x26
    1d8e:	0e 94 a2 2d 	call	0x5b44	; 0x5b44 <hypot_f>
    1d92:	6f a3       	std	Y+39, r22	; 0x27
    1d94:	78 a7       	std	Y+40, r23	; 0x28
    1d96:	89 a7       	std	Y+41, r24	; 0x29
    1d98:	9a a7       	std	Y+42, r25	; 0x2a

            // Compute arc radius for mc_arc. Defined from current location to center.
            gc_block.values.r = hypot_f(gc_block.values.ijk[axis_0], gc_block.values.ijk[axis_1]);
    1d9a:	d6 01       	movw	r26, r12
    1d9c:	2d 91       	ld	r18, X+
    1d9e:	3d 91       	ld	r19, X+
    1da0:	4d 91       	ld	r20, X+
    1da2:	5c 91       	ld	r21, X
    1da4:	f8 01       	movw	r30, r16
    1da6:	60 81       	ld	r22, Z
    1da8:	71 81       	ldd	r23, Z+1	; 0x01
    1daa:	82 81       	ldd	r24, Z+2	; 0x02
    1dac:	93 81       	ldd	r25, Z+3	; 0x03
    1dae:	0e 94 a2 2d 	call	0x5b44	; 0x5b44 <hypot_f>
    1db2:	6b a3       	std	Y+35, r22	; 0x23
    1db4:	7c a3       	std	Y+36, r23	; 0x24
    1db6:	8d a3       	std	Y+37, r24	; 0x25
    1db8:	9e a3       	std	Y+38, r25	; 0x26
    1dba:	60 93 a4 0c 	sts	0x0CA4, r22	; 0x800ca4 <gc_block+0x25>
    1dbe:	70 93 a5 0c 	sts	0x0CA5, r23	; 0x800ca5 <gc_block+0x26>
    1dc2:	80 93 a6 0c 	sts	0x0CA6, r24	; 0x800ca6 <gc_block+0x27>
    1dc6:	90 93 a7 0c 	sts	0x0CA7, r25	; 0x800ca7 <gc_block+0x28>

            // Compute difference between current location and target radii for final error-checks.
            float delta_r = fabs(target_r-gc_block.values.r);
    1dca:	9b 01       	movw	r18, r22
    1dcc:	ac 01       	movw	r20, r24
    1dce:	6f a1       	ldd	r22, Y+39	; 0x27
    1dd0:	78 a5       	ldd	r23, Y+40	; 0x28
    1dd2:	89 a5       	ldd	r24, Y+41	; 0x29
    1dd4:	9a a5       	ldd	r25, Y+42	; 0x2a
    1dd6:	0e 94 34 3c 	call	0x7868	; 0x7868 <__subsf3>
    1dda:	9b 01       	movw	r18, r22
    1ddc:	ac 01       	movw	r20, r24
    1dde:	5f 77       	andi	r21, 0x7F	; 127
    1de0:	2f a3       	std	Y+39, r18	; 0x27
    1de2:	38 a7       	std	Y+40, r19	; 0x28
    1de4:	49 a7       	std	Y+41, r20	; 0x29
    1de6:	5a a7       	std	Y+42, r21	; 0x2a
            if (delta_r > 0.005) {
    1de8:	2a e0       	ldi	r18, 0x0A	; 10
    1dea:	37 ed       	ldi	r19, 0xD7	; 215
    1dec:	43 ea       	ldi	r20, 0xA3	; 163
    1dee:	5b e3       	ldi	r21, 0x3B	; 59
    1df0:	6f a1       	ldd	r22, Y+39	; 0x27
    1df2:	78 a5       	ldd	r23, Y+40	; 0x28
    1df4:	89 a5       	ldd	r24, Y+41	; 0x29
    1df6:	9a a5       	ldd	r25, Y+42	; 0x2a
    1df8:	0e 94 11 3f 	call	0x7e22	; 0x7e22 <__gesf2>
    1dfc:	18 16       	cp	r1, r24
    1dfe:	0c f0       	brlt	.+2      	; 0x1e02 <__EEPROM_REGION_LENGTH__+0xe02>
    1e00:	3f c0       	rjmp	.+126    	; 0x1e80 <__EEPROM_REGION_LENGTH__+0xe80>
              if (delta_r > 0.5) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Arc definition error] > 0.5mm
    1e02:	20 e0       	ldi	r18, 0x00	; 0
    1e04:	30 e0       	ldi	r19, 0x00	; 0
    1e06:	40 e0       	ldi	r20, 0x00	; 0
    1e08:	5f e3       	ldi	r21, 0x3F	; 63
    1e0a:	6f a1       	ldd	r22, Y+39	; 0x27
    1e0c:	78 a5       	ldd	r23, Y+40	; 0x28
    1e0e:	89 a5       	ldd	r24, Y+41	; 0x29
    1e10:	9a a5       	ldd	r25, Y+42	; 0x2a
    1e12:	0e 94 11 3f 	call	0x7e22	; 0x7e22 <__gesf2>
    1e16:	18 16       	cp	r1, r24
    1e18:	0c f4       	brge	.+2      	; 0x1e1c <__EEPROM_REGION_LENGTH__+0xe1c>
    1e1a:	ff c2       	rjmp	.+1534   	; 0x241a <__stack+0x21b>
              if (delta_r > (0.001*gc_block.values.r)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Arc definition error] > 0.005mm AND 0.1% radius
    1e1c:	2f e6       	ldi	r18, 0x6F	; 111
    1e1e:	32 e1       	ldi	r19, 0x12	; 18
    1e20:	43 e8       	ldi	r20, 0x83	; 131
    1e22:	5a e3       	ldi	r21, 0x3A	; 58
    1e24:	6b a1       	ldd	r22, Y+35	; 0x23
    1e26:	7c a1       	ldd	r23, Y+36	; 0x24
    1e28:	8d a1       	ldd	r24, Y+37	; 0x25
    1e2a:	9e a1       	ldd	r25, Y+38	; 0x26
    1e2c:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
    1e30:	9b 01       	movw	r18, r22
    1e32:	ac 01       	movw	r20, r24
    1e34:	6f a1       	ldd	r22, Y+39	; 0x27
    1e36:	78 a5       	ldd	r23, Y+40	; 0x28
    1e38:	89 a5       	ldd	r24, Y+41	; 0x29
    1e3a:	9a a5       	ldd	r25, Y+42	; 0x2a
    1e3c:	0e 94 11 3f 	call	0x7e22	; 0x7e22 <__gesf2>
    1e40:	18 16       	cp	r1, r24
    1e42:	0c f4       	brge	.+2      	; 0x1e46 <__EEPROM_REGION_LENGTH__+0xe46>
    1e44:	ec c2       	rjmp	.+1496   	; 0x241e <__stack+0x21f>
    1e46:	1c c0       	rjmp	.+56     	; 0x1e80 <__EEPROM_REGION_LENGTH__+0xe80>
            }
          }
          break;
        case MOTION_MODE_PROBE_TOWARD_NO_ERROR: case MOTION_MODE_PROBE_AWAY_NO_ERROR:
          gc_parser_flags |= GC_PARSER_PROBE_IS_NO_ERROR; // No break intentional.
    1e48:	39 2d       	mov	r19, r9
    1e4a:	30 61       	ori	r19, 0x10	; 16
    1e4c:	93 2e       	mov	r9, r19
        case MOTION_MODE_PROBE_TOWARD: case MOTION_MODE_PROBE_AWAY:
          if ((gc_block.modal.motion == MOTION_MODE_PROBE_AWAY) || 
    1e4e:	1e 58       	subi	r17, 0x8E	; 142
    1e50:	12 30       	cpi	r17, 0x02	; 2
    1e52:	18 f4       	brcc	.+6      	; 0x1e5a <__EEPROM_REGION_LENGTH__+0xe5a>
              (gc_block.modal.motion == MOTION_MODE_PROBE_AWAY_NO_ERROR)) { gc_parser_flags |= GC_PARSER_PROBE_IS_AWAY; }
    1e54:	49 2d       	mov	r20, r9
    1e56:	48 60       	ori	r20, 0x08	; 8
    1e58:	94 2e       	mov	r9, r20
          // [G38 Errors]: Target is same current. No axis words. Cutter compensation is enabled. Feed rate
          //   is undefined. Probe is triggered. NOTE: Probe check moved to probe cycle. Instead of returning
          //   an error, it issues an alarm to prevent further motion to the probe. It's also done there to
          //   allow the planner buffer to empty and move off the probe trigger before another probing cycle.
          if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    1e5a:	59 a1       	ldd	r21, Y+33	; 0x21
    1e5c:	55 23       	and	r21, r21
    1e5e:	09 f4       	brne	.+2      	; 0x1e62 <__EEPROM_REGION_LENGTH__+0xe62>
    1e60:	e0 c2       	rjmp	.+1472   	; 0x2422 <__stack+0x223>
          if (isequal_position_vector(gc_state.position, gc_block.values.xyz)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Invalid target]
    1e62:	4c e0       	ldi	r20, 0x0C	; 12
    1e64:	50 e0       	ldi	r21, 0x00	; 0
    1e66:	6d ea       	ldi	r22, 0xAD	; 173
    1e68:	7c e0       	ldi	r23, 0x0C	; 12
    1e6a:	87 e5       	ldi	r24, 0x57	; 87
    1e6c:	9c e0       	ldi	r25, 0x0C	; 12
    1e6e:	0e 94 72 40 	call	0x80e4	; 0x80e4 <memcmp>
    1e72:	89 2b       	or	r24, r25
    1e74:	09 f4       	brne	.+2      	; 0x1e78 <__EEPROM_REGION_LENGTH__+0xe78>
    1e76:	d7 c2       	rjmp	.+1454   	; 0x2426 <__stack+0x227>
    1e78:	03 c0       	rjmp	.+6      	; 0x1e80 <__EEPROM_REGION_LENGTH__+0xe80>
  } else if ( axis_command == AXIS_COMMAND_MOTION_MODE ) {

    if (gc_block.modal.motion == MOTION_MODE_SEEK) {
      // [G0 Errors]: Axis letter not configured or without real value (done.)
      // Axis words are optional. If missing, set axis command flag to ignore execution.
      if (!axis_words) { axis_command = AXIS_COMMAND_NONE; }
    1e7a:	1a a2       	std	Y+34, r1	; 0x22
    1e7c:	01 c0       	rjmp	.+2      	; 0x1e80 <__EEPROM_REGION_LENGTH__+0xe80>

      switch (gc_block.modal.motion) {
        case MOTION_MODE_LINEAR:
          // [G1 Errors]: Feed rate undefined. Axis letter not configured or without real value.
          // Axis words are optional. If missing, set axis command flag to ignore execution.
          if (!axis_words) { axis_command = AXIS_COMMAND_NONE; }
    1e7e:	1a a2       	std	Y+34, r1	; 0x22

  // [21. Program flow ]: No error checks required.

  // [0. Non-specific error-checks]: Complete unused value words check, i.e. IJK used when in arc
  // radius mode, or axis words that aren't used in the block.
  if (gc_parser_flags & GC_PARSER_JOG_MOTION) {
    1e80:	89 2d       	mov	r24, r9
    1e82:	81 70       	andi	r24, 0x01	; 1
    1e84:	78 2e       	mov	r7, r24
    1e86:	90 fe       	sbrs	r9, 0
    1e88:	03 c0       	rjmp	.+6      	; 0x1e90 <__EEPROM_REGION_LENGTH__+0xe90>
    // Jogging only uses the F feed rate and XYZ value words. N is valid, but S and T are invalid.
    bit_false(value_words,(bit(WORD_N)|bit(WORD_F)));
    1e8a:	9e ed       	ldi	r25, 0xDE	; 222
    1e8c:	a9 22       	and	r10, r25
    1e8e:	04 c0       	rjmp	.+8      	; 0x1e98 <__EEPROM_REGION_LENGTH__+0xe98>
  } else {
    bit_false(value_words,(bit(WORD_N)|bit(WORD_F)|bit(WORD_S)|bit(WORD_T))); // Remove single-meaning value words.
    1e90:	ae ed       	ldi	r26, 0xDE	; 222
    1e92:	aa 22       	and	r10, r26
    1e94:	ac ef       	ldi	r26, 0xFC	; 252
    1e96:	ba 22       	and	r11, r26
  }
  if (axis_command) { bit_false(value_words,(bit(WORD_X)|bit(WORD_Y)|bit(WORD_Z))); } // Remove axis words.
    1e98:	ba a1       	ldd	r27, Y+34	; 0x22
    1e9a:	bb 23       	and	r27, r27
    1e9c:	11 f0       	breq	.+4      	; 0x1ea2 <__EEPROM_REGION_LENGTH__+0xea2>
    1e9e:	e3 ee       	ldi	r30, 0xE3	; 227
    1ea0:	be 22       	and	r11, r30
  if (value_words) { FAIL(STATUS_GCODE_UNUSED_WORDS); } // [Unused words]
    1ea2:	ab 28       	or	r10, r11
    1ea4:	09 f0       	breq	.+2      	; 0x1ea8 <__EEPROM_REGION_LENGTH__+0xea8>
    1ea6:	c1 c2       	rjmp	.+1410   	; 0x242a <__stack+0x22b>
  */

  // Initialize planner data struct for motion blocks.
  plan_line_data_t plan_data;
  plan_line_data_t *pl_data = &plan_data;
  memset(pl_data,0,sizeof(plan_line_data_t)); // Zero pl_data struct
    1ea8:	fe 01       	movw	r30, r28
    1eaa:	72 96       	adiw	r30, 0x12	; 18
    1eac:	8d e0       	ldi	r24, 0x0D	; 13
    1eae:	df 01       	movw	r26, r30
    1eb0:	1d 92       	st	X+, r1
    1eb2:	8a 95       	dec	r24
    1eb4:	e9 f7       	brne	.-6      	; 0x1eb0 <__EEPROM_REGION_LENGTH__+0xeb0>

  // Intercept jog commands and complete error checking for valid jog commands and execute.
  // NOTE: G-code parser state is not updated, except the position to ensure sequential jog
  // targets are computed correctly. The final parser position after a jog is updated in
  // protocol_execute_realtime() when jogging completes or is canceled.
  if (gc_parser_flags & GC_PARSER_JOG_MOTION) {
    1eb6:	77 20       	and	r7, r7
    1eb8:	59 f1       	breq	.+86     	; 0x1f10 <__EEPROM_REGION_LENGTH__+0xf10>
    // Only distance and unit modal commands and G53 absolute override command are allowed.
    // NOTE: Feed rate word and axis word checks have already been performed in STEP 3.
    if (command_words & ~(bit(MODAL_GROUP_G3) | bit(MODAL_GROUP_G6 | bit(MODAL_GROUP_G0))) ) { FAIL(STATUS_INVALID_JOG_COMMAND) };
    1eba:	b6 eb       	ldi	r27, 0xB6	; 182
    1ebc:	eb 22       	and	r14, r27
    1ebe:	ef 28       	or	r14, r15
    1ec0:	09 f0       	breq	.+2      	; 0x1ec4 <__EEPROM_REGION_LENGTH__+0xec4>
    1ec2:	b5 c2       	rjmp	.+1386   	; 0x242e <__stack+0x22f>
    if (!(gc_block.non_modal_command == NON_MODAL_ABSOLUTE_OVERRIDE || gc_block.non_modal_command == NON_MODAL_NO_ACTION)) { FAIL(STATUS_INVALID_JOG_COMMAND); }
    1ec4:	80 91 7f 0c 	lds	r24, 0x0C7F	; 0x800c7f <gc_block>
    1ec8:	85 33       	cpi	r24, 0x35	; 53
    1eca:	11 f0       	breq	.+4      	; 0x1ed0 <__EEPROM_REGION_LENGTH__+0xed0>
    1ecc:	81 11       	cpse	r24, r1
    1ece:	b1 c2       	rjmp	.+1378   	; 0x2432 <__stack+0x233>

    // Initialize planner data to current spindle and coolant modal state.
    pl_data->spindle_speed = gc_state.spindle_speed;
    1ed0:	ef e3       	ldi	r30, 0x3F	; 63
    1ed2:	fc e0       	ldi	r31, 0x0C	; 12
    1ed4:	83 85       	ldd	r24, Z+11	; 0x0b
    1ed6:	94 85       	ldd	r25, Z+12	; 0x0c
    1ed8:	a5 85       	ldd	r26, Z+13	; 0x0d
    1eda:	b6 85       	ldd	r27, Z+14	; 0x0e
    1edc:	8e 8b       	std	Y+22, r24	; 0x16
    1ede:	9f 8b       	std	Y+23, r25	; 0x17
    1ee0:	a8 8f       	std	Y+24, r26	; 0x18
    1ee2:	b9 8f       	std	Y+25, r27	; 0x19
    plan_data.condition = (gc_state.modal.spindle | gc_state.modal.coolant);
    1ee4:	91 85       	ldd	r25, Z+9	; 0x09
    1ee6:	80 85       	ldd	r24, Z+8	; 0x08
    1ee8:	89 2b       	or	r24, r25
    1eea:	8e 8f       	std	Y+30, r24	; 0x1e

    uint8_t status = jog_execute(&plan_data, &gc_block);
    1eec:	6f e7       	ldi	r22, 0x7F	; 127
    1eee:	7c e0       	ldi	r23, 0x0C	; 12
    1ef0:	ce 01       	movw	r24, r28
    1ef2:	42 96       	adiw	r24, 0x12	; 18
    1ef4:	0e 94 f3 3b 	call	0x77e6	; 0x77e6 <jog_execute>
    if (status == STATUS_OK) { memcpy(gc_state.position, gc_block.values.xyz, sizeof(gc_block.values.xyz)); }
    1ef8:	81 11       	cpse	r24, r1
    1efa:	9e c2       	rjmp	.+1340   	; 0x2438 <__stack+0x239>
    1efc:	9c e0       	ldi	r25, 0x0C	; 12
    1efe:	ed ea       	ldi	r30, 0xAD	; 173
    1f00:	fc e0       	ldi	r31, 0x0C	; 12
    1f02:	a7 e5       	ldi	r26, 0x57	; 87
    1f04:	bc e0       	ldi	r27, 0x0C	; 12
    1f06:	01 90       	ld	r0, Z+
    1f08:	0d 92       	st	X+, r0
    1f0a:	9a 95       	dec	r25
    1f0c:	e1 f7       	brne	.-8      	; 0x1f06 <__EEPROM_REGION_LENGTH__+0xf06>
    1f0e:	94 c2       	rjmp	.+1320   	; 0x2438 <__stack+0x239>
    return(status);
  }
  
  // If in laser mode, setup laser power based on current and past parser conditions.
  if (bit_istrue(settings.flags,BITFLAG_LASER_MODE)) {
    1f10:	80 91 fe 0e 	lds	r24, 0x0EFE	; 0x800efe <settings+0x45>
    1f14:	81 ff       	sbrs	r24, 1
    1f16:	26 c0       	rjmp	.+76     	; 0x1f64 <__EEPROM_REGION_LENGTH__+0xf64>
    if ( !((gc_block.modal.motion == MOTION_MODE_LINEAR) || (gc_block.modal.motion == MOTION_MODE_CW_ARC) 
    1f18:	80 91 80 0c 	lds	r24, 0x0C80	; 0x800c80 <gc_block+0x1>
    1f1c:	81 50       	subi	r24, 0x01	; 1
    1f1e:	83 30       	cpi	r24, 0x03	; 3
    1f20:	18 f0       	brcs	.+6      	; 0x1f28 <__EEPROM_REGION_LENGTH__+0xf28>
        || (gc_block.modal.motion == MOTION_MODE_CCW_ARC)) ) {
      gc_parser_flags |= GC_PARSER_LASER_DISABLE;
    1f22:	e9 2d       	mov	r30, r9
    1f24:	e0 64       	ori	r30, 0x40	; 64
    1f26:	9e 2e       	mov	r9, r30
    }

    // Any motion mode with axis words is allowed to be passed from a spindle speed update. 
    // NOTE: G1 and G0 without axis words sets axis_command to none. G28/30 are intentionally omitted.
    // TODO: Check sync conditions for M3 enabled motions that don't enter the planner. (zero length).
    if (axis_words && (axis_command == AXIS_COMMAND_MOTION_MODE)) { 
    1f28:	f9 a1       	ldd	r31, Y+33	; 0x21
    1f2a:	ff 23       	and	r31, r31
    1f2c:	39 f0       	breq	.+14     	; 0x1f3c <__EEPROM_REGION_LENGTH__+0xf3c>
    1f2e:	2a a1       	ldd	r18, Y+34	; 0x22
    1f30:	22 30       	cpi	r18, 0x02	; 2
    1f32:	21 f4       	brne	.+8      	; 0x1f3c <__EEPROM_REGION_LENGTH__+0xf3c>
      gc_parser_flags |= GC_PARSER_LASER_ISMOTION; 
    1f34:	39 2d       	mov	r19, r9
    1f36:	30 68       	ori	r19, 0x80	; 128
    1f38:	93 2e       	mov	r9, r19
    1f3a:	14 c0       	rjmp	.+40     	; 0x1f64 <__EEPROM_REGION_LENGTH__+0xf64>
    } else {
      // M3 constant power laser requires planner syncs to update the laser when changing between
      // a G1/2/3 motion mode state and vice versa when there is no motion in the line.
      if (gc_state.modal.spindle == SPINDLE_ENABLE_CW) {
    1f3c:	80 91 48 0c 	lds	r24, 0x0C48	; 0x800c48 <gc_state+0x9>
    1f40:	80 31       	cpi	r24, 0x10	; 16
    1f42:	81 f4       	brne	.+32     	; 0x1f64 <__EEPROM_REGION_LENGTH__+0xf64>
        if ((gc_state.modal.motion == MOTION_MODE_LINEAR) || (gc_state.modal.motion == MOTION_MODE_CW_ARC) 
    1f44:	80 91 3f 0c 	lds	r24, 0x0C3F	; 0x800c3f <gc_state>
            || (gc_state.modal.motion == MOTION_MODE_CCW_ARC)) {
    1f48:	81 50       	subi	r24, 0x01	; 1
      gc_parser_flags |= GC_PARSER_LASER_ISMOTION; 
    } else {
      // M3 constant power laser requires planner syncs to update the laser when changing between
      // a G1/2/3 motion mode state and vice versa when there is no motion in the line.
      if (gc_state.modal.spindle == SPINDLE_ENABLE_CW) {
        if ((gc_state.modal.motion == MOTION_MODE_LINEAR) || (gc_state.modal.motion == MOTION_MODE_CW_ARC) 
    1f4a:	83 30       	cpi	r24, 0x03	; 3
    1f4c:	30 f4       	brcc	.+12     	; 0x1f5a <__EEPROM_REGION_LENGTH__+0xf5a>
            || (gc_state.modal.motion == MOTION_MODE_CCW_ARC)) {
          if (bit_istrue(gc_parser_flags,GC_PARSER_LASER_DISABLE)) { 
    1f4e:	96 fe       	sbrs	r9, 6
    1f50:	09 c0       	rjmp	.+18     	; 0x1f64 <__EEPROM_REGION_LENGTH__+0xf64>
            gc_parser_flags |= GC_PARSER_LASER_FORCE_SYNC; // Change from G1/2/3 motion mode.
    1f52:	49 2d       	mov	r20, r9
    1f54:	40 62       	ori	r20, 0x20	; 32
    1f56:	94 2e       	mov	r9, r20
    1f58:	05 c0       	rjmp	.+10     	; 0x1f64 <__EEPROM_REGION_LENGTH__+0xf64>
          }
        } else {
          // When changing to a G1 motion mode without axis words from a non-G1/2/3 motion mode.
          if (bit_isfalse(gc_parser_flags,GC_PARSER_LASER_DISABLE)) { 
    1f5a:	96 fc       	sbrc	r9, 6
    1f5c:	03 c0       	rjmp	.+6      	; 0x1f64 <__EEPROM_REGION_LENGTH__+0xf64>
            gc_parser_flags |= GC_PARSER_LASER_FORCE_SYNC;
    1f5e:	59 2d       	mov	r21, r9
    1f60:	50 62       	ori	r21, 0x20	; 32
    1f62:	95 2e       	mov	r9, r21
    }
  }

  // [0. Non-specific/common error-checks and miscellaneous setup]:
  // NOTE: If no line number is present, the value is zero.
  gc_state.line_number = gc_block.values.n;
    1f64:	af e7       	ldi	r26, 0x7F	; 127
    1f66:	bc e0       	ldi	r27, 0x0C	; 12
    1f68:	5d 96       	adiw	r26, 0x1d	; 29
    1f6a:	4d 91       	ld	r20, X+
    1f6c:	5d 91       	ld	r21, X+
    1f6e:	6d 91       	ld	r22, X+
    1f70:	7c 91       	ld	r23, X
    1f72:	90 97       	sbiw	r26, 0x20	; 32
    1f74:	ef e3       	ldi	r30, 0x3F	; 63
    1f76:	fc e0       	ldi	r31, 0x0C	; 12
    1f78:	44 8b       	std	Z+20, r20	; 0x14
    1f7a:	55 8b       	std	Z+21, r21	; 0x15
    1f7c:	66 8b       	std	Z+22, r22	; 0x16
    1f7e:	77 8b       	std	Z+23, r23	; 0x17
  pl_data->line_number = gc_state.line_number; // Record data for planner use.
    1f80:	4a 8f       	std	Y+26, r20	; 0x1a
    1f82:	5b 8f       	std	Y+27, r21	; 0x1b
    1f84:	6c 8f       	std	Y+28, r22	; 0x1c
    1f86:	7d 8f       	std	Y+29, r23	; 0x1d

  // [1. Comments feedback ]:  NOT SUPPORTED

  // [2. Set feed rate mode ]:
  gc_state.modal.feed_rate = gc_block.modal.feed_rate;
    1f88:	12 96       	adiw	r26, 0x02	; 2
    1f8a:	8c 91       	ld	r24, X
    1f8c:	81 83       	std	Z+1, r24	; 0x01
  if (gc_state.modal.feed_rate) { pl_data->condition |= PL_COND_FLAG_INVERSE_TIME; } // Set condition flag for planner use.
    1f8e:	88 23       	and	r24, r24
    1f90:	11 f0       	breq	.+4      	; 0x1f96 <__EEPROM_REGION_LENGTH__+0xf96>
    1f92:	88 e0       	ldi	r24, 0x08	; 8
    1f94:	8e 8f       	std	Y+30, r24	; 0x1e

  // [3. Set feed rate ]:
  gc_state.feed_rate = gc_block.values.f; // Always copy this value. See feed rate error-checking.
    1f96:	ef e7       	ldi	r30, 0x7F	; 127
    1f98:	fc e0       	ldi	r31, 0x0C	; 12
    1f9a:	44 85       	ldd	r20, Z+12	; 0x0c
    1f9c:	55 85       	ldd	r21, Z+13	; 0x0d
    1f9e:	66 85       	ldd	r22, Z+14	; 0x0e
    1fa0:	77 85       	ldd	r23, Z+15	; 0x0f
    1fa2:	af e3       	ldi	r26, 0x3F	; 63
    1fa4:	bc e0       	ldi	r27, 0x0C	; 12
    1fa6:	1f 96       	adiw	r26, 0x0f	; 15
    1fa8:	4d 93       	st	X+, r20
    1faa:	5d 93       	st	X+, r21
    1fac:	6d 93       	st	X+, r22
    1fae:	7c 93       	st	X, r23
    1fb0:	52 97       	sbiw	r26, 0x12	; 18
  pl_data->feed_rate = gc_state.feed_rate; // Record data for planner use.
    1fb2:	4a 8b       	std	Y+18, r20	; 0x12
    1fb4:	5b 8b       	std	Y+19, r21	; 0x13
    1fb6:	6c 8b       	std	Y+20, r22	; 0x14
    1fb8:	7d 8b       	std	Y+21, r23	; 0x15

  // [4. Set spindle speed ]:
  if ((gc_state.spindle_speed != gc_block.values.s) || bit_istrue(gc_parser_flags,GC_PARSER_LASER_FORCE_SYNC)) {
    1fba:	1b 96       	adiw	r26, 0x0b	; 11
    1fbc:	6d 91       	ld	r22, X+
    1fbe:	7d 91       	ld	r23, X+
    1fc0:	8d 91       	ld	r24, X+
    1fc2:	9c 91       	ld	r25, X
    1fc4:	1e 97       	sbiw	r26, 0x0e	; 14
    1fc6:	c1 a4       	ldd	r12, Z+41	; 0x29
    1fc8:	d2 a4       	ldd	r13, Z+42	; 0x2a
    1fca:	e3 a4       	ldd	r14, Z+43	; 0x2b
    1fcc:	f4 a4       	ldd	r15, Z+44	; 0x2c
    1fce:	a7 01       	movw	r20, r14
    1fd0:	96 01       	movw	r18, r12
    1fd2:	0e 94 0e 3d 	call	0x7a1c	; 0x7a1c <__cmpsf2>
    1fd6:	81 11       	cpse	r24, r1
    1fd8:	02 c0       	rjmp	.+4      	; 0x1fde <__EEPROM_REGION_LENGTH__+0xfde>
    1fda:	95 fe       	sbrs	r9, 5
    1fdc:	20 c0       	rjmp	.+64     	; 0x201e <__DATA_REGION_LENGTH__+0x1e>
    if (gc_state.modal.spindle != SPINDLE_DISABLE) { 
    1fde:	80 91 48 0c 	lds	r24, 0x0C48	; 0x800c48 <gc_state+0x9>
    1fe2:	88 23       	and	r24, r24
    1fe4:	61 f0       	breq	.+24     	; 0x1ffe <__EEPROM_REGION_LENGTH__+0xffe>
      if (bit_isfalse(gc_parser_flags,GC_PARSER_LASER_ISMOTION)) {
    1fe6:	99 20       	and	r9, r9
    1fe8:	54 f0       	brlt	.+20     	; 0x1ffe <__EEPROM_REGION_LENGTH__+0xffe>
        if (bit_istrue(gc_parser_flags,GC_PARSER_LASER_DISABLE)) {
    1fea:	96 fe       	sbrs	r9, 6
    1fec:	05 c0       	rjmp	.+10     	; 0x1ff8 <__EEPROM_REGION_LENGTH__+0xff8>
           spindle_sync(gc_state.modal.spindle, 0.0);
    1fee:	40 e0       	ldi	r20, 0x00	; 0
    1ff0:	50 e0       	ldi	r21, 0x00	; 0
    1ff2:	ba 01       	movw	r22, r20
    1ff4:	75 d3       	rcall	.+1770   	; 0x26e0 <spindle_sync>
    1ff6:	03 c0       	rjmp	.+6      	; 0x1ffe <__EEPROM_REGION_LENGTH__+0xffe>
        } else { spindle_sync(gc_state.modal.spindle, gc_block.values.s); }
    1ff8:	b7 01       	movw	r22, r14
    1ffa:	a6 01       	movw	r20, r12
    1ffc:	71 d3       	rcall	.+1762   	; 0x26e0 <spindle_sync>
      }
    }
    gc_state.spindle_speed = gc_block.values.s; // Update spindle speed state.
    1ffe:	80 91 a8 0c 	lds	r24, 0x0CA8	; 0x800ca8 <gc_block+0x29>
    2002:	90 91 a9 0c 	lds	r25, 0x0CA9	; 0x800ca9 <gc_block+0x2a>
    2006:	a0 91 aa 0c 	lds	r26, 0x0CAA	; 0x800caa <gc_block+0x2b>
    200a:	b0 91 ab 0c 	lds	r27, 0x0CAB	; 0x800cab <gc_block+0x2c>
    200e:	80 93 4a 0c 	sts	0x0C4A, r24	; 0x800c4a <gc_state+0xb>
    2012:	90 93 4b 0c 	sts	0x0C4B, r25	; 0x800c4b <gc_state+0xc>
    2016:	a0 93 4c 0c 	sts	0x0C4C, r26	; 0x800c4c <gc_state+0xd>
    201a:	b0 93 4d 0c 	sts	0x0C4D, r27	; 0x800c4d <gc_state+0xe>
  }
  // NOTE: Pass zero spindle speed for all restricted laser motions.
  if (bit_isfalse(gc_parser_flags,GC_PARSER_LASER_DISABLE)) {
    201e:	96 fc       	sbrc	r9, 6
    2020:	0c c0       	rjmp	.+24     	; 0x203a <__DATA_REGION_LENGTH__+0x3a>
    pl_data->spindle_speed = gc_state.spindle_speed; // Record data for planner use. 
    2022:	80 91 4a 0c 	lds	r24, 0x0C4A	; 0x800c4a <gc_state+0xb>
    2026:	90 91 4b 0c 	lds	r25, 0x0C4B	; 0x800c4b <gc_state+0xc>
    202a:	a0 91 4c 0c 	lds	r26, 0x0C4C	; 0x800c4c <gc_state+0xd>
    202e:	b0 91 4d 0c 	lds	r27, 0x0C4D	; 0x800c4d <gc_state+0xe>
    2032:	8e 8b       	std	Y+22, r24	; 0x16
    2034:	9f 8b       	std	Y+23, r25	; 0x17
    2036:	a8 8f       	std	Y+24, r26	; 0x18
    2038:	b9 8f       	std	Y+25, r27	; 0x19
  } // else { pl_data->spindle_speed = 0.0; } // Initialized as zero already.
  
  // [5. Select tool ]: NOT SUPPORTED. Only tracks tool value.
  gc_state.tool = gc_block.values.t;
    203a:	ef e7       	ldi	r30, 0x7F	; 127
    203c:	fc e0       	ldi	r31, 0x0C	; 12
    203e:	85 a5       	ldd	r24, Z+45	; 0x2d
    2040:	af e3       	ldi	r26, 0x3F	; 63
    2042:	bc e0       	ldi	r27, 0x0C	; 12
    2044:	53 96       	adiw	r26, 0x13	; 19
    2046:	8c 93       	st	X, r24
    2048:	53 97       	sbiw	r26, 0x13	; 19

  // [6. Change tool ]: NOT SUPPORTED

  // [7. Spindle control ]:
  if (gc_state.modal.spindle != gc_block.modal.spindle) {
    204a:	19 96       	adiw	r26, 0x09	; 9
    204c:	9c 91       	ld	r25, X
    204e:	82 85       	ldd	r24, Z+10	; 0x0a
    2050:	98 17       	cp	r25, r24
    2052:	49 f0       	breq	.+18     	; 0x2066 <__DATA_REGION_LENGTH__+0x66>
    // Update spindle control and apply spindle speed when enabling it in this block.
    // NOTE: All spindle state changes are synced, even in laser mode. Also, pl_data,
    // rather than gc_state, is used to manage laser state for non-laser motions.
    spindle_sync(gc_block.modal.spindle, pl_data->spindle_speed);
    2054:	4e 89       	ldd	r20, Y+22	; 0x16
    2056:	5f 89       	ldd	r21, Y+23	; 0x17
    2058:	68 8d       	ldd	r22, Y+24	; 0x18
    205a:	79 8d       	ldd	r23, Y+25	; 0x19
    205c:	41 d3       	rcall	.+1666   	; 0x26e0 <spindle_sync>
    gc_state.modal.spindle = gc_block.modal.spindle;
    205e:	80 91 89 0c 	lds	r24, 0x0C89	; 0x800c89 <gc_block+0xa>
    2062:	80 93 48 0c 	sts	0x0C48, r24	; 0x800c48 <gc_state+0x9>
  }
  pl_data->condition |= gc_state.modal.spindle; // Set condition flag for planner use.
    2066:	ef e3       	ldi	r30, 0x3F	; 63
    2068:	fc e0       	ldi	r31, 0x0C	; 12
    206a:	81 85       	ldd	r24, Z+9	; 0x09
    206c:	9e 8d       	ldd	r25, Y+30	; 0x1e
    206e:	89 2b       	or	r24, r25
    2070:	8e 8f       	std	Y+30, r24	; 0x1e

  // [8. Coolant control ]:
  if (gc_state.modal.coolant != gc_block.modal.coolant) {
    2072:	90 85       	ldd	r25, Z+8	; 0x08
    2074:	80 91 88 0c 	lds	r24, 0x0C88	; 0x800c88 <gc_block+0x9>
    2078:	98 17       	cp	r25, r24
    // NOTE: Coolant M-codes are modal. Only one command per line is allowed. But, multiple states
    // can exist at the same time, while coolant disable clears all states.
    coolant_sync(gc_block.modal.coolant);
    207a:	29 f0       	breq	.+10     	; 0x2086 <__DATA_REGION_LENGTH__+0x86>
    207c:	88 d3       	rcall	.+1808   	; 0x278e <coolant_sync>
    gc_state.modal.coolant = gc_block.modal.coolant;
    207e:	80 91 88 0c 	lds	r24, 0x0C88	; 0x800c88 <gc_block+0x9>
    2082:	80 93 47 0c 	sts	0x0C47, r24	; 0x800c47 <gc_state+0x8>
  }
  pl_data->condition |= gc_state.modal.coolant; // Set condition flag for planner use.
    2086:	80 91 47 0c 	lds	r24, 0x0C47	; 0x800c47 <gc_state+0x8>
    208a:	9e 8d       	ldd	r25, Y+30	; 0x1e
    208c:	89 2b       	or	r24, r25
    208e:	8e 8f       	std	Y+30, r24	; 0x1e
      mc_override_ctrl_update(gc_state.modal.override);
    }
  #endif

  // [10. Dwell ]:
  if (gc_block.non_modal_command == NON_MODAL_DWELL) { mc_dwell(gc_block.values.p); }
    2090:	80 91 7f 0c 	lds	r24, 0x0C7F	; 0x800c7f <gc_block>
    2094:	84 30       	cpi	r24, 0x04	; 4
    2096:	51 f4       	brne	.+20     	; 0x20ac <__DATA_REGION_LENGTH__+0xac>
    2098:	60 91 a0 0c 	lds	r22, 0x0CA0	; 0x800ca0 <gc_block+0x21>
    209c:	70 91 a1 0c 	lds	r23, 0x0CA1	; 0x800ca1 <gc_block+0x22>
    20a0:	80 91 a2 0c 	lds	r24, 0x0CA2	; 0x800ca2 <gc_block+0x23>
    20a4:	90 91 a3 0c 	lds	r25, 0x0CA3	; 0x800ca3 <gc_block+0x24>
    20a8:	0e 94 0c 06 	call	0xc18	; 0xc18 <mc_dwell>

  // [11. Set active plane ]:
  gc_state.modal.plane_select = gc_block.modal.plane_select;
    20ac:	af e7       	ldi	r26, 0x7F	; 127
    20ae:	bc e0       	ldi	r27, 0x0C	; 12
    20b0:	15 96       	adiw	r26, 0x05	; 5
    20b2:	8c 91       	ld	r24, X
    20b4:	15 97       	sbiw	r26, 0x05	; 5
    20b6:	ef e3       	ldi	r30, 0x3F	; 63
    20b8:	fc e0       	ldi	r31, 0x0C	; 12
    20ba:	84 83       	std	Z+4, r24	; 0x04

  // [12. Set length units ]:
  gc_state.modal.units = gc_block.modal.units;
    20bc:	13 96       	adiw	r26, 0x03	; 3
    20be:	8c 91       	ld	r24, X
    20c0:	82 83       	std	Z+2, r24	; 0x02

  // [14. Cutter length compensation ]: G43.1 and G49 supported. G43 NOT SUPPORTED.
  // NOTE: If G43 were supported, its operation wouldn't be any different from G43.1 in terms
  // of execution. The error-checking step would simply load the offset value into the correct
  // axis of the block XYZ value array.
  if (axis_command == AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // Indicates a change.
    20c2:	8a a1       	ldd	r24, Y+34	; 0x22
    20c4:	83 30       	cpi	r24, 0x03	; 3
    20c6:	71 f5       	brne	.+92     	; 0x2124 <__DATA_REGION_LENGTH__+0x124>
    gc_state.modal.tool_length = gc_block.modal.tool_length;
    20c8:	80 91 85 0c 	lds	r24, 0x0C85	; 0x800c85 <gc_block+0x6>
    20cc:	80 93 44 0c 	sts	0x0C44, r24	; 0x800c44 <gc_state+0x5>
    if (gc_state.modal.tool_length == TOOL_LENGTH_OFFSET_CANCEL) { // G49
    20d0:	81 11       	cpse	r24, r1
    20d2:	08 c0       	rjmp	.+16     	; 0x20e4 <__DATA_REGION_LENGTH__+0xe4>
      gc_block.values.xyz[TOOL_LENGTH_OFFSET_AXIS] = 0.0;
    20d4:	10 92 b5 0c 	sts	0x0CB5, r1	; 0x800cb5 <gc_block+0x36>
    20d8:	10 92 b6 0c 	sts	0x0CB6, r1	; 0x800cb6 <gc_block+0x37>
    20dc:	10 92 b7 0c 	sts	0x0CB7, r1	; 0x800cb7 <gc_block+0x38>
    20e0:	10 92 b8 0c 	sts	0x0CB8, r1	; 0x800cb8 <gc_block+0x39>
    } // else G43.1
    if ( gc_state.tool_length_offset != gc_block.values.xyz[TOOL_LENGTH_OFFSET_AXIS] ) {
    20e4:	60 91 7b 0c 	lds	r22, 0x0C7B	; 0x800c7b <gc_state+0x3c>
    20e8:	70 91 7c 0c 	lds	r23, 0x0C7C	; 0x800c7c <gc_state+0x3d>
    20ec:	80 91 7d 0c 	lds	r24, 0x0C7D	; 0x800c7d <gc_state+0x3e>
    20f0:	90 91 7e 0c 	lds	r25, 0x0C7E	; 0x800c7e <gc_state+0x3f>
    20f4:	c0 90 b5 0c 	lds	r12, 0x0CB5	; 0x800cb5 <gc_block+0x36>
    20f8:	d0 90 b6 0c 	lds	r13, 0x0CB6	; 0x800cb6 <gc_block+0x37>
    20fc:	e0 90 b7 0c 	lds	r14, 0x0CB7	; 0x800cb7 <gc_block+0x38>
    2100:	f0 90 b8 0c 	lds	r15, 0x0CB8	; 0x800cb8 <gc_block+0x39>
    2104:	a7 01       	movw	r20, r14
    2106:	96 01       	movw	r18, r12
    2108:	0e 94 0e 3d 	call	0x7a1c	; 0x7a1c <__cmpsf2>
    210c:	88 23       	and	r24, r24
    210e:	51 f0       	breq	.+20     	; 0x2124 <__DATA_REGION_LENGTH__+0x124>
      gc_state.tool_length_offset = gc_block.values.xyz[TOOL_LENGTH_OFFSET_AXIS];
    2110:	c0 92 7b 0c 	sts	0x0C7B, r12	; 0x800c7b <gc_state+0x3c>
    2114:	d0 92 7c 0c 	sts	0x0C7C, r13	; 0x800c7c <gc_state+0x3d>
    2118:	e0 92 7d 0c 	sts	0x0C7D, r14	; 0x800c7d <gc_state+0x3e>
    211c:	f0 92 7e 0c 	sts	0x0C7E, r15	; 0x800c7e <gc_state+0x3f>
      system_flag_wco_change();
    2120:	0e 94 c7 38 	call	0x718e	; 0x718e <system_flag_wco_change>
    }
  }

  // [15. Coordinate system selection ]:
  if (gc_state.modal.coord_select != gc_block.modal.coord_select) {
    2124:	90 91 45 0c 	lds	r25, 0x0C45	; 0x800c45 <gc_state+0x6>
    2128:	80 91 86 0c 	lds	r24, 0x0C86	; 0x800c86 <gc_block+0x7>
    212c:	98 17       	cp	r25, r24
    212e:	69 f0       	breq	.+26     	; 0x214a <__DATA_REGION_LENGTH__+0x14a>
    gc_state.modal.coord_select = gc_block.modal.coord_select;
    2130:	80 93 45 0c 	sts	0x0C45, r24	; 0x800c45 <gc_state+0x6>
    memcpy(gc_state.coord_system,block_coord_system,N_AXIS*sizeof(float));
    2134:	8c e0       	ldi	r24, 0x0C	; 12
    2136:	fe 01       	movw	r30, r28
    2138:	36 96       	adiw	r30, 0x06	; 6
    213a:	a3 e6       	ldi	r26, 0x63	; 99
    213c:	bc e0       	ldi	r27, 0x0C	; 12
    213e:	01 90       	ld	r0, Z+
    2140:	0d 92       	st	X+, r0
    2142:	8a 95       	dec	r24
    2144:	e1 f7       	brne	.-8      	; 0x213e <__DATA_REGION_LENGTH__+0x13e>
    system_flag_wco_change();
    2146:	0e 94 c7 38 	call	0x718e	; 0x718e <system_flag_wco_change>

  // [16. Set path control mode ]: G61.1/G64 NOT SUPPORTED
  // gc_state.modal.control = gc_block.modal.control; // NOTE: Always default.

  // [17. Set distance mode ]:
  gc_state.modal.distance = gc_block.modal.distance;
    214a:	ef e7       	ldi	r30, 0x7F	; 127
    214c:	fc e0       	ldi	r31, 0x0C	; 12
    214e:	84 81       	ldd	r24, Z+4	; 0x04
    2150:	80 93 42 0c 	sts	0x0C42, r24	; 0x800c42 <gc_state+0x3>

  // [18. Set retract mode ]: NOT SUPPORTED

  // [19. Go to predefined position, Set G10, or Set axis offsets ]:
  switch(gc_block.non_modal_command) {
    2154:	80 81       	ld	r24, Z
    2156:	86 32       	cpi	r24, 0x26	; 38
    2158:	09 f4       	brne	.+2      	; 0x215c <__DATA_REGION_LENGTH__+0x15c>
    215a:	45 c0       	rjmp	.+138    	; 0x21e6 <__DATA_REGION_LENGTH__+0x1e6>
    215c:	38 f4       	brcc	.+14     	; 0x216c <__DATA_REGION_LENGTH__+0x16c>
    215e:	8c 31       	cpi	r24, 0x1C	; 28
    2160:	21 f1       	breq	.+72     	; 0x21aa <__DATA_REGION_LENGTH__+0x1aa>
    2162:	8e 31       	cpi	r24, 0x1E	; 30
    2164:	11 f1       	breq	.+68     	; 0x21aa <__DATA_REGION_LENGTH__+0x1aa>
    2166:	8a 30       	cpi	r24, 0x0A	; 10
    2168:	59 f0       	breq	.+22     	; 0x2180 <__DATA_REGION_LENGTH__+0x180>
    216a:	5e c0       	rjmp	.+188    	; 0x2228 <__stack+0x29>
    216c:	8c 35       	cpi	r24, 0x5C	; 92
    216e:	09 f4       	brne	.+2      	; 0x2172 <__DATA_REGION_LENGTH__+0x172>
    2170:	46 c0       	rjmp	.+140    	; 0x21fe <__DATA_REGION_LENGTH__+0x1fe>
    2172:	86 36       	cpi	r24, 0x66	; 102
    2174:	09 f4       	brne	.+2      	; 0x2178 <__DATA_REGION_LENGTH__+0x178>
    2176:	4f c0       	rjmp	.+158    	; 0x2216 <__stack+0x17>
    2178:	88 32       	cpi	r24, 0x28	; 40
    217a:	09 f0       	breq	.+2      	; 0x217e <__DATA_REGION_LENGTH__+0x17e>
    217c:	55 c0       	rjmp	.+170    	; 0x2228 <__stack+0x29>
    217e:	39 c0       	rjmp	.+114    	; 0x21f2 <__DATA_REGION_LENGTH__+0x1f2>
    case NON_MODAL_SET_COORDINATE_DATA:
      settings_write_coord_data(coord_select,gc_block.values.ijk);
    2180:	6f e8       	ldi	r22, 0x8F	; 143
    2182:	7c e0       	ldi	r23, 0x0C	; 12
    2184:	85 2d       	mov	r24, r5
    2186:	0e 94 74 24 	call	0x48e8	; 0x48e8 <settings_write_coord_data>
      // Update system coordinate system if currently active.
      if (gc_state.modal.coord_select == coord_select) {
    218a:	80 91 45 0c 	lds	r24, 0x0C45	; 0x800c45 <gc_state+0x6>
    218e:	58 12       	cpse	r5, r24
    2190:	4b c0       	rjmp	.+150    	; 0x2228 <__stack+0x29>
        memcpy(gc_state.coord_system,gc_block.values.ijk,N_AXIS*sizeof(float));
    2192:	8c e0       	ldi	r24, 0x0C	; 12
    2194:	ef e8       	ldi	r30, 0x8F	; 143
    2196:	fc e0       	ldi	r31, 0x0C	; 12
    2198:	a3 e6       	ldi	r26, 0x63	; 99
    219a:	bc e0       	ldi	r27, 0x0C	; 12
    219c:	01 90       	ld	r0, Z+
    219e:	0d 92       	st	X+, r0
    21a0:	8a 95       	dec	r24
    21a2:	e1 f7       	brne	.-8      	; 0x219c <__DATA_REGION_LENGTH__+0x19c>
        system_flag_wco_change();
    21a4:	0e 94 c7 38 	call	0x718e	; 0x718e <system_flag_wco_change>
    21a8:	3f c0       	rjmp	.+126    	; 0x2228 <__stack+0x29>
      }
      break;
    case NON_MODAL_GO_HOME_0: case NON_MODAL_GO_HOME_1:
      // Move to intermediate position before going home. Obeys current coordinate system and offsets
      // and absolute and incremental modes.
      pl_data->condition |= PL_COND_FLAG_RAPID_MOTION; // Set rapid motion condition flag.
    21aa:	8e 8d       	ldd	r24, Y+30	; 0x1e
    21ac:	81 60       	ori	r24, 0x01	; 1
    21ae:	8e 8f       	std	Y+30, r24	; 0x1e
      if (axis_command) { mc_line(gc_block.values.xyz, pl_data); }
    21b0:	9a a1       	ldd	r25, Y+34	; 0x22
    21b2:	99 23       	and	r25, r25
    21b4:	39 f0       	breq	.+14     	; 0x21c4 <__DATA_REGION_LENGTH__+0x1c4>
    21b6:	be 01       	movw	r22, r28
    21b8:	6e 5e       	subi	r22, 0xEE	; 238
    21ba:	7f 4f       	sbci	r23, 0xFF	; 255
    21bc:	8d ea       	ldi	r24, 0xAD	; 173
    21be:	9c e0       	ldi	r25, 0x0C	; 12
    21c0:	0e 94 ec 02 	call	0x5d8	; 0x5d8 <mc_line>
      mc_line(gc_block.values.ijk, pl_data);
    21c4:	be 01       	movw	r22, r28
    21c6:	6e 5e       	subi	r22, 0xEE	; 238
    21c8:	7f 4f       	sbci	r23, 0xFF	; 255
    21ca:	8f e8       	ldi	r24, 0x8F	; 143
    21cc:	9c e0       	ldi	r25, 0x0C	; 12
    21ce:	0e 94 ec 02 	call	0x5d8	; 0x5d8 <mc_line>
      memcpy(gc_state.position, gc_block.values.ijk, N_AXIS*sizeof(float));
    21d2:	8c e0       	ldi	r24, 0x0C	; 12
    21d4:	ef e8       	ldi	r30, 0x8F	; 143
    21d6:	fc e0       	ldi	r31, 0x0C	; 12
    21d8:	a7 e5       	ldi	r26, 0x57	; 87
    21da:	bc e0       	ldi	r27, 0x0C	; 12
    21dc:	01 90       	ld	r0, Z+
    21de:	0d 92       	st	X+, r0
    21e0:	8a 95       	dec	r24
    21e2:	e1 f7       	brne	.-8      	; 0x21dc <__DATA_REGION_LENGTH__+0x1dc>
      break;
    21e4:	21 c0       	rjmp	.+66     	; 0x2228 <__stack+0x29>
    case NON_MODAL_SET_HOME_0:
      settings_write_coord_data(SETTING_INDEX_G28,gc_state.position);
    21e6:	67 e5       	ldi	r22, 0x57	; 87
    21e8:	7c e0       	ldi	r23, 0x0C	; 12
    21ea:	86 e0       	ldi	r24, 0x06	; 6
    21ec:	0e 94 74 24 	call	0x48e8	; 0x48e8 <settings_write_coord_data>
      break;
    21f0:	1b c0       	rjmp	.+54     	; 0x2228 <__stack+0x29>
    case NON_MODAL_SET_HOME_1:
      settings_write_coord_data(SETTING_INDEX_G30,gc_state.position);
    21f2:	67 e5       	ldi	r22, 0x57	; 87
    21f4:	7c e0       	ldi	r23, 0x0C	; 12
    21f6:	87 e0       	ldi	r24, 0x07	; 7
    21f8:	0e 94 74 24 	call	0x48e8	; 0x48e8 <settings_write_coord_data>
      break;
    21fc:	15 c0       	rjmp	.+42     	; 0x2228 <__stack+0x29>
    case NON_MODAL_SET_COORDINATE_OFFSET:
      memcpy(gc_state.coord_offset,gc_block.values.xyz,sizeof(gc_block.values.xyz));
    21fe:	8c e0       	ldi	r24, 0x0C	; 12
    2200:	ed ea       	ldi	r30, 0xAD	; 173
    2202:	fc e0       	ldi	r31, 0x0C	; 12
    2204:	af e6       	ldi	r26, 0x6F	; 111
    2206:	bc e0       	ldi	r27, 0x0C	; 12
    2208:	01 90       	ld	r0, Z+
    220a:	0d 92       	st	X+, r0
    220c:	8a 95       	dec	r24
    220e:	e1 f7       	brne	.-8      	; 0x2208 <__stack+0x9>
      system_flag_wco_change();
    2210:	0e 94 c7 38 	call	0x718e	; 0x718e <system_flag_wco_change>
      break;
    2214:	09 c0       	rjmp	.+18     	; 0x2228 <__stack+0x29>
    case NON_MODAL_RESET_COORDINATE_OFFSET:
      clear_vector(gc_state.coord_offset); // Disable G92 offsets by zeroing offset vector.
    2216:	8c e0       	ldi	r24, 0x0C	; 12
    2218:	ef e6       	ldi	r30, 0x6F	; 111
    221a:	fc e0       	ldi	r31, 0x0C	; 12
    221c:	df 01       	movw	r26, r30
    221e:	1d 92       	st	X+, r1
    2220:	8a 95       	dec	r24
    2222:	e9 f7       	brne	.-6      	; 0x221e <__stack+0x1f>
      system_flag_wco_change();
    2224:	0e 94 c7 38 	call	0x718e	; 0x718e <system_flag_wco_change>


  // [20. Motion modes ]:
  // NOTE: Commands G10,G28,G30,G92 lock out and prevent axis words from use in motion modes.
  // Enter motion modes only if there are axis words or a motion mode command word in the block.
  gc_state.modal.motion = gc_block.modal.motion;
    2228:	80 91 80 0c 	lds	r24, 0x0C80	; 0x800c80 <gc_block+0x1>
    222c:	80 93 3f 0c 	sts	0x0C3F, r24	; 0x800c3f <gc_state>
  if (gc_state.modal.motion != MOTION_MODE_NONE) {
    2230:	80 35       	cpi	r24, 0x50	; 80
    2232:	09 f4       	brne	.+2      	; 0x2236 <__stack+0x37>
    2234:	58 c0       	rjmp	.+176    	; 0x22e6 <__stack+0xe7>
    if (axis_command == AXIS_COMMAND_MOTION_MODE) {
    2236:	ba a1       	ldd	r27, Y+34	; 0x22
    2238:	b2 30       	cpi	r27, 0x02	; 2
    223a:	09 f0       	breq	.+2      	; 0x223e <__stack+0x3f>
    223c:	54 c0       	rjmp	.+168    	; 0x22e6 <__stack+0xe7>
      uint8_t gc_update_pos = GC_UPDATE_POS_TARGET;
      if (gc_state.modal.motion == MOTION_MODE_LINEAR) {
    223e:	81 30       	cpi	r24, 0x01	; 1
    2240:	49 f4       	brne	.+18     	; 0x2254 <__stack+0x55>
        mc_line(gc_block.values.xyz, pl_data);
    2242:	be 01       	movw	r22, r28
    2244:	6e 5e       	subi	r22, 0xEE	; 238
    2246:	7f 4f       	sbci	r23, 0xFF	; 255
    2248:	8d ea       	ldi	r24, 0xAD	; 173
    224a:	9c e0       	ldi	r25, 0x0C	; 12
    224c:	0e 94 ec 02 	call	0x5d8	; 0x5d8 <mc_line>
  // NOTE: Commands G10,G28,G30,G92 lock out and prevent axis words from use in motion modes.
  // Enter motion modes only if there are axis words or a motion mode command word in the block.
  gc_state.modal.motion = gc_block.modal.motion;
  if (gc_state.modal.motion != MOTION_MODE_NONE) {
    if (axis_command == AXIS_COMMAND_MOTION_MODE) {
      uint8_t gc_update_pos = GC_UPDATE_POS_TARGET;
    2250:	80 e0       	ldi	r24, 0x00	; 0
    2252:	39 c0       	rjmp	.+114    	; 0x22c6 <__stack+0xc7>
      if (gc_state.modal.motion == MOTION_MODE_LINEAR) {
        mc_line(gc_block.values.xyz, pl_data);
      } else if (gc_state.modal.motion == MOTION_MODE_SEEK) {
    2254:	81 11       	cpse	r24, r1
    2256:	0c c0       	rjmp	.+24     	; 0x2270 <__stack+0x71>
        pl_data->condition |= PL_COND_FLAG_RAPID_MOTION; // Set rapid motion condition flag.
    2258:	8e 8d       	ldd	r24, Y+30	; 0x1e
    225a:	81 60       	ori	r24, 0x01	; 1
    225c:	8e 8f       	std	Y+30, r24	; 0x1e
        mc_line(gc_block.values.xyz, pl_data);
    225e:	be 01       	movw	r22, r28
    2260:	6e 5e       	subi	r22, 0xEE	; 238
    2262:	7f 4f       	sbci	r23, 0xFF	; 255
    2264:	8d ea       	ldi	r24, 0xAD	; 173
    2266:	9c e0       	ldi	r25, 0x0C	; 12
    2268:	0e 94 ec 02 	call	0x5d8	; 0x5d8 <mc_line>
  // NOTE: Commands G10,G28,G30,G92 lock out and prevent axis words from use in motion modes.
  // Enter motion modes only if there are axis words or a motion mode command word in the block.
  gc_state.modal.motion = gc_block.modal.motion;
  if (gc_state.modal.motion != MOTION_MODE_NONE) {
    if (axis_command == AXIS_COMMAND_MOTION_MODE) {
      uint8_t gc_update_pos = GC_UPDATE_POS_TARGET;
    226c:	80 e0       	ldi	r24, 0x00	; 0
    226e:	2b c0       	rjmp	.+86     	; 0x22c6 <__stack+0xc7>
      if (gc_state.modal.motion == MOTION_MODE_LINEAR) {
        mc_line(gc_block.values.xyz, pl_data);
      } else if (gc_state.modal.motion == MOTION_MODE_SEEK) {
        pl_data->condition |= PL_COND_FLAG_RAPID_MOTION; // Set rapid motion condition flag.
        mc_line(gc_block.values.xyz, pl_data);
      } else if ((gc_state.modal.motion == MOTION_MODE_CW_ARC) || (gc_state.modal.motion == MOTION_MODE_CCW_ARC)) {
    2270:	82 50       	subi	r24, 0x02	; 2
    2272:	82 30       	cpi	r24, 0x02	; 2
    2274:	e8 f4       	brcc	.+58     	; 0x22b0 <__stack+0xb1>
        mc_arc(gc_block.values.xyz, pl_data, gc_state.position, gc_block.values.ijk, gc_block.values.r,
    2276:	e0 90 a4 0c 	lds	r14, 0x0CA4	; 0x800ca4 <gc_block+0x25>
    227a:	f0 90 a5 0c 	lds	r15, 0x0CA5	; 0x800ca5 <gc_block+0x26>
    227e:	00 91 a6 0c 	lds	r16, 0x0CA6	; 0x800ca6 <gc_block+0x27>
    2282:	10 91 a7 0c 	lds	r17, 0x0CA7	; 0x800ca7 <gc_block+0x28>
    2286:	92 fa       	bst	r9, 2
    2288:	99 24       	eor	r9, r9
    228a:	90 f8       	bld	r9, 0
    228c:	9f 92       	push	r9
    228e:	8b a4       	ldd	r8, Y+43	; 0x2b
    2290:	af 8c       	ldd	r10, Y+31	; 0x1f
    2292:	c4 2c       	mov	r12, r4
    2294:	2f e8       	ldi	r18, 0x8F	; 143
    2296:	3c e0       	ldi	r19, 0x0C	; 12
    2298:	47 e5       	ldi	r20, 0x57	; 87
    229a:	5c e0       	ldi	r21, 0x0C	; 12
    229c:	be 01       	movw	r22, r28
    229e:	6e 5e       	subi	r22, 0xEE	; 238
    22a0:	7f 4f       	sbci	r23, 0xFF	; 255
    22a2:	8d ea       	ldi	r24, 0xAD	; 173
    22a4:	9c e0       	ldi	r25, 0x0C	; 12
    22a6:	0e 94 28 03 	call	0x650	; 0x650 <mc_arc>
    22aa:	0f 90       	pop	r0
  // NOTE: Commands G10,G28,G30,G92 lock out and prevent axis words from use in motion modes.
  // Enter motion modes only if there are axis words or a motion mode command word in the block.
  gc_state.modal.motion = gc_block.modal.motion;
  if (gc_state.modal.motion != MOTION_MODE_NONE) {
    if (axis_command == AXIS_COMMAND_MOTION_MODE) {
      uint8_t gc_update_pos = GC_UPDATE_POS_TARGET;
    22ac:	80 e0       	ldi	r24, 0x00	; 0
    22ae:	0b c0       	rjmp	.+22     	; 0x22c6 <__stack+0xc7>
            axis_0, axis_1, axis_linear, bit_istrue(gc_parser_flags,GC_PARSER_ARC_IS_CLOCKWISE));
      } else {
        // NOTE: gc_block.values.xyz is returned from mc_probe_cycle with the updated position value. So
        // upon a successful probing cycle, the machine position and the returned value should be the same.
        #ifndef ALLOW_FEED_OVERRIDE_DURING_PROBE_CYCLES
          pl_data->condition |= PL_COND_FLAG_NO_FEED_OVERRIDE;
    22b0:	8e 8d       	ldd	r24, Y+30	; 0x1e
    22b2:	84 60       	ori	r24, 0x04	; 4
    22b4:	8e 8f       	std	Y+30, r24	; 0x1e
        #endif
        gc_update_pos = mc_probe_cycle(gc_block.values.xyz, pl_data, gc_parser_flags);
    22b6:	49 2d       	mov	r20, r9
    22b8:	be 01       	movw	r22, r28
    22ba:	6e 5e       	subi	r22, 0xEE	; 238
    22bc:	7f 4f       	sbci	r23, 0xFF	; 255
    22be:	8d ea       	ldi	r24, 0xAD	; 173
    22c0:	9c e0       	ldi	r25, 0x0C	; 12
    22c2:	0e 94 36 06 	call	0xc6c	; 0xc6c <mc_probe_cycle>
      }  
     
      // As far as the parser is concerned, the position is now == target. In reality the
      // motion control system might still be processing the action and the real tool position
      // in any intermediate location.
      if (gc_update_pos == GC_UPDATE_POS_TARGET) {
    22c6:	81 11       	cpse	r24, r1
    22c8:	0a c0       	rjmp	.+20     	; 0x22de <__stack+0xdf>
        memcpy(gc_state.position, gc_block.values.xyz, sizeof(gc_block.values.xyz)); // gc_state.position[] = gc_block.values.xyz[]
    22ca:	8c e0       	ldi	r24, 0x0C	; 12
    22cc:	ed ea       	ldi	r30, 0xAD	; 173
    22ce:	fc e0       	ldi	r31, 0x0C	; 12
    22d0:	a7 e5       	ldi	r26, 0x57	; 87
    22d2:	bc e0       	ldi	r27, 0x0C	; 12
    22d4:	01 90       	ld	r0, Z+
    22d6:	0d 92       	st	X+, r0
    22d8:	8a 95       	dec	r24
    22da:	e1 f7       	brne	.-8      	; 0x22d4 <__stack+0xd5>
    22dc:	04 c0       	rjmp	.+8      	; 0x22e6 <__stack+0xe7>
      } else if (gc_update_pos == GC_UPDATE_POS_SYSTEM) {
    22de:	81 30       	cpi	r24, 0x01	; 1
    22e0:	11 f4       	brne	.+4      	; 0x22e6 <__stack+0xe7>
        gc_sync_position(); // gc_state.position[] = sys_position
    22e2:	0e 94 e2 06 	call	0xdc4	; 0xdc4 <gc_sync_position>
  }

  // [21. Program flow ]:
  // M0,M1,M2,M30: Perform non-running program flow actions. During a program pause, the buffer may
  // refill and can only be resumed by the cycle start run-time command.
  gc_state.modal.program_flow = gc_block.modal.program_flow;
    22e6:	80 91 87 0c 	lds	r24, 0x0C87	; 0x800c87 <gc_block+0x8>
    22ea:	80 93 46 0c 	sts	0x0C46, r24	; 0x800c46 <gc_state+0x7>
  if (gc_state.modal.program_flow) {
    22ee:	88 23       	and	r24, r24
    22f0:	09 f4       	brne	.+2      	; 0x22f4 <__stack+0xf5>
    protocol_buffer_synchronize(); // Sync and finish all remaining buffered motions before moving on.
    22f2:	a2 c0       	rjmp	.+324    	; 0x2438 <__stack+0x239>
    22f4:	df d6       	rcall	.+3518   	; 0x30b4 <protocol_buffer_synchronize>
    if (gc_state.modal.program_flow == PROGRAM_FLOW_PAUSED) {
    22f6:	80 91 46 0c 	lds	r24, 0x0C46	; 0x800c46 <gc_state+0x7>
    22fa:	83 30       	cpi	r24, 0x03	; 3
    22fc:	49 f4       	brne	.+18     	; 0x2310 <__stack+0x111>
      if (sys.state != STATE_CHECK_MODE) {
    22fe:	80 91 11 0c 	lds	r24, 0x0C11	; 0x800c11 <sys>
    2302:	82 30       	cpi	r24, 0x02	; 2
        system_set_exec_state_flag(EXEC_FEED_HOLD); // Use feed hold for program pause.
    2304:	61 f1       	breq	.+88     	; 0x235e <__stack+0x15f>
    2306:	88 e0       	ldi	r24, 0x08	; 8
    2308:	0e 94 4b 39 	call	0x7296	; 0x7296 <system_set_exec_state_flag>
        protocol_execute_realtime(); // Execute suspend.
    230c:	2b d6       	rcall	.+3158   	; 0x2f64 <protocol_execute_realtime>
    230e:	27 c0       	rjmp	.+78     	; 0x235e <__stack+0x15f>
    } else { // == PROGRAM_FLOW_COMPLETED
      // Upon program complete, only a subset of g-codes reset to certain defaults, according to
      // LinuxCNC's program end descriptions and testing. Only modal groups [G-code 1,2,3,5,7,12]
      // and [M-code 7,8,9] reset to [G1,G17,G90,G94,G40,G54,M5,M9,M48]. The remaining modal groups
      // [G-code 4,6,8,10,13,14,15] and [M-code 4,5,6] and the modal words [F,S,T,H] do not reset.
      gc_state.modal.motion = MOTION_MODE_LINEAR;
    2310:	ef e3       	ldi	r30, 0x3F	; 63
    2312:	fc e0       	ldi	r31, 0x0C	; 12
    2314:	81 e0       	ldi	r24, 0x01	; 1
    2316:	80 83       	st	Z, r24
      gc_state.modal.plane_select = PLANE_SELECT_XY;
    2318:	14 82       	std	Z+4, r1	; 0x04
      gc_state.modal.distance = DISTANCE_MODE_ABSOLUTE;
    231a:	13 82       	std	Z+3, r1	; 0x03
      gc_state.modal.feed_rate = FEED_RATE_MODE_UNITS_PER_MIN;
    231c:	11 82       	std	Z+1, r1	; 0x01
      // gc_state.modal.cutter_comp = CUTTER_COMP_DISABLE; // Not supported.
      gc_state.modal.coord_select = 0; // G54
    231e:	16 82       	std	Z+6, r1	; 0x06
      gc_state.modal.spindle = SPINDLE_DISABLE;
    2320:	11 86       	std	Z+9, r1	; 0x09
      gc_state.modal.coolant = COOLANT_DISABLE;
    2322:	10 86       	std	Z+8, r1	; 0x08
          gc_state.modal.override = OVERRIDE_PARKING_MOTION;
        #endif
      #endif

      #ifdef RESTORE_OVERRIDES_AFTER_PROGRAM_END
        sys.f_override = DEFAULT_FEED_OVERRIDE;
    2324:	e1 e1       	ldi	r30, 0x11	; 17
    2326:	fc e0       	ldi	r31, 0x0C	; 12
    2328:	84 e6       	ldi	r24, 0x64	; 100
    232a:	87 83       	std	Z+7, r24	; 0x07
        sys.r_override = DEFAULT_RAPID_OVERRIDE;
    232c:	80 87       	std	Z+8, r24	; 0x08
        sys.spindle_speed_ovr = DEFAULT_SPINDLE_SPEED_OVERRIDE;
    232e:	81 87       	std	Z+9, r24	; 0x09
      #endif

      // Execute coordinate change and spindle/coolant stop.
      if (sys.state != STATE_CHECK_MODE) {
    2330:	80 81       	ld	r24, Z
    2332:	82 30       	cpi	r24, 0x02	; 2
    2334:	89 f0       	breq	.+34     	; 0x2358 <__stack+0x159>
        if (!(settings_read_coord_data(gc_state.modal.coord_select,gc_state.coord_system))) { FAIL(STATUS_SETTING_READ_FAIL); }
    2336:	63 e6       	ldi	r22, 0x63	; 99
    2338:	7c e0       	ldi	r23, 0x0C	; 12
    233a:	80 e0       	ldi	r24, 0x00	; 0
    233c:	0e 94 18 25 	call	0x4a30	; 0x4a30 <settings_read_coord_data>
    2340:	88 23       	and	r24, r24
    2342:	09 f4       	brne	.+2      	; 0x2346 <__stack+0x147>
    2344:	78 c0       	rjmp	.+240    	; 0x2436 <__stack+0x237>
        system_flag_wco_change(); // Set to refresh immediately just in case something altered.
    2346:	0e 94 c7 38 	call	0x718e	; 0x718e <system_flag_wco_change>
        spindle_set_state(SPINDLE_DISABLE,0.0);
    234a:	40 e0       	ldi	r20, 0x00	; 0
    234c:	50 e0       	ldi	r21, 0x00	; 0
    234e:	ba 01       	movw	r22, r20
    2350:	80 e0       	ldi	r24, 0x00	; 0
        coolant_set_state(COOLANT_DISABLE);
    2352:	98 d1       	rcall	.+816    	; 0x2684 <spindle_set_state>
    2354:	80 e0       	ldi	r24, 0x00	; 0
    2356:	fa d1       	rcall	.+1012   	; 0x274c <coolant_set_state>
      }
      report_feedback_message(MESSAGE_PROGRAM_END);
    2358:	88 e0       	ldi	r24, 0x08	; 8
    235a:	0e 94 95 33 	call	0x672a	; 0x672a <report_feedback_message>
    }
    gc_state.modal.program_flow = PROGRAM_FLOW_RUNNING; // Reset program flow.
    235e:	10 92 46 0c 	sts	0x0C46, r1	; 0x800c46 <gc_state+0x7>
  }

  // TODO: % to denote start of program.

  return(STATUS_OK);
    2362:	87 2d       	mov	r24, r7
    2364:	69 c0       	rjmp	.+210    	; 0x2438 <__stack+0x239>

  while (line[char_counter] != 0) { // Loop until no more g-code words in line.

    // Import the next g-code word, expecting a letter followed by a value. Otherwise, error out.
    letter = line[char_counter];
    if((letter < 'A') || (letter > 'Z')) { FAIL(STATUS_EXPECTED_COMMAND_LETTER); } // [Expected word letter]
    2366:	81 e0       	ldi	r24, 0x01	; 1
    2368:	67 c0       	rjmp	.+206    	; 0x2438 <__stack+0x239>
    char_counter++;
    if (!read_float(line, &char_counter, &value)) { FAIL(STATUS_BAD_NUMBER_FORMAT); } // [Expected word value]
    236a:	82 e0       	ldi	r24, 0x02	; 2
    236c:	65 c0       	rjmp	.+202    	; 0x2438 <__stack+0x239>
          case 61:
            word_bit = MODAL_GROUP_G13;
            if (mantissa != 0) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G61.1 not supported]
            // gc_block.modal.control = CONTROL_MODE_EXACT_PATH; // G61
            break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G command]
    236e:	84 e1       	ldi	r24, 0x14	; 20
    2370:	63 c0       	rjmp	.+198    	; 0x2438 <__stack+0x239>
        switch(int_value) {
          case 10: case 28: case 30: case 92:
            // Check for G10/28/30/92 being called with G0/1/2/3/38 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (mantissa == 0) { // Ignore G28.1, G30.1, and G92.1
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
    2372:	88 e1       	ldi	r24, 0x18	; 24
    2374:	61 c0       	rjmp	.+194    	; 0x2438 <__stack+0x239>
            // No break. Continues to next line.
          case 4: case 53:
            word_bit = MODAL_GROUP_G0;
            gc_block.non_modal_command = int_value;
            if ((int_value == 28) || (int_value == 30) || (int_value == 92)) {
              if (!((mantissa == 0) || (mantissa == 10))) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); }
    2376:	84 e1       	ldi	r24, 0x14	; 20
    2378:	5f c0       	rjmp	.+190    	; 0x2438 <__stack+0x239>
            }                
            break;
          case 0: case 1: case 2: case 3: case 38:
            // Check for G0/1/2/3/38 being called with G10/28/30/92 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
    237a:	88 e1       	ldi	r24, 0x18	; 24
    237c:	5d c0       	rjmp	.+186    	; 0x2438 <__stack+0x239>
          case 80:
            word_bit = MODAL_GROUP_G1;
            gc_block.modal.motion = int_value;
            if (int_value == 38){
              if (!((mantissa == 20) || (mantissa == 30) || (mantissa == 40) || (mantissa == 50))) {
                FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G38.x command]
    237e:	84 e1       	ldi	r24, 0x14	; 20
    2380:	5b c0       	rjmp	.+182    	; 0x2438 <__stack+0x239>
            if (mantissa == 0) {
              word_bit = MODAL_GROUP_G3;
              gc_block.modal.distance = int_value - 90;
            } else {
              word_bit = MODAL_GROUP_G4;
              if ((mantissa != 10) || (int_value == 90)) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G90.1 not supported]
    2382:	84 e1       	ldi	r24, 0x14	; 20
    2384:	59 c0       	rjmp	.+178    	; 0x2438 <__stack+0x239>
    2386:	84 e1       	ldi	r24, 0x14	; 20
    2388:	57 c0       	rjmp	.+174    	; 0x2438 <__stack+0x239>
          case 43: case 49:
            word_bit = MODAL_GROUP_G8;
            // NOTE: The NIST g-code standard vaguely states that when a tool length offset is changed,
            // there cannot be any axis motion or coordinate offsets updated. Meaning G43, G43.1, and G49
            // all are explicit axis commands, regardless if they require axis words or not.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict] }
    238a:	88 e1       	ldi	r24, 0x18	; 24
    238c:	55 c0       	rjmp	.+170    	; 0x2438 <__stack+0x239>
            axis_command = AXIS_COMMAND_TOOL_LENGTH_OFFSET;
            if (int_value == 49) { // G49
              gc_block.modal.tool_length = TOOL_LENGTH_OFFSET_CANCEL;
            } else if (mantissa == 10) { // G43.1
              gc_block.modal.tool_length = TOOL_LENGTH_OFFSET_ENABLE_DYNAMIC;
            } else { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [Unsupported G43.x command]
    238e:	84 e1       	ldi	r24, 0x14	; 20
    2390:	53 c0       	rjmp	.+166    	; 0x2438 <__stack+0x239>
            word_bit = MODAL_GROUP_G12;
            gc_block.modal.coord_select = int_value - 54; // Shift to array indexing.
            break;
          case 61:
            word_bit = MODAL_GROUP_G13;
            if (mantissa != 0) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G61.1 not supported]
    2392:	84 e1       	ldi	r24, 0x14	; 20
    2394:	51 c0       	rjmp	.+162    	; 0x2438 <__stack+0x239>
            // gc_block.modal.control = CONTROL_MODE_EXACT_PATH; // G61
            break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G command]
        }
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [Unsupported or invalid Gxx.x command]
    2396:	87 e1       	ldi	r24, 0x17	; 23
    2398:	4f c0       	rjmp	.+158    	; 0x2438 <__stack+0x239>
        // Check for more than one command per modal group violations in the current block
        // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
        if ( bit_istrue(command_words,bit(word_bit)) ) { FAIL(STATUS_GCODE_MODAL_GROUP_VIOLATION); }
    239a:	85 e1       	ldi	r24, 0x15	; 21
    239c:	4d c0       	rjmp	.+154    	; 0x2438 <__stack+0x239>
        break;

      case 'M':

        // Determine 'M' command and its modal group
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [No Mxx.x commands]
    239e:	87 e1       	ldi	r24, 0x17	; 23
    23a0:	4b c0       	rjmp	.+150    	; 0x2438 <__stack+0x239>
            case 56:
              word_bit = MODAL_GROUP_M9;
              gc_block.modal.override = OVERRIDE_PARKING_MOTION;
              break;
          #endif
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported M command]
    23a2:	84 e1       	ldi	r24, 0x14	; 20
    23a4:	49 c0       	rjmp	.+146    	; 0x2438 <__stack+0x239>
        }

        // Check for more than one command per modal group violations in the current block
        // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
        if ( bit_istrue(command_words,bit(word_bit)) ) { FAIL(STATUS_GCODE_MODAL_GROUP_VIOLATION); }
    23a6:	85 e1       	ldi	r24, 0x15	; 21
    23a8:	47 c0       	rjmp	.+142    	; 0x2438 <__stack+0x239>
						gc_block.values.t = int_value;
						break;
          case 'X': word_bit = WORD_X; gc_block.values.xyz[X_AXIS] = value; axis_words |= (1<<X_AXIS); break;
          case 'Y': word_bit = WORD_Y; gc_block.values.xyz[Y_AXIS] = value; axis_words |= (1<<Y_AXIS); break;
          case 'Z': word_bit = WORD_Z; gc_block.values.xyz[Z_AXIS] = value; axis_words |= (1<<Z_AXIS); break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND);
    23aa:	84 e1       	ldi	r24, 0x14	; 20
    23ac:	45 c0       	rjmp	.+138    	; 0x2438 <__stack+0x239>
          // NOTE: For certain commands, P value must be an integer, but none of these commands are supported.
          // case 'Q': // Not supported
          case 'R': word_bit = WORD_R; gc_block.values.r = value; break;
          case 'S': word_bit = WORD_S; gc_block.values.s = value; break;
          case 'T': word_bit = WORD_T; 
						if (value > MAX_TOOL_NUMBER) { FAIL(STATUS_GCODE_MAX_VALUE_EXCEEDED); }
    23ae:	86 e2       	ldi	r24, 0x26	; 38
    23b0:	43 c0       	rjmp	.+134    	; 0x2438 <__stack+0x239>
          case 'Z': word_bit = WORD_Z; gc_block.values.xyz[Z_AXIS] = value; axis_words |= (1<<Z_AXIS); break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND);
        }

        // NOTE: Variable 'word_bit' is always assigned, if the non-command letter is valid.
        if (bit_istrue(value_words,bit(word_bit))) { FAIL(STATUS_GCODE_WORD_REPEATED); } // [Word repeated]
    23b2:	89 e1       	ldi	r24, 0x19	; 25
    23b4:	41 c0       	rjmp	.+130    	; 0x2438 <__stack+0x239>
        // Check for invalid negative values for words F, N, P, T, and S.
        // NOTE: Negative value check is done here simply for code-efficiency.
        if ( bit(word_bit) & (bit(WORD_F)|bit(WORD_N)|bit(WORD_P)|bit(WORD_T)|bit(WORD_S)) ) {
          if (value < 0.0) { FAIL(STATUS_NEGATIVE_VALUE); } // [Word value cannot be negative]
    23b6:	84 e0       	ldi	r24, 0x04	; 4
    23b8:	3f c0       	rjmp	.+126    	; 0x2438 <__stack+0x239>
  }

  // Check for valid line number N value.
  if (bit_istrue(value_words,bit(WORD_N))) {
    // Line number value cannot be less than zero (done) or greater than max line number.
    if (gc_block.values.n > MAX_LINE_NUMBER) { FAIL(STATUS_GCODE_INVALID_LINE_NUMBER); } // [Exceeds max line number]
    23ba:	8b e1       	ldi	r24, 0x1B	; 27
    23bc:	3d c0       	rjmp	.+122    	; 0x2438 <__stack+0x239>

  // [2. Set feed rate mode ]: G93 F word missing with G1,G2/3 active, implicitly or explicitly. Feed rate
  //   is not defined after switching to G94 from G93.
  // NOTE: For jogging, ignore prior feed rate mode. Enforce G94 and check for required F word.
  if (gc_parser_flags & GC_PARSER_JOG_MOTION) {
    if (bit_isfalse(value_words,bit(WORD_F))) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); }
    23be:	86 e1       	ldi	r24, 0x16	; 22
    23c0:	3b c0       	rjmp	.+118    	; 0x2438 <__stack+0x239>
  } else {
    if (gc_block.modal.feed_rate == FEED_RATE_MODE_INVERSE_TIME) { // = G93
      // NOTE: G38 can also operate in inverse time, but is undefined as an error. Missing F word check added here.
      if (axis_command == AXIS_COMMAND_MOTION_MODE) {
        if ((gc_block.modal.motion != MOTION_MODE_NONE) && (gc_block.modal.motion != MOTION_MODE_SEEK)) {
          if (bit_isfalse(value_words,bit(WORD_F))) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); } // [F word missing]
    23c2:	86 e1       	ldi	r24, 0x16	; 22
    23c4:	39 c0       	rjmp	.+114    	; 0x2438 <__stack+0x239>
    }
  #endif

  // [10. Dwell ]: P value missing. P is negative (done.) NOTE: See below.
  if (gc_block.non_modal_command == NON_MODAL_DWELL) {
    if (bit_isfalse(value_words,bit(WORD_P))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSING); } // [P word missing]
    23c6:	8c e1       	ldi	r24, 0x1C	; 28
    23c8:	37 c0       	rjmp	.+110    	; 0x2438 <__stack+0x239>
  //   NOTE: Although not explicitly stated so, G43.1 should be applied to only one valid
  //   axis that is configured (in config.h). There should be an error if the configured axis
  //   is absent or if any of the other axis words are present.
  if (axis_command == AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // Indicates called in block.
    if (gc_block.modal.tool_length == TOOL_LENGTH_OFFSET_ENABLE_DYNAMIC) {
      if (axis_words ^ (1<<TOOL_LENGTH_OFFSET_AXIS)) { FAIL(STATUS_GCODE_G43_DYNAMIC_AXIS_ERROR); }
    23ca:	85 e2       	ldi	r24, 0x25	; 37
    23cc:	35 c0       	rjmp	.+106    	; 0x2438 <__stack+0x239>
  // future versions on processors with enough memory, all coordinate data should be stored
  // in memory and written to EEPROM only when there is not a cycle active.
  float block_coord_system[N_AXIS];
  memcpy(block_coord_system,gc_state.coord_system,sizeof(gc_state.coord_system));
  if ( bit_istrue(command_words,bit(MODAL_GROUP_G12)) ) { // Check if called in block
    if (gc_block.modal.coord_select > N_COORDINATE_SYSTEM) { FAIL(STATUS_GCODE_UNSUPPORTED_COORD_SYS); } // [Greater than N sys]
    23ce:	8d e1       	ldi	r24, 0x1D	; 29
    23d0:	33 c0       	rjmp	.+102    	; 0x2438 <__stack+0x239>
    if (gc_state.modal.coord_select != gc_block.modal.coord_select) {
      if (!(settings_read_coord_data(gc_block.modal.coord_select,block_coord_system))) { FAIL(STATUS_SETTING_READ_FAIL); }
    23d2:	87 e0       	ldi	r24, 0x07	; 7
    23d4:	31 c0       	rjmp	.+98     	; 0x2438 <__stack+0x239>
  switch (gc_block.non_modal_command) {
    case NON_MODAL_SET_COORDINATE_DATA:
      // [G10 Errors]: L missing and is not 2 or 20. P word missing. (Negative P value done.)
      // [G10 L2 Errors]: R word NOT SUPPORTED. P value not 0 to nCoordSys(max 9). Axis words missing.
      // [G10 L20 Errors]: P must be 0 to nCoordSys(max 9). Axis words missing.
      if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS) }; // [No axis words]
    23d6:	8a e1       	ldi	r24, 0x1A	; 26
    23d8:	2f c0       	rjmp	.+94     	; 0x2438 <__stack+0x239>
      if (bit_isfalse(value_words,((1<<WORD_P)|(1<<WORD_L)))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSING); } // [P/L word missing]
    23da:	8c e1       	ldi	r24, 0x1C	; 28
    23dc:	2d c0       	rjmp	.+90     	; 0x2438 <__stack+0x239>
      coord_select = trunc(gc_block.values.p); // Convert p value to int.
      if (coord_select > N_COORDINATE_SYSTEM) { FAIL(STATUS_GCODE_UNSUPPORTED_COORD_SYS); } // [Greater than N sys]
    23de:	8d e1       	ldi	r24, 0x1D	; 29
    23e0:	2b c0       	rjmp	.+86     	; 0x2438 <__stack+0x239>
      if (gc_block.values.l != 20) {
        if (gc_block.values.l == 2) {
          if (bit_istrue(value_words,bit(WORD_R))) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G10 L2 R not supported]
        } else { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [Unsupported L]
    23e2:	84 e1       	ldi	r24, 0x14	; 20
    23e4:	29 c0       	rjmp	.+82     	; 0x2438 <__stack+0x239>
      if (bit_isfalse(value_words,((1<<WORD_P)|(1<<WORD_L)))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSING); } // [P/L word missing]
      coord_select = trunc(gc_block.values.p); // Convert p value to int.
      if (coord_select > N_COORDINATE_SYSTEM) { FAIL(STATUS_GCODE_UNSUPPORTED_COORD_SYS); } // [Greater than N sys]
      if (gc_block.values.l != 20) {
        if (gc_block.values.l == 2) {
          if (bit_istrue(value_words,bit(WORD_R))) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G10 L2 R not supported]
    23e6:	84 e1       	ldi	r24, 0x14	; 20
    23e8:	27 c0       	rjmp	.+78     	; 0x2438 <__stack+0x239>
      // Determine coordinate system to change and try to load from EEPROM.
      if (coord_select > 0) { coord_select--; } // Adjust P1-P6 index to EEPROM coordinate data indexing.
      else { coord_select = gc_block.modal.coord_select; } // Index P0 as the active coordinate system
      
      // NOTE: Store parameter data in IJK values. By rule, they are not in use with this command.
      if (!settings_read_coord_data(coord_select,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); } // [EEPROM read fail]
    23ea:	87 e0       	ldi	r24, 0x07	; 7
    23ec:	25 c0       	rjmp	.+74     	; 0x2438 <__stack+0x239>
        } // Else, keep current stored value.
      }
      break;
    case NON_MODAL_SET_COORDINATE_OFFSET:
      // [G92 Errors]: No axis words.
      if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    23ee:	8a e1       	ldi	r24, 0x1A	; 26
    23f0:	23 c0       	rjmp	.+70     	; 0x2438 <__stack+0x239>
        case NON_MODAL_GO_HOME_1: // G30
          // [G28/30 Errors]: Cutter compensation is enabled.
          // Retreive G28/30 go-home position data (in machine coordinates) from EEPROM
          // NOTE: Store parameter data in IJK values. By rule, they are not in use with this command.
          if (gc_block.non_modal_command == NON_MODAL_GO_HOME_0) {
            if (!settings_read_coord_data(SETTING_INDEX_G28,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); }
    23f2:	87 e0       	ldi	r24, 0x07	; 7
    23f4:	21 c0       	rjmp	.+66     	; 0x2438 <__stack+0x239>
          } else { // == NON_MODAL_GO_HOME_1
            if (!settings_read_coord_data(SETTING_INDEX_G30,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); }
    23f6:	87 e0       	ldi	r24, 0x07	; 7
    23f8:	1f c0       	rjmp	.+62     	; 0x2438 <__stack+0x239>
          break;
        case NON_MODAL_ABSOLUTE_OVERRIDE:
          // [G53 Errors]: G0 and G1 are not active. Cutter compensation is enabled.
          // NOTE: All explicit axis word commands are in this modal group. So no implicit check necessary.
          if (!(gc_block.modal.motion == MOTION_MODE_SEEK || gc_block.modal.motion == MOTION_MODE_LINEAR)) {
            FAIL(STATUS_GCODE_G53_INVALID_MOTION_MODE); // [G53 G0/1 not active]
    23fa:	8e e1       	ldi	r24, 0x1E	; 30
    23fc:	1d c0       	rjmp	.+58     	; 0x2438 <__stack+0x239>

  // [20. Motion modes ]:
  if (gc_block.modal.motion == MOTION_MODE_NONE) {
    // [G80 Errors]: Axis word are programmed while G80 is active.
    // NOTE: Even non-modal commands or TLO that use axis words will throw this strict error.
    if (axis_words) { FAIL(STATUS_GCODE_AXIS_WORDS_EXIST); } // [No axis words allowed]
    23fe:	8f e1       	ldi	r24, 0x1F	; 31
    2400:	1b c0       	rjmp	.+54     	; 0x2438 <__stack+0x239>

    // All remaining motion modes (all but G0 and G80), require a valid feed rate value. In units per mm mode,
    // the value must be positive. In inverse time mode, a positive value must be passed with each block.
    } else {
      // Check if feed rate is defined for the motion modes that require it.
      if (gc_block.values.f == 0.0) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); } // [Feed rate undefined]
    2402:	86 e1       	ldi	r24, 0x16	; 22
    2404:	19 c0       	rjmp	.+50     	; 0x2438 <__stack+0x239>
          // [G2/3 Offset-Mode Errors]: No axis words and/or offsets in selected plane. The radius to the current
          //   point and the radius to the target point differs more than 0.002mm (EMC def. 0.5mm OR 0.005mm and 0.1% radius).
          // [G2/3 Full-Circle-Mode Errors]: NOT SUPPORTED. Axis words exist. No offsets programmed. P must be an integer.
          // NOTE: Both radius and offsets are required for arc tracing and are pre-computed with the error-checking.

          if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    2406:	8a e1       	ldi	r24, 0x1A	; 26
    2408:	17 c0       	rjmp	.+46     	; 0x2438 <__stack+0x239>
          if (!(axis_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_AXIS_WORDS_IN_PLANE); } // [No axis words in plane]
    240a:	80 e2       	ldi	r24, 0x20	; 32
    240c:	15 c0       	rjmp	.+42     	; 0x2438 <__stack+0x239>
          x = gc_block.values.xyz[axis_0]-gc_state.position[axis_0]; // Delta x between current position and target
          y = gc_block.values.xyz[axis_1]-gc_state.position[axis_1]; // Delta y between current position and target

          if (value_words & bit(WORD_R)) { // Arc Radius Mode
            bit_false(value_words,bit(WORD_R));
            if (isequal_position_vector(gc_state.position, gc_block.values.xyz)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Invalid target]
    240e:	81 e2       	ldi	r24, 0x21	; 33
    2410:	13 c0       	rjmp	.+38     	; 0x2438 <__stack+0x239>

            // First, use h_x2_div_d to compute 4*h^2 to check if it is negative or r is smaller
            // than d. If so, the sqrt of a negative number is complex and error out.
            float h_x2_div_d = 4.0 * gc_block.values.r*gc_block.values.r - x*x - y*y;

            if (h_x2_div_d < 0) { FAIL(STATUS_GCODE_ARC_RADIUS_ERROR); } // [Arc radius error]
    2412:	82 e2       	ldi	r24, 0x22	; 34
    2414:	11 c0       	rjmp	.+34     	; 0x2438 <__stack+0x239>
            // Complete the operation by calculating the actual center of the arc
            gc_block.values.ijk[axis_0] = 0.5*(x-(y*h_x2_div_d));
            gc_block.values.ijk[axis_1] = 0.5*(y+(x*h_x2_div_d));

          } else { // Arc Center Format Offset Mode
            if (!(ijk_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_OFFSETS_IN_PLANE); } // [No offsets in plane]
    2416:	83 e2       	ldi	r24, 0x23	; 35
    2418:	0f c0       	rjmp	.+30     	; 0x2438 <__stack+0x239>
            gc_block.values.r = hypot_f(gc_block.values.ijk[axis_0], gc_block.values.ijk[axis_1]);

            // Compute difference between current location and target radii for final error-checks.
            float delta_r = fabs(target_r-gc_block.values.r);
            if (delta_r > 0.005) {
              if (delta_r > 0.5) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Arc definition error] > 0.5mm
    241a:	81 e2       	ldi	r24, 0x21	; 33
    241c:	0d c0       	rjmp	.+26     	; 0x2438 <__stack+0x239>
              if (delta_r > (0.001*gc_block.values.r)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Arc definition error] > 0.005mm AND 0.1% radius
    241e:	81 e2       	ldi	r24, 0x21	; 33
    2420:	0b c0       	rjmp	.+22     	; 0x2438 <__stack+0x239>
              (gc_block.modal.motion == MOTION_MODE_PROBE_AWAY_NO_ERROR)) { gc_parser_flags |= GC_PARSER_PROBE_IS_AWAY; }
          // [G38 Errors]: Target is same current. No axis words. Cutter compensation is enabled. Feed rate
          //   is undefined. Probe is triggered. NOTE: Probe check moved to probe cycle. Instead of returning
          //   an error, it issues an alarm to prevent further motion to the probe. It's also done there to
          //   allow the planner buffer to empty and move off the probe trigger before another probing cycle.
          if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    2422:	8a e1       	ldi	r24, 0x1A	; 26
    2424:	09 c0       	rjmp	.+18     	; 0x2438 <__stack+0x239>
          if (isequal_position_vector(gc_state.position, gc_block.values.xyz)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Invalid target]
    2426:	81 e2       	ldi	r24, 0x21	; 33
    2428:	07 c0       	rjmp	.+14     	; 0x2438 <__stack+0x239>
    bit_false(value_words,(bit(WORD_N)|bit(WORD_F)));
  } else {
    bit_false(value_words,(bit(WORD_N)|bit(WORD_F)|bit(WORD_S)|bit(WORD_T))); // Remove single-meaning value words.
  }
  if (axis_command) { bit_false(value_words,(bit(WORD_X)|bit(WORD_Y)|bit(WORD_Z))); } // Remove axis words.
  if (value_words) { FAIL(STATUS_GCODE_UNUSED_WORDS); } // [Unused words]
    242a:	84 e2       	ldi	r24, 0x24	; 36
    242c:	05 c0       	rjmp	.+10     	; 0x2438 <__stack+0x239>
  // targets are computed correctly. The final parser position after a jog is updated in
  // protocol_execute_realtime() when jogging completes or is canceled.
  if (gc_parser_flags & GC_PARSER_JOG_MOTION) {
    // Only distance and unit modal commands and G53 absolute override command are allowed.
    // NOTE: Feed rate word and axis word checks have already been performed in STEP 3.
    if (command_words & ~(bit(MODAL_GROUP_G3) | bit(MODAL_GROUP_G6 | bit(MODAL_GROUP_G0))) ) { FAIL(STATUS_INVALID_JOG_COMMAND) };
    242e:	80 e1       	ldi	r24, 0x10	; 16
    2430:	03 c0       	rjmp	.+6      	; 0x2438 <__stack+0x239>
    if (!(gc_block.non_modal_command == NON_MODAL_ABSOLUTE_OVERRIDE || gc_block.non_modal_command == NON_MODAL_NO_ACTION)) { FAIL(STATUS_INVALID_JOG_COMMAND); }
    2432:	80 e1       	ldi	r24, 0x10	; 16
    2434:	01 c0       	rjmp	.+2      	; 0x2438 <__stack+0x239>
        sys.spindle_speed_ovr = DEFAULT_SPINDLE_SPEED_OVERRIDE;
      #endif

      // Execute coordinate change and spindle/coolant stop.
      if (sys.state != STATE_CHECK_MODE) {
        if (!(settings_read_coord_data(gc_state.modal.coord_select,gc_state.coord_system))) { FAIL(STATUS_SETTING_READ_FAIL); }
    2436:	87 e0       	ldi	r24, 0x07	; 7
  }

  // TODO: % to denote start of program.

  return(STATUS_OK);
}
    2438:	e3 96       	adiw	r28, 0x33	; 51
    243a:	0f b6       	in	r0, 0x3f	; 63
    243c:	f8 94       	cli
    243e:	de bf       	out	0x3e, r29	; 62
    2440:	0f be       	out	0x3f, r0	; 63
    2442:	cd bf       	out	0x3d, r28	; 61
    2444:	df 91       	pop	r29
    2446:	cf 91       	pop	r28
    2448:	1f 91       	pop	r17
    244a:	0f 91       	pop	r16
    244c:	ff 90       	pop	r15
    244e:	ef 90       	pop	r14
    2450:	df 90       	pop	r13
    2452:	cf 90       	pop	r12
    2454:	bf 90       	pop	r11
    2456:	af 90       	pop	r10
    2458:	9f 90       	pop	r9
    245a:	8f 90       	pop	r8
    245c:	7f 90       	pop	r7
    245e:	6f 90       	pop	r6
    2460:	5f 90       	pop	r5
    2462:	4f 90       	pop	r4
    2464:	3f 90       	pop	r3
    2466:	2f 90       	pop	r2
    2468:	08 95       	ret

0000246a <spindle_get_state>:
uint8_t spindle_get_state()
{
  #ifdef INVERT_SPINDLE_ENABLE_PIN
    if (bit_isfalse(SPINDLE_ENABLE_PORT,(1<<SPINDLE_ENABLE_BIT)) && (SPINDLE_TCCRA_REGISTER & (1<<SPINDLE_COMB_BIT))) {
  #else
    if (bit_istrue(SPINDLE_ENABLE_PORT,(1<<SPINDLE_ENABLE_BIT)) && (SPINDLE_TCCRA_REGISTER & (1<<SPINDLE_COMB_BIT))) {
    246a:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x7c0102>
    246e:	89 2f       	mov	r24, r25
    2470:	88 70       	andi	r24, 0x08	; 8
    2472:	93 ff       	sbrs	r25, 3
    2474:	0b c0       	rjmp	.+22     	; 0x248c <spindle_get_state+0x22>
    2476:	90 91 a0 00 	lds	r25, 0x00A0	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7c00a0>
    247a:	89 2f       	mov	r24, r25
    247c:	80 72       	andi	r24, 0x20	; 32
    247e:	95 ff       	sbrs	r25, 5
    2480:	05 c0       	rjmp	.+10     	; 0x248c <spindle_get_state+0x22>
  #endif
    if (SPINDLE_DIRECTION_PORT & (1<<SPINDLE_DIRECTION_BIT)) { return(SPINDLE_STATE_CCW); }
    2482:	73 9b       	sbis	0x0e, 3	; 14
    2484:	02 c0       	rjmp	.+4      	; 0x248a <spindle_get_state+0x20>
    2486:	82 e0       	ldi	r24, 0x02	; 2
    2488:	08 95       	ret
    else { return(SPINDLE_STATE_CW); }
    248a:	81 e0       	ldi	r24, 0x01	; 1
  }
	return(SPINDLE_STATE_DISABLE);
}
    248c:	08 95       	ret

0000248e <spindle_stop>:
// Disables the spindle and sets PWM output to zero when PWM variable spindle speed is enabled.
// Called by various main program and ISR routines. Keep routine small, fast, and efficient.
// Called by spindle_init(), spindle_set_speed(), spindle_set_state(), and mc_reset().
void spindle_stop()
{
  SPINDLE_TCCRA_REGISTER &= ~(1<<SPINDLE_COMB_BIT); // Disable PWM. Output voltage is zero.
    248e:	e0 ea       	ldi	r30, 0xA0	; 160
    2490:	f0 e0       	ldi	r31, 0x00	; 0
    2492:	80 81       	ld	r24, Z
    2494:	8f 7d       	andi	r24, 0xDF	; 223
    2496:	80 83       	st	Z, r24
  #ifdef INVERT_SPINDLE_ENABLE_PIN
    SPINDLE_ENABLE_PORT |= (1<<SPINDLE_ENABLE_BIT);  // Set pin to high
  #else
    SPINDLE_ENABLE_PORT &= ~(1<<SPINDLE_ENABLE_BIT); // Set pin to low
    2498:	e2 e0       	ldi	r30, 0x02	; 2
    249a:	f1 e0       	ldi	r31, 0x01	; 1
    249c:	80 81       	ld	r24, Z
    249e:	87 7f       	andi	r24, 0xF7	; 247
    24a0:	80 83       	st	Z, r24
    24a2:	08 95       	ret

000024a4 <spindle_init>:


void spindle_init()
{    
  // Configure variable spindle PWM and enable pin, if required.
  SPINDLE_PWM_DDR |= (1<<SPINDLE_PWM_BIT); // Configure as PWM output pin.
    24a4:	e1 e0       	ldi	r30, 0x01	; 1
    24a6:	f1 e0       	ldi	r31, 0x01	; 1
    24a8:	80 81       	ld	r24, Z
    24aa:	80 61       	ori	r24, 0x10	; 16
    24ac:	80 83       	st	Z, r24
  SPINDLE_TCCRA_REGISTER = SPINDLE_TCCRA_INIT_MASK; // Configure PWM output compare timer
    24ae:	83 e0       	ldi	r24, 0x03	; 3
    24b0:	80 93 a0 00 	sts	0x00A0, r24	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7c00a0>
  SPINDLE_TCCRB_REGISTER = SPINDLE_TCCRB_INIT_MASK;
    24b4:	8a e1       	ldi	r24, 0x1A	; 26
    24b6:	80 93 a1 00 	sts	0x00A1, r24	; 0x8000a1 <__TEXT_REGION_LENGTH__+0x7c00a1>
  SPINDLE_OCRA_REGISTER = SPINDLE_OCRA_TOP_VALUE; // Set the top value for 16-bit fast PWM mode
    24ba:	80 e0       	ldi	r24, 0x00	; 0
    24bc:	94 e0       	ldi	r25, 0x04	; 4
    24be:	90 93 a9 00 	sts	0x00A9, r25	; 0x8000a9 <__TEXT_REGION_LENGTH__+0x7c00a9>
    24c2:	80 93 a8 00 	sts	0x00A8, r24	; 0x8000a8 <__TEXT_REGION_LENGTH__+0x7c00a8>
  SPINDLE_ENABLE_DDR |= (1<<SPINDLE_ENABLE_BIT); // Configure as output pin.
    24c6:	80 81       	ld	r24, Z
    24c8:	88 60       	ori	r24, 0x08	; 8
    24ca:	80 83       	st	Z, r24
  SPINDLE_DIRECTION_DDR |= (1<<SPINDLE_DIRECTION_BIT); // Configure as output pin.
    24cc:	8d b1       	in	r24, 0x0d	; 13
    24ce:	88 60       	ori	r24, 0x08	; 8
    24d0:	8d b9       	out	0x0d, r24	; 13

  pwm_gradient = SPINDLE_PWM_RANGE/(settings.rpm_max-settings.rpm_min);
    24d2:	60 91 f6 0e 	lds	r22, 0x0EF6	; 0x800ef6 <settings+0x3d>
    24d6:	70 91 f7 0e 	lds	r23, 0x0EF7	; 0x800ef7 <settings+0x3e>
    24da:	80 91 f8 0e 	lds	r24, 0x0EF8	; 0x800ef8 <settings+0x3f>
    24de:	90 91 f9 0e 	lds	r25, 0x0EF9	; 0x800ef9 <settings+0x40>
    24e2:	20 91 fa 0e 	lds	r18, 0x0EFA	; 0x800efa <settings+0x41>
    24e6:	30 91 fb 0e 	lds	r19, 0x0EFB	; 0x800efb <settings+0x42>
    24ea:	40 91 fc 0e 	lds	r20, 0x0EFC	; 0x800efc <settings+0x43>
    24ee:	50 91 fd 0e 	lds	r21, 0x0EFD	; 0x800efd <settings+0x44>
    24f2:	0e 94 34 3c 	call	0x7868	; 0x7868 <__subsf3>
    24f6:	9b 01       	movw	r18, r22
    24f8:	ac 01       	movw	r20, r24
    24fa:	60 e0       	ldi	r22, 0x00	; 0
    24fc:	70 ec       	ldi	r23, 0xC0	; 192
    24fe:	8f e7       	ldi	r24, 0x7F	; 127
    2500:	94 e4       	ldi	r25, 0x44	; 68
    2502:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <__divsf3>
    2506:	60 93 00 02 	sts	0x0200, r22	; 0x800200 <_edata>
    250a:	70 93 01 02 	sts	0x0201, r23	; 0x800201 <_edata+0x1>
    250e:	80 93 02 02 	sts	0x0202, r24	; 0x800202 <_edata+0x2>
    2512:	90 93 03 02 	sts	0x0203, r25	; 0x800203 <_edata+0x3>
  spindle_stop();
    2516:	bb cf       	rjmp	.-138    	; 0x248e <spindle_stop>
    2518:	08 95       	ret

0000251a <spindle_set_speed>:

// Sets spindle speed PWM output and enable pin, if configured. Called by spindle_set_state()
// and stepper ISR. Keep routine small and efficient.
void spindle_set_speed(uint16_t pwm_value)
{
  SPINDLE_OCR_REGISTER = pwm_value; // Set PWM output level.
    251a:	90 93 ab 00 	sts	0x00AB, r25	; 0x8000ab <__TEXT_REGION_LENGTH__+0x7c00ab>
    251e:	80 93 aa 00 	sts	0x00AA, r24	; 0x8000aa <__TEXT_REGION_LENGTH__+0x7c00aa>
      #else
        SPINDLE_ENABLE_PORT |= (1<<SPINDLE_ENABLE_BIT);
      #endif
    }
  #else
    if (pwm_value == SPINDLE_PWM_OFF_VALUE) {
    2522:	89 2b       	or	r24, r25
    2524:	31 f4       	brne	.+12     	; 0x2532 <spindle_set_speed+0x18>
      SPINDLE_TCCRA_REGISTER &= ~(1<<SPINDLE_COMB_BIT); // Disable PWM. Output voltage is zero.
    2526:	e0 ea       	ldi	r30, 0xA0	; 160
    2528:	f0 e0       	ldi	r31, 0x00	; 0
    252a:	80 81       	ld	r24, Z
    252c:	8f 7d       	andi	r24, 0xDF	; 223
    252e:	80 83       	st	Z, r24
    2530:	08 95       	ret
    } else {
      SPINDLE_TCCRA_REGISTER |= (1<<SPINDLE_COMB_BIT); // Ensure PWM output is enabled.
    2532:	e0 ea       	ldi	r30, 0xA0	; 160
    2534:	f0 e0       	ldi	r31, 0x00	; 0
    2536:	80 81       	ld	r24, Z
    2538:	80 62       	ori	r24, 0x20	; 32
    253a:	80 83       	st	Z, r24
    253c:	08 95       	ret

0000253e <spindle_compute_pwm_value>:

#else 

  // Called by spindle_set_state() and step segment generator. Keep routine small and efficient.
  uint16_t spindle_compute_pwm_value(float rpm) // Mega2560 PWM register is 16-bit.
  {
    253e:	4f 92       	push	r4
    2540:	5f 92       	push	r5
    2542:	6f 92       	push	r6
    2544:	7f 92       	push	r7
    2546:	8f 92       	push	r8
    2548:	9f 92       	push	r9
    254a:	af 92       	push	r10
    254c:	bf 92       	push	r11
    254e:	cf 92       	push	r12
    2550:	df 92       	push	r13
    2552:	ef 92       	push	r14
    2554:	ff 92       	push	r15
    2556:	6b 01       	movw	r12, r22
    2558:	7c 01       	movw	r14, r24
	uint16_t pwm_value;
	rpm *= (0.010*sys.spindle_speed_ovr); // Scale by spindle speed override value.
    255a:	60 91 1a 0c 	lds	r22, 0x0C1A	; 0x800c1a <sys+0x9>
    255e:	70 e0       	ldi	r23, 0x00	; 0
    2560:	80 e0       	ldi	r24, 0x00	; 0
    2562:	90 e0       	ldi	r25, 0x00	; 0
    2564:	0e 94 b0 3d 	call	0x7b60	; 0x7b60 <__floatsisf>
    2568:	2a e0       	ldi	r18, 0x0A	; 10
    256a:	37 ed       	ldi	r19, 0xD7	; 215
    256c:	43 e2       	ldi	r20, 0x23	; 35
    256e:	5c e3       	ldi	r21, 0x3C	; 60
    2570:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
    2574:	a7 01       	movw	r20, r14
    2576:	96 01       	movw	r18, r12
    2578:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
    257c:	2b 01       	movw	r4, r22
    257e:	3c 01       	movw	r6, r24
	// Calculate PWM register value based on rpm max/min settings and programmed rpm.
	if ((settings.rpm_min >= settings.rpm_max) || (rpm >= settings.rpm_max)) {
    2580:	80 90 fa 0e 	lds	r8, 0x0EFA	; 0x800efa <settings+0x41>
    2584:	90 90 fb 0e 	lds	r9, 0x0EFB	; 0x800efb <settings+0x42>
    2588:	a0 90 fc 0e 	lds	r10, 0x0EFC	; 0x800efc <settings+0x43>
    258c:	b0 90 fd 0e 	lds	r11, 0x0EFD	; 0x800efd <settings+0x44>
    2590:	c0 90 f6 0e 	lds	r12, 0x0EF6	; 0x800ef6 <settings+0x3d>
    2594:	d0 90 f7 0e 	lds	r13, 0x0EF7	; 0x800ef7 <settings+0x3e>
    2598:	e0 90 f8 0e 	lds	r14, 0x0EF8	; 0x800ef8 <settings+0x3f>
    259c:	f0 90 f9 0e 	lds	r15, 0x0EF9	; 0x800ef9 <settings+0x40>
    25a0:	a7 01       	movw	r20, r14
    25a2:	96 01       	movw	r18, r12
    25a4:	c5 01       	movw	r24, r10
    25a6:	b4 01       	movw	r22, r8
    25a8:	0e 94 11 3f 	call	0x7e22	; 0x7e22 <__gesf2>
    25ac:	88 23       	and	r24, r24
    25ae:	44 f4       	brge	.+16     	; 0x25c0 <spindle_compute_pwm_value+0x82>
    25b0:	a7 01       	movw	r20, r14
    25b2:	96 01       	movw	r18, r12
    25b4:	c3 01       	movw	r24, r6
    25b6:	b2 01       	movw	r22, r4
    25b8:	0e 94 11 3f 	call	0x7e22	; 0x7e22 <__gesf2>
    25bc:	88 23       	and	r24, r24
    25be:	5c f0       	brlt	.+22     	; 0x25d6 <spindle_compute_pwm_value+0x98>
	  // No PWM range possible. Set simple on/off spindle control pin state.
	  sys.spindle_speed = settings.rpm_max;
    25c0:	c0 92 1e 0c 	sts	0x0C1E, r12	; 0x800c1e <sys+0xd>
    25c4:	d0 92 1f 0c 	sts	0x0C1F, r13	; 0x800c1f <sys+0xe>
    25c8:	e0 92 20 0c 	sts	0x0C20, r14	; 0x800c20 <sys+0xf>
    25cc:	f0 92 21 0c 	sts	0x0C21, r15	; 0x800c21 <sys+0x10>
	  pwm_value = SPINDLE_PWM_MAX_VALUE;
    25d0:	80 e0       	ldi	r24, 0x00	; 0
    25d2:	94 e0       	ldi	r25, 0x04	; 4
    25d4:	4a c0       	rjmp	.+148    	; 0x266a <spindle_compute_pwm_value+0x12c>
	} else if (rpm <= settings.rpm_min) {
    25d6:	a5 01       	movw	r20, r10
    25d8:	94 01       	movw	r18, r8
    25da:	c3 01       	movw	r24, r6
    25dc:	b2 01       	movw	r22, r4
    25de:	0e 94 0e 3d 	call	0x7a1c	; 0x7a1c <__cmpsf2>
    25e2:	18 16       	cp	r1, r24
    25e4:	fc f0       	brlt	.+62     	; 0x2624 <spindle_compute_pwm_value+0xe6>
	  if (rpm == 0.0) { // S0 disables spindle
    25e6:	20 e0       	ldi	r18, 0x00	; 0
    25e8:	30 e0       	ldi	r19, 0x00	; 0
    25ea:	a9 01       	movw	r20, r18
    25ec:	c3 01       	movw	r24, r6
    25ee:	b2 01       	movw	r22, r4
    25f0:	0e 94 0e 3d 	call	0x7a1c	; 0x7a1c <__cmpsf2>
    25f4:	81 11       	cpse	r24, r1
    25f6:	0b c0       	rjmp	.+22     	; 0x260e <spindle_compute_pwm_value+0xd0>
		sys.spindle_speed = 0.0;
    25f8:	10 92 1e 0c 	sts	0x0C1E, r1	; 0x800c1e <sys+0xd>
    25fc:	10 92 1f 0c 	sts	0x0C1F, r1	; 0x800c1f <sys+0xe>
    2600:	10 92 20 0c 	sts	0x0C20, r1	; 0x800c20 <sys+0xf>
    2604:	10 92 21 0c 	sts	0x0C21, r1	; 0x800c21 <sys+0x10>
		pwm_value = SPINDLE_PWM_OFF_VALUE;
    2608:	80 e0       	ldi	r24, 0x00	; 0
    260a:	90 e0       	ldi	r25, 0x00	; 0
    260c:	2e c0       	rjmp	.+92     	; 0x266a <spindle_compute_pwm_value+0x12c>
	  } else { // Set minimum PWM output
		sys.spindle_speed = settings.rpm_min;
    260e:	80 92 1e 0c 	sts	0x0C1E, r8	; 0x800c1e <sys+0xd>
    2612:	90 92 1f 0c 	sts	0x0C1F, r9	; 0x800c1f <sys+0xe>
    2616:	a0 92 20 0c 	sts	0x0C20, r10	; 0x800c20 <sys+0xf>
    261a:	b0 92 21 0c 	sts	0x0C21, r11	; 0x800c21 <sys+0x10>
		pwm_value = SPINDLE_PWM_MIN_VALUE;
    261e:	81 e0       	ldi	r24, 0x01	; 1
    2620:	90 e0       	ldi	r25, 0x00	; 0
    2622:	23 c0       	rjmp	.+70     	; 0x266a <spindle_compute_pwm_value+0x12c>
	  }
	} else { 
	  // Compute intermediate PWM value with linear spindle speed model.
	  // NOTE: A nonlinear model could be installed here, if required, but keep it VERY light-weight.
	  sys.spindle_speed = rpm;
    2624:	40 92 1e 0c 	sts	0x0C1E, r4	; 0x800c1e <sys+0xd>
    2628:	50 92 1f 0c 	sts	0x0C1F, r5	; 0x800c1f <sys+0xe>
    262c:	60 92 20 0c 	sts	0x0C20, r6	; 0x800c20 <sys+0xf>
    2630:	70 92 21 0c 	sts	0x0C21, r7	; 0x800c21 <sys+0x10>
	  pwm_value = floor((rpm-settings.rpm_min)*pwm_gradient) + SPINDLE_PWM_MIN_VALUE;
    2634:	a5 01       	movw	r20, r10
    2636:	94 01       	movw	r18, r8
    2638:	c3 01       	movw	r24, r6
    263a:	b2 01       	movw	r22, r4
    263c:	0e 94 34 3c 	call	0x7868	; 0x7868 <__subsf3>
    2640:	20 91 00 02 	lds	r18, 0x0200	; 0x800200 <_edata>
    2644:	30 91 01 02 	lds	r19, 0x0201	; 0x800201 <_edata+0x1>
    2648:	40 91 02 02 	lds	r20, 0x0202	; 0x800202 <_edata+0x2>
    264c:	50 91 03 02 	lds	r21, 0x0203	; 0x800203 <_edata+0x3>
    2650:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
    2654:	0e 94 eb 3d 	call	0x7bd6	; 0x7bd6 <floor>
    2658:	20 e0       	ldi	r18, 0x00	; 0
    265a:	30 e0       	ldi	r19, 0x00	; 0
    265c:	40 e8       	ldi	r20, 0x80	; 128
    265e:	5f e3       	ldi	r21, 0x3F	; 63
    2660:	0e 94 35 3c 	call	0x786a	; 0x786a <__addsf3>
    2664:	0e 94 82 3d 	call	0x7b04	; 0x7b04 <__fixunssfsi>
    2668:	cb 01       	movw	r24, r22
	}
	return(pwm_value);
  }
    266a:	ff 90       	pop	r15
    266c:	ef 90       	pop	r14
    266e:	df 90       	pop	r13
    2670:	cf 90       	pop	r12
    2672:	bf 90       	pop	r11
    2674:	af 90       	pop	r10
    2676:	9f 90       	pop	r9
    2678:	8f 90       	pop	r8
    267a:	7f 90       	pop	r7
    267c:	6f 90       	pop	r6
    267e:	5f 90       	pop	r5
    2680:	4f 90       	pop	r4
    2682:	08 95       	ret

00002684 <spindle_set_state>:
// Immediately sets spindle running state with direction and spindle rpm via PWM, if enabled.
// Called by g-code parser spindle_sync(), parking retract and restore, g-code program end,
// sleep, and spindle stop override.
void spindle_set_state(uint8_t state, float rpm)
{
  if (sys.abort) { return; } // Block during abort.
    2684:	90 91 12 0c 	lds	r25, 0x0C12	; 0x800c12 <sys+0x1>
    2688:	91 11       	cpse	r25, r1
    268a:	29 c0       	rjmp	.+82     	; 0x26de <spindle_set_state+0x5a>
  if (state == SPINDLE_DISABLE) { // Halt or set spindle direction and rpm.
    268c:	81 11       	cpse	r24, r1
    268e:	0a c0       	rjmp	.+20     	; 0x26a4 <spindle_set_state+0x20>
  
    sys.spindle_speed = 0.0;
    2690:	10 92 1e 0c 	sts	0x0C1E, r1	; 0x800c1e <sys+0xd>
    2694:	10 92 1f 0c 	sts	0x0C1F, r1	; 0x800c1f <sys+0xe>
    2698:	10 92 20 0c 	sts	0x0C20, r1	; 0x800c20 <sys+0xf>
    269c:	10 92 21 0c 	sts	0x0C21, r1	; 0x800c21 <sys+0x10>
    spindle_stop();
    26a0:	f6 de       	rcall	.-532    	; 0x248e <spindle_stop>
    26a2:	1b c0       	rjmp	.+54     	; 0x26da <spindle_set_state+0x56>
  
  } else {
  
    if (state == SPINDLE_ENABLE_CW) {
    26a4:	80 31       	cpi	r24, 0x10	; 16
    26a6:	21 f4       	brne	.+8      	; 0x26b0 <spindle_set_state+0x2c>
      SPINDLE_DIRECTION_PORT &= ~(1<<SPINDLE_DIRECTION_BIT);
    26a8:	9e b1       	in	r25, 0x0e	; 14
    26aa:	97 7f       	andi	r25, 0xF7	; 247
    26ac:	9e b9       	out	0x0e, r25	; 14
    26ae:	03 c0       	rjmp	.+6      	; 0x26b6 <spindle_set_state+0x32>
    } else {
      SPINDLE_DIRECTION_PORT |= (1<<SPINDLE_DIRECTION_BIT);
    26b0:	9e b1       	in	r25, 0x0e	; 14
    26b2:	98 60       	ori	r25, 0x08	; 8
    26b4:	9e b9       	out	0x0e, r25	; 14
    }

    // NOTE: Assumes all calls to this function is when Grbl is not moving or must remain off.
    if (settings.flags & BITFLAG_LASER_MODE) { 
    26b6:	90 91 fe 0e 	lds	r25, 0x0EFE	; 0x800efe <settings+0x45>
    26ba:	91 ff       	sbrs	r25, 1
    26bc:	05 c0       	rjmp	.+10     	; 0x26c8 <spindle_set_state+0x44>
      if (state == SPINDLE_ENABLE_CCW) { rpm = 0.0; } // TODO: May need to be rpm_min*(100/MAX_SPINDLE_SPEED_OVERRIDE);
    26be:	80 32       	cpi	r24, 0x20	; 32
    26c0:	19 f4       	brne	.+6      	; 0x26c8 <spindle_set_state+0x44>
    26c2:	40 e0       	ldi	r20, 0x00	; 0
    26c4:	50 e0       	ldi	r21, 0x00	; 0
    26c6:	ba 01       	movw	r22, r20
    }
    spindle_set_speed(spindle_compute_pwm_value(rpm));
    26c8:	cb 01       	movw	r24, r22
    26ca:	ba 01       	movw	r22, r20
    26cc:	38 df       	rcall	.-400    	; 0x253e <spindle_compute_pwm_value>
    26ce:	25 df       	rcall	.-438    	; 0x251a <spindle_set_speed>

    #ifndef SPINDLE_ENABLE_OFF_WITH_ZERO_SPEED
      #ifdef INVERT_SPINDLE_ENABLE_PIN
        SPINDLE_ENABLE_PORT &= ~(1<<SPINDLE_ENABLE_BIT);
      #else
        SPINDLE_ENABLE_PORT |= (1<<SPINDLE_ENABLE_BIT);
    26d0:	e2 e0       	ldi	r30, 0x02	; 2
    26d2:	f1 e0       	ldi	r31, 0x01	; 1
    26d4:	80 81       	ld	r24, Z
    26d6:	88 60       	ori	r24, 0x08	; 8
    26d8:	80 83       	st	Z, r24
      #endif   
    #endif
  
  }
  
  sys.report_ovr_counter = 0; // Set to report change immediately
    26da:	10 92 1c 0c 	sts	0x0C1C, r1	; 0x800c1c <sys+0xb>
    26de:	08 95       	ret

000026e0 <spindle_sync>:


// G-code parser entry-point for setting spindle state. Forces a planner buffer sync and bails 
// if an abort or check-mode is active.
void spindle_sync(uint8_t state, float rpm)
{
    26e0:	cf 92       	push	r12
    26e2:	df 92       	push	r13
    26e4:	ef 92       	push	r14
    26e6:	ff 92       	push	r15
    26e8:	cf 93       	push	r28
  if (sys.state == STATE_CHECK_MODE) { return; }
    26ea:	90 91 11 0c 	lds	r25, 0x0C11	; 0x800c11 <sys>
    26ee:	92 30       	cpi	r25, 0x02	; 2
    26f0:	41 f0       	breq	.+16     	; 0x2702 <spindle_sync+0x22>
    26f2:	6a 01       	movw	r12, r20
    26f4:	7b 01       	movw	r14, r22
    26f6:	c8 2f       	mov	r28, r24
  protocol_buffer_synchronize(); // Empty planner buffer to ensure spindle is set when programmed.
    26f8:	dd d4       	rcall	.+2490   	; 0x30b4 <protocol_buffer_synchronize>
  spindle_set_state(state,rpm);
    26fa:	b7 01       	movw	r22, r14
    26fc:	a6 01       	movw	r20, r12
    26fe:	8c 2f       	mov	r24, r28
    2700:	c1 df       	rcall	.-126    	; 0x2684 <spindle_set_state>
}
    2702:	cf 91       	pop	r28
    2704:	ff 90       	pop	r15
    2706:	ef 90       	pop	r14
    2708:	df 90       	pop	r13
    270a:	cf 90       	pop	r12
    270c:	08 95       	ret

0000270e <coolant_get_state>:
{
  uint8_t cl_state = COOLANT_STATE_DISABLE;
  #ifdef INVERT_COOLANT_FLOOD_PIN
    if (bit_isfalse(COOLANT_FLOOD_PORT,(1 << COOLANT_FLOOD_BIT))) {
  #else
    if (bit_istrue(COOLANT_FLOOD_PORT,(1 << COOLANT_FLOOD_BIT))) {
    270e:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x7c0102>
    2712:	85 fd       	sbrc	r24, 5
    2714:	02 c0       	rjmp	.+4      	; 0x271a <coolant_get_state+0xc>


// Returns current coolant output state. Overrides may alter it from programmed state.
uint8_t coolant_get_state()
{
  uint8_t cl_state = COOLANT_STATE_DISABLE;
    2716:	80 e0       	ldi	r24, 0x00	; 0
    2718:	01 c0       	rjmp	.+2      	; 0x271c <coolant_get_state+0xe>
  #ifdef INVERT_COOLANT_FLOOD_PIN
    if (bit_isfalse(COOLANT_FLOOD_PORT,(1 << COOLANT_FLOOD_BIT))) {
  #else
    if (bit_istrue(COOLANT_FLOOD_PORT,(1 << COOLANT_FLOOD_BIT))) {
  #endif
    cl_state |= COOLANT_STATE_FLOOD;
    271a:	80 e4       	ldi	r24, 0x40	; 64
  }
  #ifdef INVERT_COOLANT_MIST_PIN
    if (bit_isfalse(COOLANT_MIST_PORT,(1 << COOLANT_MIST_BIT))) {
  #else
    if (bit_istrue(COOLANT_MIST_PORT,(1 << COOLANT_MIST_BIT))) {
    271c:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x7c0102>
    2720:	96 fd       	sbrc	r25, 6
  #endif
    cl_state |= COOLANT_STATE_MIST;
    2722:	80 68       	ori	r24, 0x80	; 128
  }
  return(cl_state);
}
    2724:	08 95       	ret

00002726 <coolant_stop>:
void coolant_stop()
{
  #ifdef INVERT_COOLANT_FLOOD_PIN
    COOLANT_FLOOD_PORT |= (1 << COOLANT_FLOOD_BIT);
  #else
    COOLANT_FLOOD_PORT &= ~(1 << COOLANT_FLOOD_BIT);
    2726:	e2 e0       	ldi	r30, 0x02	; 2
    2728:	f1 e0       	ldi	r31, 0x01	; 1
    272a:	80 81       	ld	r24, Z
    272c:	8f 7d       	andi	r24, 0xDF	; 223
    272e:	80 83       	st	Z, r24
  #endif
  #ifdef INVERT_COOLANT_MIST_PIN
    COOLANT_MIST_PORT |= (1 << COOLANT_MIST_BIT);
  #else
    COOLANT_MIST_PORT &= ~(1 << COOLANT_MIST_BIT);
    2730:	80 81       	ld	r24, Z
    2732:	8f 7b       	andi	r24, 0xBF	; 191
    2734:	80 83       	st	Z, r24
    2736:	08 95       	ret

00002738 <coolant_init>:
#include "grbl.h"


void coolant_init()
{
  COOLANT_FLOOD_DDR |= (1 << COOLANT_FLOOD_BIT); // Configure as output pin.
    2738:	e1 e0       	ldi	r30, 0x01	; 1
    273a:	f1 e0       	ldi	r31, 0x01	; 1
    273c:	80 81       	ld	r24, Z
    273e:	80 62       	ori	r24, 0x20	; 32
    2740:	80 83       	st	Z, r24
  COOLANT_MIST_DDR |= (1 << COOLANT_MIST_BIT); // Configure as output pin.
    2742:	80 81       	ld	r24, Z
    2744:	80 64       	ori	r24, 0x40	; 64
    2746:	80 83       	st	Z, r24
  coolant_stop();
    2748:	ee cf       	rjmp	.-36     	; 0x2726 <coolant_stop>
    274a:	08 95       	ret

0000274c <coolant_set_state>:
// if enabled. Also sets a flag to report an update to a coolant state.
// Called by coolant toggle override, parking restore, parking retract, sleep mode, g-code
// parser program end, and g-code parser coolant_sync().
void coolant_set_state(uint8_t mode)
{
  if (sys.abort) { return; } // Block during abort.  
    274c:	90 91 12 0c 	lds	r25, 0x0C12	; 0x800c12 <sys+0x1>
    2750:	91 11       	cpse	r25, r1
    2752:	1c c0       	rjmp	.+56     	; 0x278c <coolant_set_state+0x40>
  
  if (mode & COOLANT_FLOOD_ENABLE) {
    2754:	86 ff       	sbrs	r24, 6
    2756:	06 c0       	rjmp	.+12     	; 0x2764 <coolant_set_state+0x18>
    #ifdef INVERT_COOLANT_FLOOD_PIN
      COOLANT_FLOOD_PORT &= ~(1 << COOLANT_FLOOD_BIT);
    #else
      COOLANT_FLOOD_PORT |= (1 << COOLANT_FLOOD_BIT);
    2758:	e2 e0       	ldi	r30, 0x02	; 2
    275a:	f1 e0       	ldi	r31, 0x01	; 1
    275c:	90 81       	ld	r25, Z
    275e:	90 62       	ori	r25, 0x20	; 32
    2760:	90 83       	st	Z, r25
    2762:	05 c0       	rjmp	.+10     	; 0x276e <coolant_set_state+0x22>
    #endif
	} else {
	  #ifdef INVERT_COOLANT_FLOOD_PIN
			COOLANT_FLOOD_PORT |= (1 << COOLANT_FLOOD_BIT);
		#else
			COOLANT_FLOOD_PORT &= ~(1 << COOLANT_FLOOD_BIT);
    2764:	e2 e0       	ldi	r30, 0x02	; 2
    2766:	f1 e0       	ldi	r31, 0x01	; 1
    2768:	90 81       	ld	r25, Z
    276a:	9f 7d       	andi	r25, 0xDF	; 223
    276c:	90 83       	st	Z, r25
		#endif
	}
  
	if (mode & COOLANT_MIST_ENABLE) {
    276e:	88 23       	and	r24, r24
    2770:	34 f4       	brge	.+12     	; 0x277e <coolant_set_state+0x32>
		#ifdef INVERT_COOLANT_MIST_PIN
			COOLANT_MIST_PORT &= ~(1 << COOLANT_MIST_BIT);
		#else
			COOLANT_MIST_PORT |= (1 << COOLANT_MIST_BIT);
    2772:	e2 e0       	ldi	r30, 0x02	; 2
    2774:	f1 e0       	ldi	r31, 0x01	; 1
    2776:	80 81       	ld	r24, Z
    2778:	80 64       	ori	r24, 0x40	; 64
    277a:	80 83       	st	Z, r24
    277c:	05 c0       	rjmp	.+10     	; 0x2788 <coolant_set_state+0x3c>
		#endif
	} else {
		#ifdef INVERT_COOLANT_MIST_PIN
			COOLANT_MIST_PORT |= (1 << COOLANT_MIST_BIT);
		#else
			COOLANT_MIST_PORT &= ~(1 << COOLANT_MIST_BIT);
    277e:	e2 e0       	ldi	r30, 0x02	; 2
    2780:	f1 e0       	ldi	r31, 0x01	; 1
    2782:	80 81       	ld	r24, Z
    2784:	8f 7b       	andi	r24, 0xBF	; 191
    2786:	80 83       	st	Z, r24
		#endif
	}
	
  sys.report_ovr_counter = 0; // Set to report change immediately
    2788:	10 92 1c 0c 	sts	0x0C1C, r1	; 0x800c1c <sys+0xb>
    278c:	08 95       	ret

0000278e <coolant_sync>:


// G-code parser entry-point for setting coolant state. Forces a planner buffer sync and bails 
// if an abort or check-mode is active.
void coolant_sync(uint8_t mode)
{
    278e:	cf 93       	push	r28
  if (sys.state == STATE_CHECK_MODE) { return; }
    2790:	90 91 11 0c 	lds	r25, 0x0C11	; 0x800c11 <sys>
    2794:	92 30       	cpi	r25, 0x02	; 2
    2796:	21 f0       	breq	.+8      	; 0x27a0 <coolant_sync+0x12>
    2798:	c8 2f       	mov	r28, r24
  protocol_buffer_synchronize(); // Ensure coolant turns on when specified in program.
    279a:	8c d4       	rcall	.+2328   	; 0x30b4 <protocol_buffer_synchronize>
  coolant_set_state(mode);
    279c:	8c 2f       	mov	r24, r28
    279e:	d6 df       	rcall	.-84     	; 0x274c <coolant_set_state>
}
    27a0:	cf 91       	pop	r28
    27a2:	08 95       	ret

000027a4 <serial_get_rx_buffer_available>:
uint8_t serial_get_tx_buffer_count()
{
  uint8_t ttail = serial_tx_buffer_tail; // Copy to limit multiple calls to volatile
  if (serial_tx_buffer_head >= ttail) { return(serial_tx_buffer_head-ttail); }
  return (TX_RING_BUFFER - (ttail-serial_tx_buffer_head));
}
    27a4:	80 91 06 02 	lds	r24, 0x0206	; 0x800206 <serial_rx_buffer_tail>
    27a8:	90 91 07 02 	lds	r25, 0x0207	; 0x800207 <serial_rx_buffer_head>
    27ac:	98 17       	cp	r25, r24
    27ae:	20 f0       	brcs	.+8      	; 0x27b8 <serial_get_rx_buffer_available+0x14>
    27b0:	98 1b       	sub	r25, r24
    27b2:	89 2f       	mov	r24, r25
    27b4:	80 95       	com	r24
    27b6:	08 95       	ret
    27b8:	89 1b       	sub	r24, r25
    27ba:	81 50       	subi	r24, 0x01	; 1
    27bc:	08 95       	ret

000027be <serial_init>:
  #if BAUD_RATE < 57600
    uint16_t UBRR0_value = ((F_CPU / (8L * BAUD_RATE)) - 1)/2 ;
    UCSR0A &= ~(1 << U2X0); // baud doubler off  - Only needed on Uno XXX
  #else
    uint16_t UBRR0_value = ((F_CPU / (4L * BAUD_RATE)) - 1)/2;
    UCSR0A |= (1 << U2X0);  // baud doubler on for high baud rates, i.e. 115200
    27be:	e0 ec       	ldi	r30, 0xC0	; 192
    27c0:	f0 e0       	ldi	r31, 0x00	; 0
    27c2:	80 81       	ld	r24, Z
    27c4:	82 60       	ori	r24, 0x02	; 2
    27c6:	80 83       	st	Z, r24
  #endif
  UBRR0H = UBRR0_value >> 8;
    27c8:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7c00c5>
  UBRR0L = UBRR0_value;
    27cc:	80 e1       	ldi	r24, 0x10	; 16
    27ce:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7c00c4>

  // enable rx, tx, and interrupt on complete reception of a byte
  UCSR0B |= (1<<RXEN0 | 1<<TXEN0 | 1<<RXCIE0);
    27d2:	e1 ec       	ldi	r30, 0xC1	; 193
    27d4:	f0 e0       	ldi	r31, 0x00	; 0
    27d6:	80 81       	ld	r24, Z
    27d8:	88 69       	ori	r24, 0x98	; 152
    27da:	80 83       	st	Z, r24
    27dc:	08 95       	ret

000027de <serial_write>:


// Writes one byte to the TX serial buffer. Called by main program.
void serial_write(uint8_t data) {
  // Calculate next head
  uint8_t next_head = serial_tx_buffer_head + 1;
    27de:	e0 91 05 02 	lds	r30, 0x0205	; 0x800205 <serial_tx_buffer_head>
    27e2:	21 e0       	ldi	r18, 0x01	; 1
    27e4:	2e 0f       	add	r18, r30
  if (next_head == TX_RING_BUFFER) { next_head = 0; }

  // Wait until there is space in the buffer
  while (next_head == serial_tx_buffer_tail) {
    27e6:	04 c0       	rjmp	.+8      	; 0x27f0 <serial_write+0x12>
    // TODO: Restructure st_prep_buffer() calls to be executed here during a long print.
    if (sys_rt_exec_state & EXEC_RESET) { return; } // Only check for abort to avoid an endless loop.
    27e8:	90 91 23 0c 	lds	r25, 0x0C23	; 0x800c23 <sys_rt_exec_state>
    27ec:	94 fd       	sbrc	r25, 4
    27ee:	0f c0       	rjmp	.+30     	; 0x280e <serial_write+0x30>
  // Calculate next head
  uint8_t next_head = serial_tx_buffer_head + 1;
  if (next_head == TX_RING_BUFFER) { next_head = 0; }

  // Wait until there is space in the buffer
  while (next_head == serial_tx_buffer_tail) {
    27f0:	90 91 04 02 	lds	r25, 0x0204	; 0x800204 <serial_tx_buffer_tail>
    27f4:	29 17       	cp	r18, r25
    27f6:	c1 f3       	breq	.-16     	; 0x27e8 <serial_write+0xa>
    // TODO: Restructure st_prep_buffer() calls to be executed here during a long print.
    if (sys_rt_exec_state & EXEC_RESET) { return; } // Only check for abort to avoid an endless loop.
  }

  // Store data and advance head
  serial_tx_buffer[serial_tx_buffer_head] = data;
    27f8:	f0 e0       	ldi	r31, 0x00	; 0
    27fa:	e7 54       	subi	r30, 0x47	; 71
    27fc:	f3 4f       	sbci	r31, 0xF3	; 243
    27fe:	80 83       	st	Z, r24
  serial_tx_buffer_head = next_head;
    2800:	20 93 05 02 	sts	0x0205, r18	; 0x800205 <serial_tx_buffer_head>

  // Enable Data Register Empty Interrupt to make sure tx-streaming is running
  UCSR0B |=  (1 << UDRIE0);
    2804:	e1 ec       	ldi	r30, 0xC1	; 193
    2806:	f0 e0       	ldi	r31, 0x00	; 0
    2808:	80 81       	ld	r24, Z
    280a:	80 62       	ori	r24, 0x20	; 32
    280c:	80 83       	st	Z, r24
    280e:	08 95       	ret

00002810 <__vector_26>:
}


// Data Register Empty Interrupt handler
ISR(SERIAL_UDRE)
{
    2810:	1f 92       	push	r1
    2812:	0f 92       	push	r0
    2814:	0f b6       	in	r0, 0x3f	; 63
    2816:	0f 92       	push	r0
    2818:	11 24       	eor	r1, r1
    281a:	0b b6       	in	r0, 0x3b	; 59
    281c:	0f 92       	push	r0
    281e:	8f 93       	push	r24
    2820:	9f 93       	push	r25
    2822:	ef 93       	push	r30
    2824:	ff 93       	push	r31
  uint8_t tail = serial_tx_buffer_tail; // Temporary serial_tx_buffer_tail (to optimize for volatile)
    2826:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <serial_tx_buffer_tail>

  // Send a byte from the buffer
  UDR0 = serial_tx_buffer[tail];
    282a:	e8 2f       	mov	r30, r24
    282c:	f0 e0       	ldi	r31, 0x00	; 0
    282e:	e7 54       	subi	r30, 0x47	; 71
    2830:	f3 4f       	sbci	r31, 0xF3	; 243
    2832:	90 81       	ld	r25, Z
    2834:	90 93 c6 00 	sts	0x00C6, r25	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7c00c6>

  // Update tail position
  tail++;
    2838:	8f 5f       	subi	r24, 0xFF	; 255
  if (tail == TX_RING_BUFFER) { tail = 0; }

  serial_tx_buffer_tail = tail;
    283a:	80 93 04 02 	sts	0x0204, r24	; 0x800204 <serial_tx_buffer_tail>

  // Turn off Data Register Empty Interrupt to stop tx-streaming if this concludes the transfer
  if (tail == serial_tx_buffer_head) { UCSR0B &= ~(1 << UDRIE0); }
    283e:	90 91 05 02 	lds	r25, 0x0205	; 0x800205 <serial_tx_buffer_head>
    2842:	89 13       	cpse	r24, r25
    2844:	05 c0       	rjmp	.+10     	; 0x2850 <__vector_26+0x40>
    2846:	e1 ec       	ldi	r30, 0xC1	; 193
    2848:	f0 e0       	ldi	r31, 0x00	; 0
    284a:	80 81       	ld	r24, Z
    284c:	8f 7d       	andi	r24, 0xDF	; 223
    284e:	80 83       	st	Z, r24
}
    2850:	ff 91       	pop	r31
    2852:	ef 91       	pop	r30
    2854:	9f 91       	pop	r25
    2856:	8f 91       	pop	r24
    2858:	0f 90       	pop	r0
    285a:	0b be       	out	0x3b, r0	; 59
    285c:	0f 90       	pop	r0
    285e:	0f be       	out	0x3f, r0	; 63
    2860:	0f 90       	pop	r0
    2862:	1f 90       	pop	r1
    2864:	18 95       	reti

00002866 <serial_read>:


// Fetches the first byte in the serial read buffer. Called by main program.
uint8_t serial_read()
{
  uint8_t tail = serial_rx_buffer_tail; // Temporary serial_rx_buffer_tail (to optimize for volatile)
    2866:	90 91 06 02 	lds	r25, 0x0206	; 0x800206 <serial_rx_buffer_tail>
  if (serial_rx_buffer_head == tail) {
    286a:	80 91 07 02 	lds	r24, 0x0207	; 0x800207 <serial_rx_buffer_head>
    286e:	98 17       	cp	r25, r24
    2870:	49 f0       	breq	.+18     	; 0x2884 <serial_read+0x1e>
    return SERIAL_NO_DATA;
  } else {
    uint8_t data = serial_rx_buffer[tail];
    2872:	e9 2f       	mov	r30, r25
    2874:	f0 e0       	ldi	r31, 0x00	; 0
    2876:	e7 54       	subi	r30, 0x47	; 71
    2878:	f2 4f       	sbci	r31, 0xF2	; 242
    287a:	80 81       	ld	r24, Z

    tail++;
    287c:	9f 5f       	subi	r25, 0xFF	; 255
    if (tail == RX_RING_BUFFER) { tail = 0; }
    serial_rx_buffer_tail = tail;
    287e:	90 93 06 02 	sts	0x0206, r25	; 0x800206 <serial_rx_buffer_tail>

    return data;
    2882:	08 95       	ret
// Fetches the first byte in the serial read buffer. Called by main program.
uint8_t serial_read()
{
  uint8_t tail = serial_rx_buffer_tail; // Temporary serial_rx_buffer_tail (to optimize for volatile)
  if (serial_rx_buffer_head == tail) {
    return SERIAL_NO_DATA;
    2884:	8f ef       	ldi	r24, 0xFF	; 255
    if (tail == RX_RING_BUFFER) { tail = 0; }
    serial_rx_buffer_tail = tail;

    return data;
  }
}
    2886:	08 95       	ret

00002888 <__vector_25>:


ISR(SERIAL_RX)
{
    2888:	1f 92       	push	r1
    288a:	0f 92       	push	r0
    288c:	0f b6       	in	r0, 0x3f	; 63
    288e:	0f 92       	push	r0
    2890:	11 24       	eor	r1, r1
    2892:	0b b6       	in	r0, 0x3b	; 59
    2894:	0f 92       	push	r0
    2896:	2f 93       	push	r18
    2898:	3f 93       	push	r19
    289a:	4f 93       	push	r20
    289c:	5f 93       	push	r21
    289e:	6f 93       	push	r22
    28a0:	7f 93       	push	r23
    28a2:	8f 93       	push	r24
    28a4:	9f 93       	push	r25
    28a6:	af 93       	push	r26
    28a8:	bf 93       	push	r27
    28aa:	ef 93       	push	r30
    28ac:	ff 93       	push	r31
  uint8_t data = UDR0;
    28ae:	e0 91 c6 00 	lds	r30, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7c00c6>
  uint8_t next_head;

  // Pick off realtime command characters directly from the serial stream. These characters are
  // not passed into the main buffer, but these set system state flag bits for realtime execution.
  switch (data) {
    28b2:	e1 32       	cpi	r30, 0x21	; 33
    28b4:	a1 f0       	breq	.+40     	; 0x28de <__vector_25+0x56>
    28b6:	18 f4       	brcc	.+6      	; 0x28be <__vector_25+0x36>
    28b8:	e8 31       	cpi	r30, 0x18	; 24
    28ba:	31 f0       	breq	.+12     	; 0x28c8 <__vector_25+0x40>
    28bc:	14 c0       	rjmp	.+40     	; 0x28e6 <__vector_25+0x5e>
    28be:	ef 33       	cpi	r30, 0x3F	; 63
    28c0:	31 f0       	breq	.+12     	; 0x28ce <__vector_25+0x46>
    28c2:	ee 37       	cpi	r30, 0x7E	; 126
    28c4:	41 f0       	breq	.+16     	; 0x28d6 <__vector_25+0x4e>
    28c6:	0f c0       	rjmp	.+30     	; 0x28e6 <__vector_25+0x5e>
    case CMD_RESET:         mc_reset(); break; // Call motion control reset routine.
    28c8:	0e 94 ac 06 	call	0xd58	; 0xd58 <mc_reset>
    28cc:	81 c0       	rjmp	.+258    	; 0x29d0 <__vector_25+0x148>
    case CMD_STATUS_REPORT: system_set_exec_state_flag(EXEC_STATUS_REPORT); break; // Set as true
    28ce:	81 e0       	ldi	r24, 0x01	; 1
    28d0:	0e 94 4b 39 	call	0x7296	; 0x7296 <system_set_exec_state_flag>
    28d4:	7d c0       	rjmp	.+250    	; 0x29d0 <__vector_25+0x148>
    case CMD_CYCLE_START:   system_set_exec_state_flag(EXEC_CYCLE_START); break; // Set as true
    28d6:	82 e0       	ldi	r24, 0x02	; 2
    28d8:	0e 94 4b 39 	call	0x7296	; 0x7296 <system_set_exec_state_flag>
    28dc:	79 c0       	rjmp	.+242    	; 0x29d0 <__vector_25+0x148>
    case CMD_FEED_HOLD:     system_set_exec_state_flag(EXEC_FEED_HOLD); break; // Set as true
    28de:	88 e0       	ldi	r24, 0x08	; 8
    28e0:	0e 94 4b 39 	call	0x7296	; 0x7296 <system_set_exec_state_flag>
    28e4:	75 c0       	rjmp	.+234    	; 0x29d0 <__vector_25+0x148>
    default :
      if (data > 0x7F) { // Real-time control characters are extended ACSII only.
    28e6:	ee 23       	and	r30, r30
    28e8:	0c f0       	brlt	.+2      	; 0x28ec <__vector_25+0x64>
    28ea:	64 c0       	rjmp	.+200    	; 0x29b4 <__vector_25+0x12c>
        switch(data) {
    28ec:	8e 2f       	mov	r24, r30
    28ee:	90 e0       	ldi	r25, 0x00	; 0
    28f0:	fc 01       	movw	r30, r24
    28f2:	e4 58       	subi	r30, 0x84	; 132
    28f4:	f1 09       	sbc	r31, r1
    28f6:	ee 31       	cpi	r30, 0x1E	; 30
    28f8:	f1 05       	cpc	r31, r1
    28fa:	08 f0       	brcs	.+2      	; 0x28fe <__vector_25+0x76>
    28fc:	69 c0       	rjmp	.+210    	; 0x29d0 <__vector_25+0x148>
    28fe:	88 27       	eor	r24, r24
    2900:	eb 5f       	subi	r30, 0xFB	; 251
    2902:	fe 4f       	sbci	r31, 0xFE	; 254
    2904:	8f 4f       	sbci	r24, 0xFF	; 255
    2906:	0c 94 5b 40 	jmp	0x80b6	; 0x80b6 <__tablejump2__>
          case CMD_SAFETY_DOOR:   system_set_exec_state_flag(EXEC_SAFETY_DOOR); break; // Set as true
    290a:	80 e2       	ldi	r24, 0x20	; 32
    290c:	0e 94 4b 39 	call	0x7296	; 0x7296 <system_set_exec_state_flag>
    2910:	5f c0       	rjmp	.+190    	; 0x29d0 <__vector_25+0x148>
          case CMD_JOG_CANCEL:   
            if (sys.state & STATE_JOG) { // Block all other states from invoking motion cancel.
    2912:	80 91 11 0c 	lds	r24, 0x0C11	; 0x800c11 <sys>
    2916:	85 ff       	sbrs	r24, 5
    2918:	5b c0       	rjmp	.+182    	; 0x29d0 <__vector_25+0x148>
              system_set_exec_state_flag(EXEC_MOTION_CANCEL); 
    291a:	80 e4       	ldi	r24, 0x40	; 64
    291c:	0e 94 4b 39 	call	0x7296	; 0x7296 <system_set_exec_state_flag>
    2920:	57 c0       	rjmp	.+174    	; 0x29d0 <__vector_25+0x148>
            }
            break; 
          #ifdef DEBUG
            case CMD_DEBUG_REPORT: {uint8_t sreg = SREG; cli(); bit_true(sys_rt_exec_debug,EXEC_DEBUG_REPORT); SREG = sreg;} break;
    2922:	9f b7       	in	r25, 0x3f	; 63
    2924:	f8 94       	cli
    2926:	80 91 3e 0c 	lds	r24, 0x0C3E	; 0x800c3e <sys_rt_exec_debug>
    292a:	81 60       	ori	r24, 0x01	; 1
    292c:	80 93 3e 0c 	sts	0x0C3E, r24	; 0x800c3e <sys_rt_exec_debug>
    2930:	9f bf       	out	0x3f, r25	; 63
    2932:	4e c0       	rjmp	.+156    	; 0x29d0 <__vector_25+0x148>
          #endif
          case CMD_FEED_OVR_RESET: system_set_exec_motion_override_flag(EXEC_FEED_OVR_RESET); break;
    2934:	81 e0       	ldi	r24, 0x01	; 1
    2936:	0e 94 b0 3b 	call	0x7760	; 0x7760 <system_set_exec_motion_override_flag>
    293a:	4a c0       	rjmp	.+148    	; 0x29d0 <__vector_25+0x148>
          case CMD_FEED_OVR_COARSE_PLUS: system_set_exec_motion_override_flag(EXEC_FEED_OVR_COARSE_PLUS); break;
    293c:	82 e0       	ldi	r24, 0x02	; 2
    293e:	0e 94 b0 3b 	call	0x7760	; 0x7760 <system_set_exec_motion_override_flag>
    2942:	46 c0       	rjmp	.+140    	; 0x29d0 <__vector_25+0x148>
          case CMD_FEED_OVR_COARSE_MINUS: system_set_exec_motion_override_flag(EXEC_FEED_OVR_COARSE_MINUS); break;
    2944:	84 e0       	ldi	r24, 0x04	; 4
    2946:	0e 94 b0 3b 	call	0x7760	; 0x7760 <system_set_exec_motion_override_flag>
    294a:	42 c0       	rjmp	.+132    	; 0x29d0 <__vector_25+0x148>
          case CMD_FEED_OVR_FINE_PLUS: system_set_exec_motion_override_flag(EXEC_FEED_OVR_FINE_PLUS); break;
    294c:	88 e0       	ldi	r24, 0x08	; 8
    294e:	0e 94 b0 3b 	call	0x7760	; 0x7760 <system_set_exec_motion_override_flag>
    2952:	3e c0       	rjmp	.+124    	; 0x29d0 <__vector_25+0x148>
          case CMD_FEED_OVR_FINE_MINUS: system_set_exec_motion_override_flag(EXEC_FEED_OVR_FINE_MINUS); break;
    2954:	80 e1       	ldi	r24, 0x10	; 16
    2956:	0e 94 b0 3b 	call	0x7760	; 0x7760 <system_set_exec_motion_override_flag>
    295a:	3a c0       	rjmp	.+116    	; 0x29d0 <__vector_25+0x148>
          case CMD_RAPID_OVR_RESET: system_set_exec_motion_override_flag(EXEC_RAPID_OVR_RESET); break;
    295c:	80 e2       	ldi	r24, 0x20	; 32
    295e:	0e 94 b0 3b 	call	0x7760	; 0x7760 <system_set_exec_motion_override_flag>
    2962:	36 c0       	rjmp	.+108    	; 0x29d0 <__vector_25+0x148>
          case CMD_RAPID_OVR_MEDIUM: system_set_exec_motion_override_flag(EXEC_RAPID_OVR_MEDIUM); break;
    2964:	80 e4       	ldi	r24, 0x40	; 64
    2966:	0e 94 b0 3b 	call	0x7760	; 0x7760 <system_set_exec_motion_override_flag>
    296a:	32 c0       	rjmp	.+100    	; 0x29d0 <__vector_25+0x148>
          case CMD_RAPID_OVR_LOW: system_set_exec_motion_override_flag(EXEC_RAPID_OVR_LOW); break;
    296c:	80 e8       	ldi	r24, 0x80	; 128
    296e:	0e 94 b0 3b 	call	0x7760	; 0x7760 <system_set_exec_motion_override_flag>
    2972:	2e c0       	rjmp	.+92     	; 0x29d0 <__vector_25+0x148>
          case CMD_SPINDLE_OVR_RESET: system_set_exec_accessory_override_flag(EXEC_SPINDLE_OVR_RESET); break;
    2974:	81 e0       	ldi	r24, 0x01	; 1
    2976:	0e 94 b9 3b 	call	0x7772	; 0x7772 <system_set_exec_accessory_override_flag>
    297a:	2a c0       	rjmp	.+84     	; 0x29d0 <__vector_25+0x148>
          case CMD_SPINDLE_OVR_COARSE_PLUS: system_set_exec_accessory_override_flag(EXEC_SPINDLE_OVR_COARSE_PLUS); break;
    297c:	82 e0       	ldi	r24, 0x02	; 2
    297e:	0e 94 b9 3b 	call	0x7772	; 0x7772 <system_set_exec_accessory_override_flag>
    2982:	26 c0       	rjmp	.+76     	; 0x29d0 <__vector_25+0x148>
          case CMD_SPINDLE_OVR_COARSE_MINUS: system_set_exec_accessory_override_flag(EXEC_SPINDLE_OVR_COARSE_MINUS); break;
    2984:	84 e0       	ldi	r24, 0x04	; 4
    2986:	0e 94 b9 3b 	call	0x7772	; 0x7772 <system_set_exec_accessory_override_flag>
    298a:	22 c0       	rjmp	.+68     	; 0x29d0 <__vector_25+0x148>
          case CMD_SPINDLE_OVR_FINE_PLUS: system_set_exec_accessory_override_flag(EXEC_SPINDLE_OVR_FINE_PLUS); break;
    298c:	88 e0       	ldi	r24, 0x08	; 8
    298e:	0e 94 b9 3b 	call	0x7772	; 0x7772 <system_set_exec_accessory_override_flag>
    2992:	1e c0       	rjmp	.+60     	; 0x29d0 <__vector_25+0x148>
          case CMD_SPINDLE_OVR_FINE_MINUS: system_set_exec_accessory_override_flag(EXEC_SPINDLE_OVR_FINE_MINUS); break;
    2994:	80 e1       	ldi	r24, 0x10	; 16
    2996:	0e 94 b9 3b 	call	0x7772	; 0x7772 <system_set_exec_accessory_override_flag>
    299a:	1a c0       	rjmp	.+52     	; 0x29d0 <__vector_25+0x148>
          case CMD_SPINDLE_OVR_STOP: system_set_exec_accessory_override_flag(EXEC_SPINDLE_OVR_STOP); break;
    299c:	80 e2       	ldi	r24, 0x20	; 32
    299e:	0e 94 b9 3b 	call	0x7772	; 0x7772 <system_set_exec_accessory_override_flag>
    29a2:	16 c0       	rjmp	.+44     	; 0x29d0 <__vector_25+0x148>
          case CMD_COOLANT_FLOOD_OVR_TOGGLE: system_set_exec_accessory_override_flag(EXEC_COOLANT_FLOOD_OVR_TOGGLE); break;
    29a4:	80 e4       	ldi	r24, 0x40	; 64
    29a6:	0e 94 b9 3b 	call	0x7772	; 0x7772 <system_set_exec_accessory_override_flag>
    29aa:	12 c0       	rjmp	.+36     	; 0x29d0 <__vector_25+0x148>
          case CMD_COOLANT_MIST_OVR_TOGGLE: system_set_exec_accessory_override_flag(EXEC_COOLANT_MIST_OVR_TOGGLE); break;
    29ac:	80 e8       	ldi	r24, 0x80	; 128
    29ae:	0e 94 b9 3b 	call	0x7772	; 0x7772 <system_set_exec_accessory_override_flag>
    29b2:	0e c0       	rjmp	.+28     	; 0x29d0 <__vector_25+0x148>
        }
        // Throw away any unfound extended-ASCII character by not passing it to the serial buffer.
      } else { // Write character to buffer
        next_head = serial_rx_buffer_head + 1;
    29b4:	a0 91 07 02 	lds	r26, 0x0207	; 0x800207 <serial_rx_buffer_head>
    29b8:	81 e0       	ldi	r24, 0x01	; 1
    29ba:	8a 0f       	add	r24, r26
        if (next_head == RX_RING_BUFFER) { next_head = 0; }

        // Write data to buffer unless it is full.
        if (next_head != serial_rx_buffer_tail) {
    29bc:	90 91 06 02 	lds	r25, 0x0206	; 0x800206 <serial_rx_buffer_tail>
    29c0:	89 17       	cp	r24, r25
    29c2:	31 f0       	breq	.+12     	; 0x29d0 <__vector_25+0x148>
          serial_rx_buffer[serial_rx_buffer_head] = data;
    29c4:	b0 e0       	ldi	r27, 0x00	; 0
    29c6:	a7 54       	subi	r26, 0x47	; 71
    29c8:	b2 4f       	sbci	r27, 0xF2	; 242
    29ca:	ec 93       	st	X, r30
          serial_rx_buffer_head = next_head;
    29cc:	80 93 07 02 	sts	0x0207, r24	; 0x800207 <serial_rx_buffer_head>
        }
      }
  }
}
    29d0:	ff 91       	pop	r31
    29d2:	ef 91       	pop	r30
    29d4:	bf 91       	pop	r27
    29d6:	af 91       	pop	r26
    29d8:	9f 91       	pop	r25
    29da:	8f 91       	pop	r24
    29dc:	7f 91       	pop	r23
    29de:	6f 91       	pop	r22
    29e0:	5f 91       	pop	r21
    29e2:	4f 91       	pop	r20
    29e4:	3f 91       	pop	r19
    29e6:	2f 91       	pop	r18
    29e8:	0f 90       	pop	r0
    29ea:	0b be       	out	0x3b, r0	; 59
    29ec:	0f 90       	pop	r0
    29ee:	0f be       	out	0x3f, r0	; 63
    29f0:	0f 90       	pop	r0
    29f2:	1f 90       	pop	r1
    29f4:	18 95       	reti

000029f6 <serial_reset_read_buffer>:


void serial_reset_read_buffer()
{
  serial_rx_buffer_tail = serial_rx_buffer_head;
    29f6:	80 91 07 02 	lds	r24, 0x0207	; 0x800207 <serial_rx_buffer_head>
    29fa:	80 93 06 02 	sts	0x0206, r24	; 0x800206 <serial_rx_buffer_tail>
    29fe:	08 95       	ret

00002a00 <protocol_auto_cycle_start>:
// when one of these conditions exist respectively: There are no more blocks sent (i.e. streaming
// is finished, single commands), a command that needs to wait for the motions in the buffer to
// execute calls a buffer sync, or the planner buffer is full and ready to go.
void protocol_auto_cycle_start()
{
  if (plan_get_current_block() != NULL) { // Check if there are any blocks in the buffer.
    2a00:	0e 94 c3 28 	call	0x5186	; 0x5186 <plan_get_current_block>
    2a04:	89 2b       	or	r24, r25
    2a06:	19 f0       	breq	.+6      	; 0x2a0e <protocol_auto_cycle_start+0xe>
    system_set_exec_state_flag(EXEC_CYCLE_START); // If so, execute them!
    2a08:	82 e0       	ldi	r24, 0x02	; 2
    2a0a:	0c 94 4b 39 	jmp	0x7296	; 0x7296 <system_set_exec_state_flag>
    2a0e:	08 95       	ret

00002a10 <protocol_exec_rt_system>:

// Executes run-time commands, when required. This function primarily operates as Grbl's state
// machine and controls the various real-time features Grbl has to offer.
// NOTE: Do not alter this unless you know exactly what you are doing!
void protocol_exec_rt_system()
{
    2a10:	cf 93       	push	r28
    2a12:	df 93       	push	r29
  uint8_t rt_exec; // Temp variable to avoid calling volatile multiple times.
  rt_exec = sys_rt_exec_alarm; // Copy volatile sys_rt_exec_alarm.
    2a14:	c0 91 3d 0c 	lds	r28, 0x0C3D	; 0x800c3d <sys_rt_exec_alarm>
  if (rt_exec) { // Enter only if any bit flag is true
    2a18:	cc 23       	and	r28, r28
    2a1a:	a9 f0       	breq	.+42     	; 0x2a46 <protocol_exec_rt_system+0x36>
    // System alarm. Everything has shutdown by something that has gone severely wrong. Report
    // the source of the error to the user. If critical, Grbl disables by entering an infinite
    // loop until system reset/abort.
    sys.state = STATE_ALARM; // Set system alarm state
    2a1c:	81 e0       	ldi	r24, 0x01	; 1
    2a1e:	80 93 11 0c 	sts	0x0C11, r24	; 0x800c11 <sys>
    report_alarm_message(rt_exec);
    2a22:	8c 2f       	mov	r24, r28
    2a24:	0e 94 88 33 	call	0x6710	; 0x6710 <report_alarm_message>
    // Halt everything upon a critical event flag. Currently hard and soft limits flag this.
    if ((rt_exec == EXEC_ALARM_HARD_LIMIT) || (rt_exec == EXEC_ALARM_SOFT_LIMIT)) {
    2a28:	c1 50       	subi	r28, 0x01	; 1
    2a2a:	c2 30       	cpi	r28, 0x02	; 2
    2a2c:	50 f4       	brcc	.+20     	; 0x2a42 <protocol_exec_rt_system+0x32>
      report_feedback_message(MESSAGE_CRITICAL_EVENT);
    2a2e:	81 e0       	ldi	r24, 0x01	; 1
    2a30:	0e 94 95 33 	call	0x672a	; 0x672a <report_feedback_message>
      system_clear_exec_state_flag(EXEC_RESET); // Disable any existing reset
    2a34:	80 e1       	ldi	r24, 0x10	; 16
    2a36:	0e 94 9a 3b 	call	0x7734	; 0x7734 <system_clear_exec_state_flag>
        // Block everything, except reset and status reports, until user issues reset or power
        // cycles. Hard limits typically occur while unattended or not paying attention. Gives
        // the user and a GUI time to do what is needed before resetting, like killing the
        // incoming stream. The same could be said about soft limits. While the position is not
        // lost, continued streaming could cause a serious crash if by chance it gets executed.
      } while (bit_isfalse(sys_rt_exec_state,EXEC_RESET));
    2a3a:	80 91 23 0c 	lds	r24, 0x0C23	; 0x800c23 <sys_rt_exec_state>
    2a3e:	84 ff       	sbrs	r24, 4
    2a40:	fc cf       	rjmp	.-8      	; 0x2a3a <protocol_exec_rt_system+0x2a>
    }
    system_clear_exec_alarm(); // Clear alarm
    2a42:	0e 94 aa 3b 	call	0x7754	; 0x7754 <system_clear_exec_alarm>
  }

  rt_exec = sys_rt_exec_state; // Copy volatile sys_rt_exec_state.
    2a46:	c0 91 23 0c 	lds	r28, 0x0C23	; 0x800c23 <sys_rt_exec_state>
  if (rt_exec) {
    2a4a:	cc 23       	and	r28, r28
    2a4c:	09 f4       	brne	.+2      	; 0x2a50 <protocol_exec_rt_system+0x40>
    2a4e:	f0 c0       	rjmp	.+480    	; 0x2c30 <protocol_exec_rt_system+0x220>

    // Execute system abort.
    if (rt_exec & EXEC_RESET) {
    2a50:	c4 ff       	sbrs	r28, 4
    2a52:	04 c0       	rjmp	.+8      	; 0x2a5c <protocol_exec_rt_system+0x4c>
      sys.abort = true;  // Only place this is set true.
    2a54:	81 e0       	ldi	r24, 0x01	; 1
    2a56:	80 93 12 0c 	sts	0x0C12, r24	; 0x800c12 <sys+0x1>
      return; // Nothing else to do but exit.
    2a5a:	8f c1       	rjmp	.+798    	; 0x2d7a <protocol_exec_rt_system+0x36a>
    }

    // Execute and serial print status
    if (rt_exec & EXEC_STATUS_REPORT) {
    2a5c:	c0 ff       	sbrs	r28, 0
    2a5e:	05 c0       	rjmp	.+10     	; 0x2a6a <protocol_exec_rt_system+0x5a>
      report_realtime_status();
    2a60:	0e 94 39 36 	call	0x6c72	; 0x6c72 <report_realtime_status>
      system_clear_exec_state_flag(EXEC_STATUS_REPORT);
    2a64:	81 e0       	ldi	r24, 0x01	; 1
    2a66:	0e 94 9a 3b 	call	0x7734	; 0x7734 <system_clear_exec_state_flag>
    }

    // NOTE: Once hold is initiated, the system immediately enters a suspend state to block all
    // main program processes until either reset or resumed. This ensures a hold completes safely.
    if (rt_exec & (EXEC_MOTION_CANCEL | EXEC_FEED_HOLD | EXEC_SAFETY_DOOR | EXEC_SLEEP)) {
    2a6a:	8c 2f       	mov	r24, r28
    2a6c:	88 7e       	andi	r24, 0xE8	; 232
    2a6e:	09 f4       	brne	.+2      	; 0x2a72 <protocol_exec_rt_system+0x62>
    2a70:	5e c0       	rjmp	.+188    	; 0x2b2e <protocol_exec_rt_system+0x11e>

      // State check for allowable states for hold methods.
      if (!(sys.state & (STATE_ALARM | STATE_CHECK_MODE))) {
    2a72:	80 91 11 0c 	lds	r24, 0x0C11	; 0x800c11 <sys>
    2a76:	98 2f       	mov	r25, r24
    2a78:	93 70       	andi	r25, 0x03	; 3
    2a7a:	09 f0       	breq	.+2      	; 0x2a7e <protocol_exec_rt_system+0x6e>
    2a7c:	47 c0       	rjmp	.+142    	; 0x2b0c <protocol_exec_rt_system+0xfc>
      
        // If in CYCLE or JOG states, immediately initiate a motion HOLD.
        if (sys.state & (STATE_CYCLE | STATE_JOG)) {
    2a7e:	88 72       	andi	r24, 0x28	; 40
    2a80:	89 f0       	breq	.+34     	; 0x2aa4 <protocol_exec_rt_system+0x94>
          if (!(sys.suspend & (SUSPEND_MOTION_CANCEL | SUSPEND_JOG_CANCEL))) { // Block, if already holding.
    2a82:	80 91 13 0c 	lds	r24, 0x0C13	; 0x800c13 <sys+0x2>
    2a86:	80 7c       	andi	r24, 0xC0	; 192
    2a88:	69 f4       	brne	.+26     	; 0x2aa4 <protocol_exec_rt_system+0x94>
            st_update_plan_block_parameters(); // Notify stepper module to recompute for hold deceleration.
    2a8a:	20 d6       	rcall	.+3136   	; 0x36cc <st_update_plan_block_parameters>
            sys.step_control = STEP_CONTROL_EXECUTE_HOLD; // Initiate suspend state with active flag.
    2a8c:	e1 e1       	ldi	r30, 0x11	; 17
    2a8e:	fc e0       	ldi	r31, 0x0C	; 12
    2a90:	82 e0       	ldi	r24, 0x02	; 2
    2a92:	84 83       	std	Z+4, r24	; 0x04
            if (sys.state == STATE_JOG) { // Jog cancelled upon any hold event, except for sleeping.
    2a94:	80 81       	ld	r24, Z
    2a96:	80 32       	cpi	r24, 0x20	; 32
    2a98:	29 f4       	brne	.+10     	; 0x2aa4 <protocol_exec_rt_system+0x94>
              if (!(rt_exec & EXEC_SLEEP)) { sys.suspend |= SUSPEND_JOG_CANCEL; } 
    2a9a:	cc 23       	and	r28, r28
    2a9c:	1c f0       	brlt	.+6      	; 0x2aa4 <protocol_exec_rt_system+0x94>
    2a9e:	82 81       	ldd	r24, Z+2	; 0x02
    2aa0:	80 68       	ori	r24, 0x80	; 128
    2aa2:	82 83       	std	Z+2, r24	; 0x02
            }
          }
        }
        // If IDLE, Grbl is not in motion. Simply indicate suspend state and hold is complete.
        if (sys.state == STATE_IDLE) { sys.suspend = SUSPEND_HOLD_COMPLETE; }
    2aa4:	80 91 11 0c 	lds	r24, 0x0C11	; 0x800c11 <sys>
    2aa8:	81 11       	cpse	r24, r1
    2aaa:	03 c0       	rjmp	.+6      	; 0x2ab2 <protocol_exec_rt_system+0xa2>
    2aac:	91 e0       	ldi	r25, 0x01	; 1
    2aae:	90 93 13 0c 	sts	0x0C13, r25	; 0x800c13 <sys+0x2>

        // Execute and flag a motion cancel with deceleration and return to idle. Used primarily by probing cycle
        // to halt and cancel the remainder of the motion.
        if (rt_exec & EXEC_MOTION_CANCEL) {
    2ab2:	c6 ff       	sbrs	r28, 6
    2ab4:	07 c0       	rjmp	.+14     	; 0x2ac4 <protocol_exec_rt_system+0xb4>
          // MOTION_CANCEL only occurs during a CYCLE, but a HOLD and SAFETY_DOOR may been initiated beforehand
          // to hold the CYCLE. Motion cancel is valid for a single planner block motion only, while jog cancel
          // will handle and clear multiple planner block motions.
          if (!(sys.state & STATE_JOG)) { sys.suspend |= SUSPEND_MOTION_CANCEL; } // NOTE: State is STATE_CYCLE.
    2ab6:	85 fd       	sbrc	r24, 5
    2ab8:	05 c0       	rjmp	.+10     	; 0x2ac4 <protocol_exec_rt_system+0xb4>
    2aba:	e1 e1       	ldi	r30, 0x11	; 17
    2abc:	fc e0       	ldi	r31, 0x0C	; 12
    2abe:	92 81       	ldd	r25, Z+2	; 0x02
    2ac0:	90 64       	ori	r25, 0x40	; 64
    2ac2:	92 83       	std	Z+2, r25	; 0x02
        }

        // Execute a feed hold with deceleration, if required. Then, suspend system.
        if (rt_exec & EXEC_FEED_HOLD) {
    2ac4:	c3 ff       	sbrs	r28, 3
    2ac6:	05 c0       	rjmp	.+10     	; 0x2ad2 <protocol_exec_rt_system+0xc2>
          // Block SAFETY_DOOR, JOG, and SLEEP states from changing to HOLD state.
          if (!(sys.state & (STATE_SAFETY_DOOR | STATE_JOG | STATE_SLEEP))) { sys.state = STATE_HOLD; }
    2ac8:	80 7e       	andi	r24, 0xE0	; 224
    2aca:	19 f4       	brne	.+6      	; 0x2ad2 <protocol_exec_rt_system+0xc2>
    2acc:	80 e1       	ldi	r24, 0x10	; 16
    2ace:	80 93 11 0c 	sts	0x0C11, r24	; 0x800c11 <sys>
        }

        // Execute a safety door stop with a feed hold and disable spindle/coolant.
        // NOTE: Safety door differs from feed holds by stopping everything no matter state, disables powered
        // devices (spindle/coolant), and blocks resuming until switch is re-engaged.
        if (rt_exec & EXEC_SAFETY_DOOR) {
    2ad2:	c5 ff       	sbrs	r28, 5
    2ad4:	1b c0       	rjmp	.+54     	; 0x2b0c <protocol_exec_rt_system+0xfc>
          report_feedback_message(MESSAGE_SAFETY_DOOR_AJAR);
    2ad6:	86 e0       	ldi	r24, 0x06	; 6
    2ad8:	0e 94 95 33 	call	0x672a	; 0x672a <report_feedback_message>
          // If jogging, block safety door methods until jog cancel is complete. Just flag that it happened.
          if (!(sys.suspend & SUSPEND_JOG_CANCEL)) {
    2adc:	80 91 13 0c 	lds	r24, 0x0C13	; 0x800c13 <sys+0x2>
    2ae0:	88 23       	and	r24, r24
    2ae2:	7c f0       	brlt	.+30     	; 0x2b02 <protocol_exec_rt_system+0xf2>
            // Check if the safety re-opened during a restore parking motion only. Ignore if
            // already retracting, parked or in sleep state.
            if (sys.state == STATE_SAFETY_DOOR) {
    2ae4:	90 91 11 0c 	lds	r25, 0x0C11	; 0x800c11 <sys>
    2ae8:	90 34       	cpi	r25, 0x40	; 64
    2aea:	31 f4       	brne	.+12     	; 0x2af8 <protocol_exec_rt_system+0xe8>
              if (sys.suspend & SUSPEND_INITIATE_RESTORE) { // Actively restoring
    2aec:	83 ff       	sbrs	r24, 3
    2aee:	04 c0       	rjmp	.+8      	; 0x2af8 <protocol_exec_rt_system+0xe8>
                    st_update_plan_block_parameters(); // Notify stepper module to recompute for hold deceleration.
                    sys.step_control = (STEP_CONTROL_EXECUTE_HOLD | STEP_CONTROL_EXECUTE_SYS_MOTION);
                    sys.suspend &= ~(SUSPEND_HOLD_COMPLETE);
                  } // else NO_MOTION is active.
                #endif
                sys.suspend &= ~(SUSPEND_RETRACT_COMPLETE | SUSPEND_INITIATE_RESTORE | SUSPEND_RESTORE_COMPLETE);
    2af0:	83 7e       	andi	r24, 0xE3	; 227
                sys.suspend |= SUSPEND_RESTART_RETRACT;
    2af2:	82 60       	ori	r24, 0x02	; 2
    2af4:	80 93 13 0c 	sts	0x0C13, r24	; 0x800c13 <sys+0x2>
              }
            }
            if (sys.state != STATE_SLEEP) { sys.state = STATE_SAFETY_DOOR; }
    2af8:	90 38       	cpi	r25, 0x80	; 128
    2afa:	19 f0       	breq	.+6      	; 0x2b02 <protocol_exec_rt_system+0xf2>
    2afc:	80 e4       	ldi	r24, 0x40	; 64
    2afe:	80 93 11 0c 	sts	0x0C11, r24	; 0x800c11 <sys>
          }
          // NOTE: This flag doesn't change when the door closes, unlike sys.state. Ensures any parking motions
          // are executed if the door switch closes and the state returns to HOLD.
          sys.suspend |= SUSPEND_SAFETY_DOOR_AJAR;
    2b02:	e1 e1       	ldi	r30, 0x11	; 17
    2b04:	fc e0       	ldi	r31, 0x0C	; 12
    2b06:	82 81       	ldd	r24, Z+2	; 0x02
    2b08:	80 62       	ori	r24, 0x20	; 32
    2b0a:	82 83       	std	Z+2, r24	; 0x02
        }
        
      }

      if (rt_exec & EXEC_SLEEP) {
    2b0c:	cc 23       	and	r28, r28
    2b0e:	64 f4       	brge	.+24     	; 0x2b28 <protocol_exec_rt_system+0x118>
        if (sys.state == STATE_ALARM) { sys.suspend |= (SUSPEND_RETRACT_COMPLETE|SUSPEND_HOLD_COMPLETE); }
    2b10:	80 91 11 0c 	lds	r24, 0x0C11	; 0x800c11 <sys>
    2b14:	81 30       	cpi	r24, 0x01	; 1
    2b16:	29 f4       	brne	.+10     	; 0x2b22 <protocol_exec_rt_system+0x112>
    2b18:	e1 e1       	ldi	r30, 0x11	; 17
    2b1a:	fc e0       	ldi	r31, 0x0C	; 12
    2b1c:	82 81       	ldd	r24, Z+2	; 0x02
    2b1e:	85 60       	ori	r24, 0x05	; 5
    2b20:	82 83       	std	Z+2, r24	; 0x02
        sys.state = STATE_SLEEP; 
    2b22:	80 e8       	ldi	r24, 0x80	; 128
    2b24:	80 93 11 0c 	sts	0x0C11, r24	; 0x800c11 <sys>
      }

      system_clear_exec_state_flag((EXEC_MOTION_CANCEL | EXEC_FEED_HOLD | EXEC_SAFETY_DOOR | EXEC_SLEEP));
    2b28:	88 ee       	ldi	r24, 0xE8	; 232
    2b2a:	0e 94 9a 3b 	call	0x7734	; 0x7734 <system_clear_exec_state_flag>
    }

    // Execute a cycle start by starting the stepper interrupt to begin executing the blocks in queue.
    if (rt_exec & EXEC_CYCLE_START) {
    2b2e:	c1 ff       	sbrs	r28, 1
    2b30:	42 c0       	rjmp	.+132    	; 0x2bb6 <protocol_exec_rt_system+0x1a6>
      // Block if called at same time as the hold commands: feed hold, motion cancel, and safety door.
      // Ensures auto-cycle-start doesn't resume a hold without an explicit user-input.
      if (!(rt_exec & (EXEC_FEED_HOLD | EXEC_MOTION_CANCEL | EXEC_SAFETY_DOOR))) {
    2b32:	8c 2f       	mov	r24, r28
    2b34:	88 76       	andi	r24, 0x68	; 104
    2b36:	e1 f5       	brne	.+120    	; 0x2bb0 <protocol_exec_rt_system+0x1a0>
        // Resume door state when parking motion has retracted and door has been closed.
        if ((sys.state == STATE_SAFETY_DOOR) && !(sys.suspend & SUSPEND_SAFETY_DOOR_AJAR)) {
    2b38:	80 91 11 0c 	lds	r24, 0x0C11	; 0x800c11 <sys>
    2b3c:	80 34       	cpi	r24, 0x40	; 64
    2b3e:	71 f4       	brne	.+28     	; 0x2b5c <protocol_exec_rt_system+0x14c>
    2b40:	80 91 13 0c 	lds	r24, 0x0C13	; 0x800c13 <sys+0x2>
    2b44:	85 fd       	sbrc	r24, 5
    2b46:	0a c0       	rjmp	.+20     	; 0x2b5c <protocol_exec_rt_system+0x14c>
          if (sys.suspend & SUSPEND_RESTORE_COMPLETE) {
    2b48:	84 ff       	sbrs	r24, 4
    2b4a:	03 c0       	rjmp	.+6      	; 0x2b52 <protocol_exec_rt_system+0x142>
            sys.state = STATE_IDLE; // Set to IDLE to immediately resume the cycle.
    2b4c:	10 92 11 0c 	sts	0x0C11, r1	; 0x800c11 <sys>
    2b50:	05 c0       	rjmp	.+10     	; 0x2b5c <protocol_exec_rt_system+0x14c>
          } else if (sys.suspend & SUSPEND_RETRACT_COMPLETE) {
    2b52:	82 ff       	sbrs	r24, 2
    2b54:	03 c0       	rjmp	.+6      	; 0x2b5c <protocol_exec_rt_system+0x14c>
            // Flag to re-energize powered components and restore original position, if disabled by SAFETY_DOOR.
            // NOTE: For a safety door to resume, the switch must be closed, as indicated by HOLD state, and
            // the retraction execution is complete, which implies the initial feed hold is not active. To
            // restore normal operation, the restore procedures must be initiated by the following flag. Once,
            // they are complete, it will call CYCLE_START automatically to resume and exit the suspend.
            sys.suspend |= SUSPEND_INITIATE_RESTORE;
    2b56:	88 60       	ori	r24, 0x08	; 8
    2b58:	80 93 13 0c 	sts	0x0C13, r24	; 0x800c13 <sys+0x2>
          }
        }
        // Cycle start only when IDLE or when a hold is complete and ready to resume.
        if ((sys.state == STATE_IDLE) || ((sys.state & STATE_HOLD) && (sys.suspend & SUSPEND_HOLD_COMPLETE))) {
    2b5c:	80 91 11 0c 	lds	r24, 0x0C11	; 0x800c11 <sys>
    2b60:	88 23       	and	r24, r24
    2b62:	31 f0       	breq	.+12     	; 0x2b70 <protocol_exec_rt_system+0x160>
    2b64:	84 ff       	sbrs	r24, 4
    2b66:	24 c0       	rjmp	.+72     	; 0x2bb0 <protocol_exec_rt_system+0x1a0>
    2b68:	90 91 13 0c 	lds	r25, 0x0C13	; 0x800c13 <sys+0x2>
    2b6c:	90 ff       	sbrs	r25, 0
    2b6e:	20 c0       	rjmp	.+64     	; 0x2bb0 <protocol_exec_rt_system+0x1a0>
          if (sys.state == STATE_HOLD && sys.spindle_stop_ovr) {
    2b70:	80 31       	cpi	r24, 0x10	; 16
    2b72:	41 f4       	brne	.+16     	; 0x2b84 <protocol_exec_rt_system+0x174>
    2b74:	80 91 1b 0c 	lds	r24, 0x0C1B	; 0x800c1b <sys+0xa>
    2b78:	88 23       	and	r24, r24
    2b7a:	21 f0       	breq	.+8      	; 0x2b84 <protocol_exec_rt_system+0x174>
            sys.spindle_stop_ovr |= SPINDLE_STOP_OVR_RESTORE_CYCLE; // Set to restore in suspend routine and cycle start after.
    2b7c:	88 60       	ori	r24, 0x08	; 8
    2b7e:	80 93 1b 0c 	sts	0x0C1B, r24	; 0x800c1b <sys+0xa>
    2b82:	16 c0       	rjmp	.+44     	; 0x2bb0 <protocol_exec_rt_system+0x1a0>
          } else {
            // Start cycle only if queued motions exist in planner buffer and the motion is not canceled.
            sys.step_control = STEP_CONTROL_NORMAL_OP; // Restore step control to normal operation
    2b84:	10 92 15 0c 	sts	0x0C15, r1	; 0x800c15 <sys+0x4>
            if (plan_get_current_block() && bit_isfalse(sys.suspend,SUSPEND_MOTION_CANCEL)) {
    2b88:	0e 94 c3 28 	call	0x5186	; 0x5186 <plan_get_current_block>
    2b8c:	89 2b       	or	r24, r25
    2b8e:	61 f0       	breq	.+24     	; 0x2ba8 <protocol_exec_rt_system+0x198>
    2b90:	80 91 13 0c 	lds	r24, 0x0C13	; 0x800c13 <sys+0x2>
    2b94:	86 fd       	sbrc	r24, 6
    2b96:	08 c0       	rjmp	.+16     	; 0x2ba8 <protocol_exec_rt_system+0x198>
              sys.suspend = SUSPEND_DISABLE; // Break suspend state.
    2b98:	e1 e1       	ldi	r30, 0x11	; 17
    2b9a:	fc e0       	ldi	r31, 0x0C	; 12
    2b9c:	12 82       	std	Z+2, r1	; 0x02
              sys.state = STATE_CYCLE;
    2b9e:	88 e0       	ldi	r24, 0x08	; 8
              st_prep_buffer(); // Initialize step segment buffer before beginning cycle.
    2ba0:	80 83       	st	Z, r24
              st_wake_up();
    2ba2:	b4 d5       	rcall	.+2920   	; 0x370c <st_prep_buffer>
    2ba4:	9b d2       	rcall	.+1334   	; 0x30dc <st_wake_up>
    2ba6:	04 c0       	rjmp	.+8      	; 0x2bb0 <protocol_exec_rt_system+0x1a0>
            } else { // Otherwise, do nothing. Set and resume IDLE state.
              sys.suspend = SUSPEND_DISABLE; // Break suspend state.
    2ba8:	e1 e1       	ldi	r30, 0x11	; 17
    2baa:	fc e0       	ldi	r31, 0x0C	; 12
    2bac:	12 82       	std	Z+2, r1	; 0x02
              sys.state = STATE_IDLE;
    2bae:	10 82       	st	Z, r1
            }
          }
        }
      }
      system_clear_exec_state_flag(EXEC_CYCLE_START);
    2bb0:	82 e0       	ldi	r24, 0x02	; 2
    2bb2:	0e 94 9a 3b 	call	0x7734	; 0x7734 <system_clear_exec_state_flag>
    }

    if (rt_exec & EXEC_CYCLE_STOP) {
    2bb6:	c2 ff       	sbrs	r28, 2
    2bb8:	3b c0       	rjmp	.+118    	; 0x2c30 <protocol_exec_rt_system+0x220>
      // Reinitializes the cycle plan and stepper system after a feed hold for a resume. Called by
      // realtime command execution in the main program, ensuring that the planner re-plans safely.
      // NOTE: Bresenham algorithm variables are still maintained through both the planner and stepper
      // cycle reinitializations. The stepper path should continue exactly as if nothing has happened.
      // NOTE: EXEC_CYCLE_STOP is set by the stepper subsystem when a cycle or feed hold completes.
      if ((sys.state & (STATE_HOLD|STATE_SAFETY_DOOR|STATE_SLEEP)) && !(sys.soft_limit) && !(sys.suspend & SUSPEND_JOG_CANCEL)) {
    2bba:	80 91 11 0c 	lds	r24, 0x0C11	; 0x800c11 <sys>
    2bbe:	80 7d       	andi	r24, 0xD0	; 208
    2bc0:	b9 f0       	breq	.+46     	; 0x2bf0 <protocol_exec_rt_system+0x1e0>
    2bc2:	80 91 14 0c 	lds	r24, 0x0C14	; 0x800c14 <sys+0x3>
    2bc6:	81 11       	cpse	r24, r1
    2bc8:	13 c0       	rjmp	.+38     	; 0x2bf0 <protocol_exec_rt_system+0x1e0>
    2bca:	80 91 13 0c 	lds	r24, 0x0C13	; 0x800c13 <sys+0x2>
    2bce:	88 23       	and	r24, r24
    2bd0:	7c f0       	brlt	.+30     	; 0x2bf0 <protocol_exec_rt_system+0x1e0>
        // Hold complete. Set to indicate ready to resume.  Remain in HOLD or DOOR states until user
        // has issued a resume command or reset.
        plan_cycle_reinitialize();
    2bd2:	0e 94 95 2c 	call	0x592a	; 0x592a <plan_cycle_reinitialize>
        if (sys.step_control & STEP_CONTROL_EXECUTE_HOLD) { sys.suspend |= SUSPEND_HOLD_COMPLETE; }
    2bd6:	80 91 15 0c 	lds	r24, 0x0C15	; 0x800c15 <sys+0x4>
    2bda:	81 ff       	sbrs	r24, 1
    2bdc:	05 c0       	rjmp	.+10     	; 0x2be8 <protocol_exec_rt_system+0x1d8>
    2bde:	e1 e1       	ldi	r30, 0x11	; 17
    2be0:	fc e0       	ldi	r31, 0x0C	; 12
    2be2:	92 81       	ldd	r25, Z+2	; 0x02
    2be4:	91 60       	ori	r25, 0x01	; 1
    2be6:	92 83       	std	Z+2, r25	; 0x02
        bit_false(sys.step_control,(STEP_CONTROL_EXECUTE_HOLD | STEP_CONTROL_EXECUTE_SYS_MOTION));
    2be8:	89 7f       	andi	r24, 0xF9	; 249
    2bea:	80 93 15 0c 	sts	0x0C15, r24	; 0x800c15 <sys+0x4>
    2bee:	1d c0       	rjmp	.+58     	; 0x2c2a <protocol_exec_rt_system+0x21a>
      } else {
        // Motion complete. Includes CYCLE/JOG/HOMING states and jog cancel/motion cancel/soft limit events.
        // NOTE: Motion and jog cancel both immediately return to idle after the hold completes.
        if (sys.suspend & SUSPEND_JOG_CANCEL) {   // For jog cancel, flush buffers and sync positions.
    2bf0:	80 91 13 0c 	lds	r24, 0x0C13	; 0x800c13 <sys+0x2>
    2bf4:	88 23       	and	r24, r24
    2bf6:	4c f4       	brge	.+18     	; 0x2c0a <protocol_exec_rt_system+0x1fa>
          sys.step_control = STEP_CONTROL_NORMAL_OP;
    2bf8:	10 92 15 0c 	sts	0x0C15, r1	; 0x800c15 <sys+0x4>
          plan_reset();
    2bfc:	0e 94 9e 28 	call	0x513c	; 0x513c <plan_reset>
          st_reset();
    2c00:	10 d5       	rcall	.+2592   	; 0x3622 <st_reset>
          gc_sync_position();
    2c02:	0e 94 e2 06 	call	0xdc4	; 0xdc4 <gc_sync_position>
          plan_sync_position();
    2c06:	0e 94 6f 2c 	call	0x58de	; 0x58de <plan_sync_position>
        }
        if (sys.suspend & SUSPEND_SAFETY_DOOR_AJAR) { // Only occurs when safety door opens during jog.
    2c0a:	80 91 13 0c 	lds	r24, 0x0C13	; 0x800c13 <sys+0x2>
    2c0e:	85 ff       	sbrs	r24, 5
    2c10:	08 c0       	rjmp	.+16     	; 0x2c22 <protocol_exec_rt_system+0x212>
          sys.suspend &= ~(SUSPEND_JOG_CANCEL);
    2c12:	8f 77       	andi	r24, 0x7F	; 127
    2c14:	e1 e1       	ldi	r30, 0x11	; 17
    2c16:	fc e0       	ldi	r31, 0x0C	; 12
          sys.suspend |= SUSPEND_HOLD_COMPLETE;
    2c18:	81 60       	ori	r24, 0x01	; 1
    2c1a:	82 83       	std	Z+2, r24	; 0x02
          sys.state = STATE_SAFETY_DOOR;
    2c1c:	80 e4       	ldi	r24, 0x40	; 64
    2c1e:	80 83       	st	Z, r24
    2c20:	04 c0       	rjmp	.+8      	; 0x2c2a <protocol_exec_rt_system+0x21a>
        } else {
          sys.suspend = SUSPEND_DISABLE;
    2c22:	e1 e1       	ldi	r30, 0x11	; 17
    2c24:	fc e0       	ldi	r31, 0x0C	; 12
    2c26:	12 82       	std	Z+2, r1	; 0x02
          sys.state = STATE_IDLE;
    2c28:	10 82       	st	Z, r1
        }
      }
      system_clear_exec_state_flag(EXEC_CYCLE_STOP);
    2c2a:	84 e0       	ldi	r24, 0x04	; 4
    2c2c:	0e 94 9a 3b 	call	0x7734	; 0x7734 <system_clear_exec_state_flag>
    }
  }

  // Execute overrides.
  rt_exec = sys_rt_exec_motion_override; // Copy volatile sys_rt_exec_motion_override
    2c30:	c0 91 10 0c 	lds	r28, 0x0C10	; 0x800c10 <sys_rt_exec_motion_override>
  if (rt_exec) {
    2c34:	cc 23       	and	r28, r28
    2c36:	81 f1       	breq	.+96     	; 0x2c98 <protocol_exec_rt_system+0x288>
    system_clear_exec_motion_overrides(); // Clear all motion override flags.
    2c38:	0e 94 c2 3b 	call	0x7784	; 0x7784 <system_clear_exec_motion_overrides>

    uint8_t new_f_override =  sys.f_override;
    2c3c:	20 91 18 0c 	lds	r18, 0x0C18	; 0x800c18 <sys+0x7>
    if (rt_exec & EXEC_FEED_OVR_RESET) { new_f_override = DEFAULT_FEED_OVERRIDE; }
    2c40:	c0 fd       	sbrc	r28, 0
    2c42:	02 c0       	rjmp	.+4      	; 0x2c48 <protocol_exec_rt_system+0x238>
  // Execute overrides.
  rt_exec = sys_rt_exec_motion_override; // Copy volatile sys_rt_exec_motion_override
  if (rt_exec) {
    system_clear_exec_motion_overrides(); // Clear all motion override flags.

    uint8_t new_f_override =  sys.f_override;
    2c44:	82 2f       	mov	r24, r18
    2c46:	01 c0       	rjmp	.+2      	; 0x2c4a <protocol_exec_rt_system+0x23a>
    if (rt_exec & EXEC_FEED_OVR_RESET) { new_f_override = DEFAULT_FEED_OVERRIDE; }
    2c48:	84 e6       	ldi	r24, 0x64	; 100
    if (rt_exec & EXEC_FEED_OVR_COARSE_PLUS) { new_f_override += FEED_OVERRIDE_COARSE_INCREMENT; }
    2c4a:	c1 fd       	sbrc	r28, 1
    2c4c:	86 5f       	subi	r24, 0xF6	; 246
    if (rt_exec & EXEC_FEED_OVR_COARSE_MINUS) { new_f_override -= FEED_OVERRIDE_COARSE_INCREMENT; }
    2c4e:	c2 fd       	sbrc	r28, 2
    2c50:	8a 50       	subi	r24, 0x0A	; 10
    if (rt_exec & EXEC_FEED_OVR_FINE_PLUS) { new_f_override += FEED_OVERRIDE_FINE_INCREMENT; }
    2c52:	c3 fd       	sbrc	r28, 3
    2c54:	8f 5f       	subi	r24, 0xFF	; 255
    if (rt_exec & EXEC_FEED_OVR_FINE_MINUS) { new_f_override -= FEED_OVERRIDE_FINE_INCREMENT; }
    2c56:	c4 fd       	sbrc	r28, 4
    2c58:	81 50       	subi	r24, 0x01	; 1
    new_f_override = min(new_f_override,MAX_FEED_RATE_OVERRIDE);
    2c5a:	89 3c       	cpi	r24, 0xC9	; 201
    2c5c:	08 f0       	brcs	.+2      	; 0x2c60 <protocol_exec_rt_system+0x250>
    2c5e:	88 ec       	ldi	r24, 0xC8	; 200
    new_f_override = max(new_f_override,MIN_FEED_RATE_OVERRIDE);
    2c60:	8a 30       	cpi	r24, 0x0A	; 10
    2c62:	08 f4       	brcc	.+2      	; 0x2c66 <protocol_exec_rt_system+0x256>
    2c64:	8a e0       	ldi	r24, 0x0A	; 10

    uint8_t new_r_override = sys.r_override;
    2c66:	30 91 19 0c 	lds	r19, 0x0C19	; 0x800c19 <sys+0x8>
    if (rt_exec & EXEC_RAPID_OVR_RESET) { new_r_override = DEFAULT_RAPID_OVERRIDE; }
    2c6a:	c5 fd       	sbrc	r28, 5
    2c6c:	02 c0       	rjmp	.+4      	; 0x2c72 <protocol_exec_rt_system+0x262>
    if (rt_exec & EXEC_FEED_OVR_FINE_PLUS) { new_f_override += FEED_OVERRIDE_FINE_INCREMENT; }
    if (rt_exec & EXEC_FEED_OVR_FINE_MINUS) { new_f_override -= FEED_OVERRIDE_FINE_INCREMENT; }
    new_f_override = min(new_f_override,MAX_FEED_RATE_OVERRIDE);
    new_f_override = max(new_f_override,MIN_FEED_RATE_OVERRIDE);

    uint8_t new_r_override = sys.r_override;
    2c6e:	93 2f       	mov	r25, r19
    2c70:	01 c0       	rjmp	.+2      	; 0x2c74 <protocol_exec_rt_system+0x264>
    if (rt_exec & EXEC_RAPID_OVR_RESET) { new_r_override = DEFAULT_RAPID_OVERRIDE; }
    2c72:	94 e6       	ldi	r25, 0x64	; 100
    if (rt_exec & EXEC_RAPID_OVR_MEDIUM) { new_r_override = RAPID_OVERRIDE_MEDIUM; }
    2c74:	c6 fd       	sbrc	r28, 6
    2c76:	92 e3       	ldi	r25, 0x32	; 50
    if (rt_exec & EXEC_RAPID_OVR_LOW) { new_r_override = RAPID_OVERRIDE_LOW; }
    2c78:	cc 23       	and	r28, r28
    2c7a:	0c f4       	brge	.+2      	; 0x2c7e <protocol_exec_rt_system+0x26e>
    2c7c:	99 e1       	ldi	r25, 0x19	; 25

    if ((new_f_override != sys.f_override) || (new_r_override != sys.r_override)) {
    2c7e:	28 13       	cpse	r18, r24
    2c80:	02 c0       	rjmp	.+4      	; 0x2c86 <protocol_exec_rt_system+0x276>
    2c82:	93 17       	cp	r25, r19
    2c84:	49 f0       	breq	.+18     	; 0x2c98 <protocol_exec_rt_system+0x288>
      sys.f_override = new_f_override;
    2c86:	e1 e1       	ldi	r30, 0x11	; 17
    2c88:	fc e0       	ldi	r31, 0x0C	; 12
    2c8a:	87 83       	std	Z+7, r24	; 0x07
      sys.r_override = new_r_override;
    2c8c:	90 87       	std	Z+8, r25	; 0x08
      sys.report_ovr_counter = 0; // Set to report change immediately
    2c8e:	13 86       	std	Z+11, r1	; 0x0b
      plan_update_velocity_profile_parameters();
    2c90:	0e 94 6b 29 	call	0x52d6	; 0x52d6 <plan_update_velocity_profile_parameters>
      plan_cycle_reinitialize();
    2c94:	0e 94 95 2c 	call	0x592a	; 0x592a <plan_cycle_reinitialize>
    }
  }

  rt_exec = sys_rt_exec_accessory_override;
    2c98:	c0 91 22 0c 	lds	r28, 0x0C22	; 0x800c22 <sys_rt_exec_accessory_override>
  if (rt_exec) {
    2c9c:	cc 23       	and	r28, r28
    2c9e:	09 f4       	brne	.+2      	; 0x2ca2 <protocol_exec_rt_system+0x292>
    2ca0:	5f c0       	rjmp	.+190    	; 0x2d60 <protocol_exec_rt_system+0x350>
    system_clear_exec_accessory_overrides(); // Clear all accessory override flags.
    2ca2:	0e 94 c8 3b 	call	0x7790	; 0x7790 <system_clear_exec_accessory_overrides>

    // NOTE: Unlike motion overrides, spindle overrides do not require a planner reinitialization.
    uint8_t last_s_override =  sys.spindle_speed_ovr;
    2ca6:	90 91 1a 0c 	lds	r25, 0x0C1A	; 0x800c1a <sys+0x9>
    if (rt_exec & EXEC_SPINDLE_OVR_RESET) { last_s_override = DEFAULT_SPINDLE_SPEED_OVERRIDE; }
    2caa:	c0 fd       	sbrc	r28, 0
    2cac:	02 c0       	rjmp	.+4      	; 0x2cb2 <protocol_exec_rt_system+0x2a2>
  rt_exec = sys_rt_exec_accessory_override;
  if (rt_exec) {
    system_clear_exec_accessory_overrides(); // Clear all accessory override flags.

    // NOTE: Unlike motion overrides, spindle overrides do not require a planner reinitialization.
    uint8_t last_s_override =  sys.spindle_speed_ovr;
    2cae:	89 2f       	mov	r24, r25
    2cb0:	01 c0       	rjmp	.+2      	; 0x2cb4 <protocol_exec_rt_system+0x2a4>
    if (rt_exec & EXEC_SPINDLE_OVR_RESET) { last_s_override = DEFAULT_SPINDLE_SPEED_OVERRIDE; }
    2cb2:	84 e6       	ldi	r24, 0x64	; 100
    if (rt_exec & EXEC_SPINDLE_OVR_COARSE_PLUS) { last_s_override += SPINDLE_OVERRIDE_COARSE_INCREMENT; }
    2cb4:	c1 fd       	sbrc	r28, 1
    2cb6:	86 5f       	subi	r24, 0xF6	; 246
    if (rt_exec & EXEC_SPINDLE_OVR_COARSE_MINUS) { last_s_override -= SPINDLE_OVERRIDE_COARSE_INCREMENT; }
    2cb8:	c2 fd       	sbrc	r28, 2
    2cba:	8a 50       	subi	r24, 0x0A	; 10
    if (rt_exec & EXEC_SPINDLE_OVR_FINE_PLUS) { last_s_override += SPINDLE_OVERRIDE_FINE_INCREMENT; }
    2cbc:	c3 fd       	sbrc	r28, 3
    2cbe:	8f 5f       	subi	r24, 0xFF	; 255
    if (rt_exec & EXEC_SPINDLE_OVR_FINE_MINUS) { last_s_override -= SPINDLE_OVERRIDE_FINE_INCREMENT; }
    2cc0:	c4 fd       	sbrc	r28, 4
    2cc2:	81 50       	subi	r24, 0x01	; 1
    last_s_override = min(last_s_override,MAX_SPINDLE_SPEED_OVERRIDE);
    2cc4:	89 3c       	cpi	r24, 0xC9	; 201
    2cc6:	08 f0       	brcs	.+2      	; 0x2cca <protocol_exec_rt_system+0x2ba>
    2cc8:	88 ec       	ldi	r24, 0xC8	; 200
    last_s_override = max(last_s_override,MIN_SPINDLE_SPEED_OVERRIDE);
    2cca:	8a 30       	cpi	r24, 0x0A	; 10
    2ccc:	08 f4       	brcc	.+2      	; 0x2cd0 <protocol_exec_rt_system+0x2c0>
    2cce:	8a e0       	ldi	r24, 0x0A	; 10

    if (last_s_override != sys.spindle_speed_ovr) {
    2cd0:	98 17       	cp	r25, r24
    2cd2:	b1 f0       	breq	.+44     	; 0x2d00 <protocol_exec_rt_system+0x2f0>
      sys.spindle_speed_ovr = last_s_override;
    2cd4:	e1 e1       	ldi	r30, 0x11	; 17
    2cd6:	fc e0       	ldi	r31, 0x0C	; 12
    2cd8:	81 87       	std	Z+9, r24	; 0x09
      // NOTE: Spindle speed overrides during HOLD state are taken care of by suspend function.
      if (sys.state == STATE_IDLE) { spindle_set_state(gc_state.modal.spindle, gc_state.spindle_speed); }
    2cda:	80 81       	ld	r24, Z
    2cdc:	81 11       	cpse	r24, r1
    2cde:	09 c0       	rjmp	.+18     	; 0x2cf2 <protocol_exec_rt_system+0x2e2>
    2ce0:	ef e3       	ldi	r30, 0x3F	; 63
    2ce2:	fc e0       	ldi	r31, 0x0C	; 12
    2ce4:	43 85       	ldd	r20, Z+11	; 0x0b
    2ce6:	54 85       	ldd	r21, Z+12	; 0x0c
    2ce8:	65 85       	ldd	r22, Z+13	; 0x0d
    2cea:	76 85       	ldd	r23, Z+14	; 0x0e
    2cec:	81 85       	ldd	r24, Z+9	; 0x09
    2cee:	ca dc       	rcall	.-1644   	; 0x2684 <spindle_set_state>
    2cf0:	05 c0       	rjmp	.+10     	; 0x2cfc <protocol_exec_rt_system+0x2ec>
			else { bit_true(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM); }
    2cf2:	e1 e1       	ldi	r30, 0x11	; 17
    2cf4:	fc e0       	ldi	r31, 0x0C	; 12
    2cf6:	84 81       	ldd	r24, Z+4	; 0x04
    2cf8:	88 60       	ori	r24, 0x08	; 8
    2cfa:	84 83       	std	Z+4, r24	; 0x04
      sys.report_ovr_counter = 0; // Set to report change immediately
    2cfc:	10 92 1c 0c 	sts	0x0C1C, r1	; 0x800c1c <sys+0xb>
    }

    if (rt_exec & EXEC_SPINDLE_OVR_STOP) {
    2d00:	c5 ff       	sbrs	r28, 5
    2d02:	11 c0       	rjmp	.+34     	; 0x2d26 <protocol_exec_rt_system+0x316>
      // Spindle stop override allowed only while in HOLD state.
      // NOTE: Report counters are set in spindle_set_state() when spindle stop is executed.
      if (sys.state == STATE_HOLD) {
    2d04:	80 91 11 0c 	lds	r24, 0x0C11	; 0x800c11 <sys>
    2d08:	80 31       	cpi	r24, 0x10	; 16
    2d0a:	69 f4       	brne	.+26     	; 0x2d26 <protocol_exec_rt_system+0x316>
        if (!(sys.spindle_stop_ovr)) { sys.spindle_stop_ovr = SPINDLE_STOP_OVR_INITIATE; }
    2d0c:	80 91 1b 0c 	lds	r24, 0x0C1B	; 0x800c1b <sys+0xa>
    2d10:	81 11       	cpse	r24, r1
    2d12:	04 c0       	rjmp	.+8      	; 0x2d1c <protocol_exec_rt_system+0x30c>
    2d14:	82 e0       	ldi	r24, 0x02	; 2
    2d16:	80 93 1b 0c 	sts	0x0C1B, r24	; 0x800c1b <sys+0xa>
    2d1a:	05 c0       	rjmp	.+10     	; 0x2d26 <protocol_exec_rt_system+0x316>
        else if (sys.spindle_stop_ovr & SPINDLE_STOP_OVR_ENABLED) { sys.spindle_stop_ovr |= SPINDLE_STOP_OVR_RESTORE; }
    2d1c:	80 ff       	sbrs	r24, 0
    2d1e:	03 c0       	rjmp	.+6      	; 0x2d26 <protocol_exec_rt_system+0x316>
    2d20:	84 60       	ori	r24, 0x04	; 4
    2d22:	80 93 1b 0c 	sts	0x0C1B, r24	; 0x800c1b <sys+0xa>
    }

    // NOTE: Since coolant state always performs a planner sync whenever it changes, the current
    // run state can be determined by checking the parser state.
    // NOTE: Coolant overrides only operate during IDLE, CYCLE, HOLD, and JOG states. Ignored otherwise.																										
    if (rt_exec & (EXEC_COOLANT_FLOOD_OVR_TOGGLE | EXEC_COOLANT_MIST_OVR_TOGGLE)) {
    2d26:	8c 2f       	mov	r24, r28
    2d28:	80 7c       	andi	r24, 0xC0	; 192
    2d2a:	d1 f0       	breq	.+52     	; 0x2d60 <protocol_exec_rt_system+0x350>
      if ((sys.state == STATE_IDLE) || (sys.state & (STATE_CYCLE | STATE_HOLD | STATE_JOG))) {
    2d2c:	80 91 11 0c 	lds	r24, 0x0C11	; 0x800c11 <sys>
    2d30:	88 23       	and	r24, r24
    2d32:	11 f0       	breq	.+4      	; 0x2d38 <protocol_exec_rt_system+0x328>
    2d34:	88 73       	andi	r24, 0x38	; 56
    2d36:	a1 f0       	breq	.+40     	; 0x2d60 <protocol_exec_rt_system+0x350>
        uint8_t coolant_state = gc_state.modal.coolant;
    2d38:	d0 91 47 0c 	lds	r29, 0x0C47	; 0x800c47 <gc_state+0x8>
        if (rt_exec & EXEC_COOLANT_MIST_OVR_TOGGLE) {
    2d3c:	cc 23       	and	r28, r28
    2d3e:	2c f4       	brge	.+10     	; 0x2d4a <protocol_exec_rt_system+0x33a>
          if (coolant_state & COOLANT_MIST_ENABLE) { bit_false(coolant_state,COOLANT_MIST_ENABLE); }
    2d40:	dd 23       	and	r29, r29
    2d42:	14 f4       	brge	.+4      	; 0x2d48 <protocol_exec_rt_system+0x338>
    2d44:	df 77       	andi	r29, 0x7F	; 127
    2d46:	01 c0       	rjmp	.+2      	; 0x2d4a <protocol_exec_rt_system+0x33a>
          else { coolant_state |= COOLANT_MIST_ENABLE; }
    2d48:	d0 68       	ori	r29, 0x80	; 128
        }
        if (rt_exec & EXEC_COOLANT_FLOOD_OVR_TOGGLE) {
    2d4a:	c6 ff       	sbrs	r28, 6
    2d4c:	05 c0       	rjmp	.+10     	; 0x2d58 <protocol_exec_rt_system+0x348>
          if (coolant_state & COOLANT_FLOOD_ENABLE) { bit_false(coolant_state,COOLANT_FLOOD_ENABLE); }
    2d4e:	d6 ff       	sbrs	r29, 6
    2d50:	02 c0       	rjmp	.+4      	; 0x2d56 <protocol_exec_rt_system+0x346>
    2d52:	df 7b       	andi	r29, 0xBF	; 191
          else { coolant_state |= COOLANT_FLOOD_ENABLE; }
    2d54:	01 c0       	rjmp	.+2      	; 0x2d58 <protocol_exec_rt_system+0x348>
        }
        coolant_set_state(coolant_state); // Report counter set in coolant_set_state().
    2d56:	d0 64       	ori	r29, 0x40	; 64
    2d58:	8d 2f       	mov	r24, r29
    2d5a:	f8 dc       	rcall	.-1552   	; 0x274c <coolant_set_state>
        gc_state.modal.coolant = coolant_state;
    2d5c:	d0 93 47 0c 	sts	0x0C47, r29	; 0x800c47 <gc_state+0x8>
      }
    }
  }

  #ifdef DEBUG
    if (sys_rt_exec_debug) {
    2d60:	80 91 3e 0c 	lds	r24, 0x0C3E	; 0x800c3e <sys_rt_exec_debug>
    2d64:	88 23       	and	r24, r24
    2d66:	21 f0       	breq	.+8      	; 0x2d70 <protocol_exec_rt_system+0x360>
      report_realtime_debug();
    2d68:	0e 94 32 38 	call	0x7064	; 0x7064 <report_realtime_debug>
      sys_rt_exec_debug = 0;
    2d6c:	10 92 3e 0c 	sts	0x0C3E, r1	; 0x800c3e <sys_rt_exec_debug>
    }
  #endif

  // Reload step segment buffer
  if (sys.state & (STATE_CYCLE | STATE_HOLD | STATE_SAFETY_DOOR | STATE_HOMING | STATE_SLEEP| STATE_JOG)) {
    2d70:	80 91 11 0c 	lds	r24, 0x0C11	; 0x800c11 <sys>
    2d74:	8c 7f       	andi	r24, 0xFC	; 252
    st_prep_buffer();
    2d76:	09 f0       	breq	.+2      	; 0x2d7a <protocol_exec_rt_system+0x36a>
    2d78:	c9 d4       	rcall	.+2450   	; 0x370c <st_prep_buffer>
  }

}
    2d7a:	df 91       	pop	r29
    2d7c:	cf 91       	pop	r28
    2d7e:	08 95       	ret

00002d80 <protocol_exec_rt_suspend>:
// The system will enter this loop, create local variables for suspend tasks, and return to
// whatever function that invoked the suspend, such that Grbl resumes normal operation.
// This function is written in a way to promote custom parking motions. Simply use this as a
// template
static void protocol_exec_rt_suspend()
{
    2d80:	cf 92       	push	r12
    2d82:	df 92       	push	r13
    2d84:	ef 92       	push	r14
    2d86:	ff 92       	push	r15
    2d88:	1f 93       	push	r17
    2d8a:	cf 93       	push	r28
    2d8c:	df 93       	push	r29
    memset(pl_data,0,sizeof(plan_line_data_t));
    pl_data->condition = (PL_COND_FLAG_SYSTEM_MOTION|PL_COND_FLAG_NO_FEED_OVERRIDE);
    pl_data->line_number = PARKING_MOTION_LINE_NUMBER;
  #endif

  plan_block_t *block = plan_get_current_block();
    2d8e:	0e 94 c3 28 	call	0x5186	; 0x5186 <plan_get_current_block>
    2d92:	ec 01       	movw	r28, r24
  uint8_t restore_condition;
  float restore_spindle_speed;
  if (block == NULL) {
    2d94:	89 2b       	or	r24, r25
    2d96:	51 f4       	brne	.+20     	; 0x2dac <protocol_exec_rt_suspend+0x2c>
    restore_condition = (gc_state.modal.spindle | gc_state.modal.coolant);
    2d98:	ef e3       	ldi	r30, 0x3F	; 63
    2d9a:	fc e0       	ldi	r31, 0x0C	; 12
    2d9c:	11 85       	ldd	r17, Z+9	; 0x09
    2d9e:	80 85       	ldd	r24, Z+8	; 0x08
    2da0:	18 2b       	or	r17, r24
    restore_spindle_speed = gc_state.spindle_speed;
    2da2:	c3 84       	ldd	r12, Z+11	; 0x0b
    2da4:	d4 84       	ldd	r13, Z+12	; 0x0c
    2da6:	e5 84       	ldd	r14, Z+13	; 0x0d
    2da8:	f6 84       	ldd	r15, Z+14	; 0x0e
    2daa:	08 c0       	rjmp	.+16     	; 0x2dbc <protocol_exec_rt_suspend+0x3c>
  } else {
    restore_condition = (block->condition & PL_COND_SPINDLE_MASK) | coolant_get_state();
    2dac:	19 89       	ldd	r17, Y+17	; 0x11
    2dae:	af dc       	rcall	.-1698   	; 0x270e <coolant_get_state>
    2db0:	10 73       	andi	r17, 0x30	; 48
    2db2:	18 2b       	or	r17, r24
    restore_spindle_speed = block->spindle_speed;
    2db4:	ca a8       	ldd	r12, Y+50	; 0x32
    2db6:	db a8       	ldd	r13, Y+51	; 0x33
    2db8:	ec a8       	ldd	r14, Y+52	; 0x34
    2dba:	fd a8       	ldd	r15, Y+53	; 0x35
  }
  #ifdef DISABLE_LASER_DURING_HOLD
    if (bit_istrue(settings.flags,BITFLAG_LASER_MODE)) { 
    2dbc:	80 91 fe 0e 	lds	r24, 0x0EFE	; 0x800efe <settings+0x45>
    2dc0:	81 ff       	sbrs	r24, 1
    2dc2:	c4 c0       	rjmp	.+392    	; 0x2f4c <protocol_exec_rt_suspend+0x1cc>
      system_set_exec_accessory_override_flag(EXEC_SPINDLE_OVR_STOP);
    2dc4:	80 e2       	ldi	r24, 0x20	; 32
    2dc6:	0e 94 b9 3b 	call	0x7772	; 0x7772 <system_set_exec_accessory_override_flag>
    2dca:	c0 c0       	rjmp	.+384    	; 0x2f4c <protocol_exec_rt_suspend+0x1cc>
    }
  #endif

  while (sys.suspend) {

    if (sys.abort) { return; }
    2dcc:	90 91 12 0c 	lds	r25, 0x0C12	; 0x800c12 <sys+0x1>
    2dd0:	91 11       	cpse	r25, r1
    2dd2:	c0 c0       	rjmp	.+384    	; 0x2f54 <protocol_exec_rt_suspend+0x1d4>

    // Block until initial hold is complete and the machine has stopped motion.
    if (sys.suspend & SUSPEND_HOLD_COMPLETE) {
    2dd4:	80 ff       	sbrs	r24, 0
    2dd6:	b9 c0       	rjmp	.+370    	; 0x2f4a <protocol_exec_rt_suspend+0x1ca>

      // Parking manager. Handles de/re-energizing, switch state checks, and parking motions for 
      // the safety door and sleep states.
      if (sys.state & (STATE_SAFETY_DOOR | STATE_SLEEP)) {
    2dd8:	90 91 11 0c 	lds	r25, 0x0C11	; 0x800c11 <sys>
    2ddc:	29 2f       	mov	r18, r25
    2dde:	20 7c       	andi	r18, 0xC0	; 192
    2de0:	09 f4       	brne	.+2      	; 0x2de4 <protocol_exec_rt_suspend+0x64>
    2de2:	6d c0       	rjmp	.+218    	; 0x2ebe <protocol_exec_rt_suspend+0x13e>
      
        // Handles retraction motions and de-energizing.
        if (bit_isfalse(sys.suspend,SUSPEND_RETRACT_COMPLETE)) {
    2de4:	82 fd       	sbrc	r24, 2
    2de6:	0f c0       	rjmp	.+30     	; 0x2e06 <protocol_exec_rt_suspend+0x86>

          // Ensure any prior spindle stop override is disabled at start of safety door routine.
          sys.spindle_stop_ovr = SPINDLE_STOP_OVR_DISABLED;
    2de8:	c1 e1       	ldi	r28, 0x11	; 17
    2dea:	dc e0       	ldi	r29, 0x0C	; 12
    2dec:	1a 86       	std	Y+10, r1	; 0x0a

          #ifndef PARKING_ENABLE

            spindle_set_state(SPINDLE_DISABLE,0.0); // De-energize
    2dee:	40 e0       	ldi	r20, 0x00	; 0
    2df0:	50 e0       	ldi	r21, 0x00	; 0
    2df2:	ba 01       	movw	r22, r20
    2df4:	80 e0       	ldi	r24, 0x00	; 0
    2df6:	46 dc       	rcall	.-1908   	; 0x2684 <spindle_set_state>
            coolant_set_state(COOLANT_DISABLE);     // De-energize
    2df8:	80 e0       	ldi	r24, 0x00	; 0
    2dfa:	a8 dc       	rcall	.-1712   	; 0x274c <coolant_set_state>
    2dfc:	8a 81       	ldd	r24, Y+2	; 0x02

            }

          #endif

          sys.suspend &= ~(SUSPEND_RESTART_RETRACT);
    2dfe:	8d 7f       	andi	r24, 0xFD	; 253
    2e00:	84 60       	ori	r24, 0x04	; 4
          sys.suspend |= SUSPEND_RETRACT_COMPLETE;
    2e02:	8a 83       	std	Y+2, r24	; 0x02
    2e04:	a2 c0       	rjmp	.+324    	; 0x2f4a <protocol_exec_rt_suspend+0x1ca>
    2e06:	90 38       	cpi	r25, 0x80	; 128

        } else {

          
          if (sys.state == STATE_SLEEP) {
    2e08:	91 f4       	brne	.+36     	; 0x2e2e <protocol_exec_rt_suspend+0xae>
    2e0a:	8b e0       	ldi	r24, 0x0B	; 11
            report_feedback_message(MESSAGE_SLEEP_MODE);
    2e0c:	0e 94 95 33 	call	0x672a	; 0x672a <report_feedback_message>
    2e10:	40 e0       	ldi	r20, 0x00	; 0
            // Spindle and coolant should already be stopped, but do it again just to be sure.
            spindle_set_state(SPINDLE_DISABLE,0.0); // De-energize
    2e12:	50 e0       	ldi	r21, 0x00	; 0
    2e14:	ba 01       	movw	r22, r20
    2e16:	80 e0       	ldi	r24, 0x00	; 0
    2e18:	35 dc       	rcall	.-1942   	; 0x2684 <spindle_set_state>
            coolant_set_state(COOLANT_DISABLE); // De-energize
    2e1a:	80 e0       	ldi	r24, 0x00	; 0
    2e1c:	97 dc       	rcall	.-1746   	; 0x274c <coolant_set_state>
            st_go_idle(); // Disable steppers
    2e1e:	82 d1       	rcall	.+772    	; 0x3124 <st_go_idle>
    2e20:	01 c0       	rjmp	.+2      	; 0x2e24 <protocol_exec_rt_suspend+0xa4>
            while (!(sys.abort)) { protocol_exec_rt_system(); } // Do nothing until reset.
    2e22:	f6 dd       	rcall	.-1044   	; 0x2a10 <protocol_exec_rt_system>
    2e24:	80 91 12 0c 	lds	r24, 0x0C12	; 0x800c12 <sys+0x1>
    2e28:	88 23       	and	r24, r24
    2e2a:	d9 f3       	breq	.-10     	; 0x2e22 <protocol_exec_rt_suspend+0xa2>
    2e2c:	93 c0       	rjmp	.+294    	; 0x2f54 <protocol_exec_rt_suspend+0x1d4>
    2e2e:	90 34       	cpi	r25, 0x40	; 64
    2e30:	49 f4       	brne	.+18     	; 0x2e44 <protocol_exec_rt_suspend+0xc4>
            return; // Abort received. Return to re-initialize.
          }    
          
          // Allows resuming from parking/safety door. Actively checks if safety door is closed and ready to resume.
          if (sys.state == STATE_SAFETY_DOOR) {
    2e32:	0e 94 a1 38 	call	0x7142	; 0x7142 <system_check_safety_door_ajar>
            if (!(system_check_safety_door_ajar())) {
    2e36:	81 11       	cpse	r24, r1
    2e38:	05 c0       	rjmp	.+10     	; 0x2e44 <protocol_exec_rt_suspend+0xc4>
    2e3a:	e1 e1       	ldi	r30, 0x11	; 17
    2e3c:	fc e0       	ldi	r31, 0x0C	; 12
              sys.suspend &= ~(SUSPEND_SAFETY_DOOR_AJAR); // Reset door ajar flag to denote ready to resume.
    2e3e:	82 81       	ldd	r24, Z+2	; 0x02
    2e40:	8f 7d       	andi	r24, 0xDF	; 223
    2e42:	82 83       	std	Z+2, r24	; 0x02
    2e44:	80 91 13 0c 	lds	r24, 0x0C13	; 0x800c13 <sys+0x2>
            }
          }

          // Handles parking restore and safety door resume.
          if (sys.suspend & SUSPEND_INITIATE_RESTORE) {
    2e48:	83 ff       	sbrs	r24, 3
    2e4a:	7f c0       	rjmp	.+254    	; 0x2f4a <protocol_exec_rt_suspend+0x1ca>
    2e4c:	90 91 48 0c 	lds	r25, 0x0C48	; 0x800c48 <gc_state+0x9>
                }
              }
            #endif

            // Delayed Tasks: Restart spindle and coolant, delay to power-up, then resume cycle.
            if (gc_state.modal.spindle != SPINDLE_DISABLE) {
    2e50:	99 23       	and	r25, r25
    2e52:	c1 f0       	breq	.+48     	; 0x2e84 <protocol_exec_rt_suspend+0x104>
    2e54:	81 fd       	sbrc	r24, 1
    2e56:	16 c0       	rjmp	.+44     	; 0x2e84 <protocol_exec_rt_suspend+0x104>
              // Block if safety door re-opened during prior restore actions.
              if (bit_isfalse(sys.suspend,SUSPEND_RESTART_RETRACT)) {
    2e58:	80 91 fe 0e 	lds	r24, 0x0EFE	; 0x800efe <settings+0x45>
                if (bit_istrue(settings.flags,BITFLAG_LASER_MODE)) {
    2e5c:	81 ff       	sbrs	r24, 1
    2e5e:	06 c0       	rjmp	.+12     	; 0x2e6c <protocol_exec_rt_suspend+0xec>
    2e60:	e1 e1       	ldi	r30, 0x11	; 17
    2e62:	fc e0       	ldi	r31, 0x0C	; 12
                  // When in laser mode, ignore spindle spin-up delay. Set to turn on laser when cycle starts.
                  bit_true(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM);
    2e64:	84 81       	ldd	r24, Z+4	; 0x04
    2e66:	88 60       	ori	r24, 0x08	; 8
    2e68:	84 83       	std	Z+4, r24	; 0x04
    2e6a:	0c c0       	rjmp	.+24     	; 0x2e84 <protocol_exec_rt_suspend+0x104>
    2e6c:	b7 01       	movw	r22, r14
                } else {
                  spindle_set_state((restore_condition & (PL_COND_FLAG_SPINDLE_CW | PL_COND_FLAG_SPINDLE_CCW)), restore_spindle_speed);
    2e6e:	a6 01       	movw	r20, r12
    2e70:	81 2f       	mov	r24, r17
    2e72:	80 73       	andi	r24, 0x30	; 48
    2e74:	07 dc       	rcall	.-2034   	; 0x2684 <spindle_set_state>
    2e76:	41 e0       	ldi	r20, 0x01	; 1
    2e78:	60 e0       	ldi	r22, 0x00	; 0
                  delay_sec(SAFETY_DOOR_SPINDLE_DELAY, DELAY_MODE_SYS_SUSPEND);
    2e7a:	70 e0       	ldi	r23, 0x00	; 0
    2e7c:	80 e8       	ldi	r24, 0x80	; 128
    2e7e:	90 e4       	ldi	r25, 0x40	; 64
    2e80:	0e 94 64 2d 	call	0x5ac8	; 0x5ac8 <delay_sec>
    2e84:	80 91 47 0c 	lds	r24, 0x0C47	; 0x800c47 <gc_state+0x8>
                }
              }
            }
            if (gc_state.modal.coolant != COOLANT_DISABLE) {
    2e88:	88 23       	and	r24, r24
    2e8a:	71 f0       	breq	.+28     	; 0x2ea8 <protocol_exec_rt_suspend+0x128>
    2e8c:	80 91 13 0c 	lds	r24, 0x0C13	; 0x800c13 <sys+0x2>
              // Block if safety door re-opened during prior restore actions.
              if (bit_isfalse(sys.suspend,SUSPEND_RESTART_RETRACT)) {
    2e90:	81 fd       	sbrc	r24, 1
    2e92:	0a c0       	rjmp	.+20     	; 0x2ea8 <protocol_exec_rt_suspend+0x128>
    2e94:	81 2f       	mov	r24, r17
                // NOTE: Laser mode will honor this delay. An exhaust system is often controlled by this pin.
                coolant_set_state((restore_condition & (PL_COND_FLAG_COOLANT_FLOOD | PL_COND_FLAG_COOLANT_MIST)));
    2e96:	80 7c       	andi	r24, 0xC0	; 192
    2e98:	59 dc       	rcall	.-1870   	; 0x274c <coolant_set_state>
    2e9a:	41 e0       	ldi	r20, 0x01	; 1
    2e9c:	60 e0       	ldi	r22, 0x00	; 0
                delay_sec(SAFETY_DOOR_COOLANT_DELAY, DELAY_MODE_SYS_SUSPEND);
    2e9e:	70 e0       	ldi	r23, 0x00	; 0
    2ea0:	80 e8       	ldi	r24, 0x80	; 128
    2ea2:	9f e3       	ldi	r25, 0x3F	; 63
    2ea4:	0e 94 64 2d 	call	0x5ac8	; 0x5ac8 <delay_sec>
    2ea8:	80 91 13 0c 	lds	r24, 0x0C13	; 0x800c13 <sys+0x2>
                  mc_parking_motion(restore_target, pl_data);
                }
              }
            #endif

            if (bit_isfalse(sys.suspend,SUSPEND_RESTART_RETRACT)) {
    2eac:	81 fd       	sbrc	r24, 1
    2eae:	4d c0       	rjmp	.+154    	; 0x2f4a <protocol_exec_rt_suspend+0x1ca>
    2eb0:	80 61       	ori	r24, 0x10	; 16
    2eb2:	80 93 13 0c 	sts	0x0C13, r24	; 0x800c13 <sys+0x2>
              sys.suspend |= SUSPEND_RESTORE_COMPLETE;
    2eb6:	82 e0       	ldi	r24, 0x02	; 2
    2eb8:	0e 94 4b 39 	call	0x7296	; 0x7296 <system_set_exec_state_flag>
              system_set_exec_state_flag(EXEC_CYCLE_START); // Set to resume program.
    2ebc:	46 c0       	rjmp	.+140    	; 0x2f4a <protocol_exec_rt_suspend+0x1ca>
    2ebe:	80 91 1b 0c 	lds	r24, 0x0C1B	; 0x800c1b <sys+0xa>

      } else {

        // Feed hold manager. Controls spindle stop override states.
        // NOTE: Hold ensured as completed by condition check at the beginning of suspend routine.
        if (sys.spindle_stop_ovr) {
    2ec2:	88 23       	and	r24, r24
    2ec4:	a1 f1       	breq	.+104    	; 0x2f2e <protocol_exec_rt_suspend+0x1ae>
    2ec6:	81 ff       	sbrs	r24, 1
    2ec8:	10 c0       	rjmp	.+32     	; 0x2eea <protocol_exec_rt_suspend+0x16a>
          // Handles beginning of spindle stop
          if (sys.spindle_stop_ovr & SPINDLE_STOP_OVR_INITIATE) {
    2eca:	80 91 48 0c 	lds	r24, 0x0C48	; 0x800c48 <gc_state+0x9>
            if (gc_state.modal.spindle != SPINDLE_DISABLE) {
    2ece:	88 23       	and	r24, r24
    2ed0:	49 f0       	breq	.+18     	; 0x2ee4 <protocol_exec_rt_suspend+0x164>
    2ed2:	40 e0       	ldi	r20, 0x00	; 0
              spindle_set_state(SPINDLE_DISABLE,0.0); // De-energize
    2ed4:	50 e0       	ldi	r21, 0x00	; 0
    2ed6:	ba 01       	movw	r22, r20
    2ed8:	80 e0       	ldi	r24, 0x00	; 0
    2eda:	d4 db       	rcall	.-2136   	; 0x2684 <spindle_set_state>
    2edc:	81 e0       	ldi	r24, 0x01	; 1
    2ede:	80 93 1b 0c 	sts	0x0C1B, r24	; 0x800c1b <sys+0xa>
              sys.spindle_stop_ovr = SPINDLE_STOP_OVR_ENABLED; // Set stop override state to enabled, if de-energized.
    2ee2:	33 c0       	rjmp	.+102    	; 0x2f4a <protocol_exec_rt_suspend+0x1ca>
    2ee4:	10 92 1b 0c 	sts	0x0C1B, r1	; 0x800c1b <sys+0xa>
            } else {
              sys.spindle_stop_ovr = SPINDLE_STOP_OVR_DISABLED; // Clear stop override state
    2ee8:	30 c0       	rjmp	.+96     	; 0x2f4a <protocol_exec_rt_suspend+0x1ca>
    2eea:	8c 70       	andi	r24, 0x0C	; 12
    2eec:	71 f1       	breq	.+92     	; 0x2f4a <protocol_exec_rt_suspend+0x1ca>
            }
          // Handles restoring of spindle state
          } else if (sys.spindle_stop_ovr & (SPINDLE_STOP_OVR_RESTORE | SPINDLE_STOP_OVR_RESTORE_CYCLE)) {
    2eee:	80 91 48 0c 	lds	r24, 0x0C48	; 0x800c48 <gc_state+0x9>
            if (gc_state.modal.spindle != SPINDLE_DISABLE) {
    2ef2:	88 23       	and	r24, r24
    2ef4:	91 f0       	breq	.+36     	; 0x2f1a <protocol_exec_rt_suspend+0x19a>
    2ef6:	8a e0       	ldi	r24, 0x0A	; 10
    2ef8:	0e 94 95 33 	call	0x672a	; 0x672a <report_feedback_message>
              report_feedback_message(MESSAGE_SPINDLE_RESTORE);
    2efc:	80 91 fe 0e 	lds	r24, 0x0EFE	; 0x800efe <settings+0x45>
              if (bit_istrue(settings.flags,BITFLAG_LASER_MODE)) {
    2f00:	81 ff       	sbrs	r24, 1
    2f02:	06 c0       	rjmp	.+12     	; 0x2f10 <protocol_exec_rt_suspend+0x190>
    2f04:	e1 e1       	ldi	r30, 0x11	; 17
    2f06:	fc e0       	ldi	r31, 0x0C	; 12
                // When in laser mode, ignore spindle spin-up delay. Set to turn on laser when cycle starts.
                bit_true(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM);
    2f08:	84 81       	ldd	r24, Z+4	; 0x04
    2f0a:	88 60       	ori	r24, 0x08	; 8
    2f0c:	84 83       	std	Z+4, r24	; 0x04
    2f0e:	05 c0       	rjmp	.+10     	; 0x2f1a <protocol_exec_rt_suspend+0x19a>
    2f10:	b7 01       	movw	r22, r14
              } else {
                spindle_set_state((restore_condition & (PL_COND_FLAG_SPINDLE_CW | PL_COND_FLAG_SPINDLE_CCW)), restore_spindle_speed);
    2f12:	a6 01       	movw	r20, r12
    2f14:	81 2f       	mov	r24, r17
    2f16:	80 73       	andi	r24, 0x30	; 48
    2f18:	b5 db       	rcall	.-2198   	; 0x2684 <spindle_set_state>
    2f1a:	80 91 1b 0c 	lds	r24, 0x0C1B	; 0x800c1b <sys+0xa>
              }
            }
            if (sys.spindle_stop_ovr & SPINDLE_STOP_OVR_RESTORE_CYCLE) {
    2f1e:	83 ff       	sbrs	r24, 3
    2f20:	03 c0       	rjmp	.+6      	; 0x2f28 <protocol_exec_rt_suspend+0x1a8>
    2f22:	82 e0       	ldi	r24, 0x02	; 2
    2f24:	0e 94 4b 39 	call	0x7296	; 0x7296 <system_set_exec_state_flag>
              system_set_exec_state_flag(EXEC_CYCLE_START);  // Set to resume program.
    2f28:	10 92 1b 0c 	sts	0x0C1B, r1	; 0x800c1b <sys+0xa>
            }
            sys.spindle_stop_ovr = SPINDLE_STOP_OVR_DISABLED; // Clear stop override state
    2f2c:	0e c0       	rjmp	.+28     	; 0x2f4a <protocol_exec_rt_suspend+0x1ca>
    2f2e:	80 91 15 0c 	lds	r24, 0x0C15	; 0x800c15 <sys+0x4>
          }
        } else {
          // Handles spindle state during hold. NOTE: Spindle speed overrides may be altered during hold state.
          // NOTE: STEP_CONTROL_UPDATE_SPINDLE_PWM is automatically reset upon resume in step generator.
          if (bit_istrue(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM)) {
    2f32:	83 ff       	sbrs	r24, 3
    2f34:	0a c0       	rjmp	.+20     	; 0x2f4a <protocol_exec_rt_suspend+0x1ca>
            spindle_set_state((restore_condition & (PL_COND_FLAG_SPINDLE_CW | PL_COND_FLAG_SPINDLE_CCW)), restore_spindle_speed);
    2f36:	b7 01       	movw	r22, r14
    2f38:	a6 01       	movw	r20, r12
    2f3a:	81 2f       	mov	r24, r17
    2f3c:	80 73       	andi	r24, 0x30	; 48
    2f3e:	a2 db       	rcall	.-2236   	; 0x2684 <spindle_set_state>
    2f40:	e1 e1       	ldi	r30, 0x11	; 17
            bit_false(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM);
    2f42:	fc e0       	ldi	r31, 0x0C	; 12
    2f44:	84 81       	ldd	r24, Z+4	; 0x04
    2f46:	87 7f       	andi	r24, 0xF7	; 247
    2f48:	84 83       	std	Z+4, r24	; 0x04
    2f4a:	62 dd       	rcall	.-1340   	; 0x2a10 <protocol_exec_rt_system>
      // Sleep is valid for both hold and door states, if the spindle or coolant are on or
      // set to be re-enabled.
      sleep_check();
    #endif

    protocol_exec_rt_system();
    2f4c:	80 91 13 0c 	lds	r24, 0x0C13	; 0x800c13 <sys+0x2>
    if (bit_istrue(settings.flags,BITFLAG_LASER_MODE)) { 
      system_set_exec_accessory_override_flag(EXEC_SPINDLE_OVR_STOP);
    }
  #endif

  while (sys.suspend) {
    2f50:	81 11       	cpse	r24, r1
    2f52:	3c cf       	rjmp	.-392    	; 0x2dcc <protocol_exec_rt_suspend+0x4c>
    2f54:	df 91       	pop	r29
    2f56:	cf 91       	pop	r28
    #endif

    protocol_exec_rt_system();

  }
}
    2f58:	1f 91       	pop	r17
    2f5a:	ff 90       	pop	r15
    2f5c:	ef 90       	pop	r14
    2f5e:	df 90       	pop	r13
    2f60:	cf 90       	pop	r12
    2f62:	08 95       	ret

00002f64 <protocol_execute_realtime>:
    2f64:	55 dd       	rcall	.-1366   	; 0x2a10 <protocol_exec_rt_system>
    2f66:	80 91 13 0c 	lds	r24, 0x0C13	; 0x800c13 <sys+0x2>
// NOTE: The sys_rt_exec_state variable flags are set by any process, step or serial interrupts, pinouts,
// limit switches, or the main program.
void protocol_execute_realtime()
{
  protocol_exec_rt_system();
  if (sys.suspend) { protocol_exec_rt_suspend(); }
    2f6a:	81 11       	cpse	r24, r1
    2f6c:	09 cf       	rjmp	.-494    	; 0x2d80 <protocol_exec_rt_suspend>
    2f6e:	08 95       	ret

00002f70 <protocol_main_loop>:

/*
  GRBL PRIMARY LOOP:
*/
void protocol_main_loop()
{
    2f70:	cf 93       	push	r28
    2f72:	df 93       	push	r29
  // Perform some machine checks to make sure everything is good to go.
  #ifdef CHECK_LIMITS_AT_INIT
    if (bit_istrue(settings.flags, BITFLAG_HARD_LIMIT_ENABLE)) {
    2f74:	80 91 fe 0e 	lds	r24, 0x0EFE	; 0x800efe <settings+0x45>
    2f78:	83 ff       	sbrs	r24, 3
    2f7a:	0a c0       	rjmp	.+20     	; 0x2f90 <protocol_main_loop+0x20>
      if (limits_get_state()) {
    2f7c:	0e 94 ca 2e 	call	0x5d94	; 0x5d94 <limits_get_state>
    2f80:	88 23       	and	r24, r24
    2f82:	31 f0       	breq	.+12     	; 0x2f90 <protocol_main_loop+0x20>
        sys.state = STATE_ALARM; // Ensure alarm state is active.
    2f84:	81 e0       	ldi	r24, 0x01	; 1
    2f86:	80 93 11 0c 	sts	0x0C11, r24	; 0x800c11 <sys>
        report_feedback_message(MESSAGE_CHECK_LIMITS);
    2f8a:	87 e0       	ldi	r24, 0x07	; 7
    2f8c:	0e 94 95 33 	call	0x672a	; 0x672a <report_feedback_message>
    }
  #endif
  // Check for and report alarm state after a reset, error, or an initial power up.
  // NOTE: Sleep mode disables the stepper drivers and position can't be guaranteed.
  // Re-initialize the sleep state as an ALARM mode to ensure user homes or acknowledges.
  if (sys.state & (STATE_ALARM | STATE_SLEEP)) {
    2f90:	80 91 11 0c 	lds	r24, 0x0C11	; 0x800c11 <sys>
    2f94:	81 78       	andi	r24, 0x81	; 129
    2f96:	49 f0       	breq	.+18     	; 0x2faa <protocol_main_loop+0x3a>
    report_feedback_message(MESSAGE_ALARM_LOCK);
    2f98:	82 e0       	ldi	r24, 0x02	; 2
    2f9a:	0e 94 95 33 	call	0x672a	; 0x672a <report_feedback_message>
    sys.state = STATE_ALARM; // Ensure alarm state is set.
    2f9e:	81 e0       	ldi	r24, 0x01	; 1
    2fa0:	80 93 11 0c 	sts	0x0C11, r24	; 0x800c11 <sys>
          // Parse and execute g-code block.
          report_status_message(gc_execute_line(line));
        }

        // Reset tracking data for next line.
        line_flags = 0;
    2fa4:	c0 e0       	ldi	r28, 0x00	; 0
    2fa6:	d0 e0       	ldi	r29, 0x00	; 0
    2fa8:	78 c0       	rjmp	.+240    	; 0x309a <protocol_main_loop+0x12a>
  if (sys.state & (STATE_ALARM | STATE_SLEEP)) {
    report_feedback_message(MESSAGE_ALARM_LOCK);
    sys.state = STATE_ALARM; // Ensure alarm state is set.
  } else {
    // Check if the safety door is open.
    sys.state = STATE_IDLE;
    2faa:	10 92 11 0c 	sts	0x0C11, r1	; 0x800c11 <sys>
    if (system_check_safety_door_ajar()) {
    2fae:	0e 94 a1 38 	call	0x7142	; 0x7142 <system_check_safety_door_ajar>
    2fb2:	88 23       	and	r24, r24
    2fb4:	31 f0       	breq	.+12     	; 0x2fc2 <protocol_main_loop+0x52>
      bit_true(sys_rt_exec_state, EXEC_SAFETY_DOOR);
    2fb6:	80 91 23 0c 	lds	r24, 0x0C23	; 0x800c23 <sys_rt_exec_state>
    2fba:	80 62       	ori	r24, 0x20	; 32
    2fbc:	80 93 23 0c 	sts	0x0C23, r24	; 0x800c23 <sys_rt_exec_state>
      protocol_execute_realtime(); // Enter safety door mode. Should return as IDLE state.
    2fc0:	d1 df       	rcall	.-94     	; 0x2f64 <protocol_execute_realtime>
    }
    // All systems go!
    system_execute_startup(line); // Execute startup script.
    2fc2:	88 e0       	ldi	r24, 0x08	; 8
    2fc4:	92 e0       	ldi	r25, 0x02	; 2
    2fc6:	0e 94 a4 38 	call	0x7148	; 0x7148 <system_execute_startup>
    2fca:	ec cf       	rjmp	.-40     	; 0x2fa4 <protocol_main_loop+0x34>
  for (;;) {

    // Process one line of incoming serial data, as the data becomes available. Performs an
    // initial filtering by removing spaces and comments and capitalizing all letters.
    while((c = serial_read()) != SERIAL_NO_DATA) {
      if ((c == '\n') || (c == '\r')) { // End of line reached
    2fcc:	8a 30       	cpi	r24, 0x0A	; 10
    2fce:	11 f0       	breq	.+4      	; 0x2fd4 <protocol_main_loop+0x64>
    2fd0:	8d 30       	cpi	r24, 0x0D	; 13

        protocol_execute_realtime(); // Runtime command check point.
    2fd2:	c9 f5       	brne	.+114    	; 0x3046 <protocol_main_loop+0xd6>
    2fd4:	c7 df       	rcall	.-114    	; 0x2f64 <protocol_execute_realtime>
        if (sys.abort) { return; } // Bail to calling function upon system abort
    2fd6:	80 91 12 0c 	lds	r24, 0x0C12	; 0x800c12 <sys+0x1>
    2fda:	81 11       	cpse	r24, r1
    2fdc:	68 c0       	rjmp	.+208    	; 0x30ae <protocol_main_loop+0x13e>

        line[char_counter] = 0; // Set string termination character.
    2fde:	ec 2f       	mov	r30, r28
    2fe0:	f0 e0       	ldi	r31, 0x00	; 0
    2fe2:	e8 5f       	subi	r30, 0xF8	; 248
    2fe4:	fd 4f       	sbci	r31, 0xFD	; 253
    2fe6:	10 82       	st	Z, r1
        #ifdef REPORT_ECHO_LINE_RECEIVED
          report_echo_line_received(line);
        #endif

        // Direct and execute one line of formatted input, and report status of execution.
        if (line_flags & LINE_FLAG_OVERFLOW) {
    2fe8:	d0 ff       	sbrs	r29, 0
    2fea:	06 c0       	rjmp	.+12     	; 0x2ff8 <protocol_main_loop+0x88>
          // Report line overflow error.
          report_status_message(STATUS_OVERFLOW);
    2fec:	8b e0       	ldi	r24, 0x0B	; 11
    2fee:	0e 94 78 33 	call	0x66f0	; 0x66f0 <report_status_message>
          report_status_message(gc_execute_line(line));
        }

        // Reset tracking data for next line.
        line_flags = 0;
        char_counter = 0;
    2ff2:	c0 e0       	ldi	r28, 0x00	; 0
          // Parse and execute g-code block.
          report_status_message(gc_execute_line(line));
        }

        // Reset tracking data for next line.
        line_flags = 0;
    2ff4:	d0 e0       	ldi	r29, 0x00	; 0
    2ff6:	51 c0       	rjmp	.+162    	; 0x309a <protocol_main_loop+0x12a>

        // Direct and execute one line of formatted input, and report status of execution.
        if (line_flags & LINE_FLAG_OVERFLOW) {
          // Report line overflow error.
          report_status_message(STATUS_OVERFLOW);
        } else if (line[0] == 0) {
    2ff8:	80 91 08 02 	lds	r24, 0x0208	; 0x800208 <line>
    2ffc:	81 11       	cpse	r24, r1
    2ffe:	05 c0       	rjmp	.+10     	; 0x300a <protocol_main_loop+0x9a>
          // Empty or comment line. For syncing purposes.
          report_status_message(STATUS_OK);
    3000:	0e 94 78 33 	call	0x66f0	; 0x66f0 <report_status_message>
          report_status_message(gc_execute_line(line));
        }

        // Reset tracking data for next line.
        line_flags = 0;
        char_counter = 0;
    3004:	c0 e0       	ldi	r28, 0x00	; 0
          // Parse and execute g-code block.
          report_status_message(gc_execute_line(line));
        }

        // Reset tracking data for next line.
        line_flags = 0;
    3006:	d0 e0       	ldi	r29, 0x00	; 0
    3008:	48 c0       	rjmp	.+144    	; 0x309a <protocol_main_loop+0x12a>
          // Report line overflow error.
          report_status_message(STATUS_OVERFLOW);
        } else if (line[0] == 0) {
          // Empty or comment line. For syncing purposes.
          report_status_message(STATUS_OK);
        } else if (line[0] == '$') {
    300a:	84 32       	cpi	r24, 0x24	; 36
    300c:	49 f4       	brne	.+18     	; 0x3020 <protocol_main_loop+0xb0>
          // Grbl '$' system command
          report_status_message(system_execute_line(line));
    300e:	88 e0       	ldi	r24, 0x08	; 8
    3010:	92 e0       	ldi	r25, 0x02	; 2
    3012:	0e 94 54 39 	call	0x72a8	; 0x72a8 <system_execute_line>
    3016:	0e 94 78 33 	call	0x66f0	; 0x66f0 <report_status_message>
          report_status_message(gc_execute_line(line));
        }

        // Reset tracking data for next line.
        line_flags = 0;
        char_counter = 0;
    301a:	c0 e0       	ldi	r28, 0x00	; 0
          // Parse and execute g-code block.
          report_status_message(gc_execute_line(line));
        }

        // Reset tracking data for next line.
        line_flags = 0;
    301c:	d0 e0       	ldi	r29, 0x00	; 0
    301e:	3d c0       	rjmp	.+122    	; 0x309a <protocol_main_loop+0x12a>
          // Empty or comment line. For syncing purposes.
          report_status_message(STATUS_OK);
        } else if (line[0] == '$') {
          // Grbl '$' system command
          report_status_message(system_execute_line(line));
        } else if (sys.state & (STATE_ALARM | STATE_JOG)) {
    3020:	80 91 11 0c 	lds	r24, 0x0C11	; 0x800c11 <sys>
    3024:	81 72       	andi	r24, 0x21	; 33
    3026:	31 f0       	breq	.+12     	; 0x3034 <protocol_main_loop+0xc4>
          // Everything else is gcode. Block if in alarm or jog mode.
          report_status_message(STATUS_SYSTEM_GC_LOCK);
    3028:	89 e0       	ldi	r24, 0x09	; 9
    302a:	0e 94 78 33 	call	0x66f0	; 0x66f0 <report_status_message>
          report_status_message(gc_execute_line(line));
        }

        // Reset tracking data for next line.
        line_flags = 0;
        char_counter = 0;
    302e:	c0 e0       	ldi	r28, 0x00	; 0
          // Parse and execute g-code block.
          report_status_message(gc_execute_line(line));
        }

        // Reset tracking data for next line.
        line_flags = 0;
    3030:	d0 e0       	ldi	r29, 0x00	; 0
    3032:	33 c0       	rjmp	.+102    	; 0x309a <protocol_main_loop+0x12a>
        } else if (sys.state & (STATE_ALARM | STATE_JOG)) {
          // Everything else is gcode. Block if in alarm or jog mode.
          report_status_message(STATUS_SYSTEM_GC_LOCK);
        } else {
          // Parse and execute g-code block.
          report_status_message(gc_execute_line(line));
    3034:	88 e0       	ldi	r24, 0x08	; 8
    3036:	92 e0       	ldi	r25, 0x02	; 2
    3038:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <gc_execute_line>
    303c:	0e 94 78 33 	call	0x66f0	; 0x66f0 <report_status_message>
        }

        // Reset tracking data for next line.
        line_flags = 0;
        char_counter = 0;
    3040:	c0 e0       	ldi	r28, 0x00	; 0
          // Parse and execute g-code block.
          report_status_message(gc_execute_line(line));
        }

        // Reset tracking data for next line.
        line_flags = 0;
    3042:	d0 e0       	ldi	r29, 0x00	; 0
    3044:	2a c0       	rjmp	.+84     	; 0x309a <protocol_main_loop+0x12a>
        char_counter = 0;

      } else {

        if (line_flags) {
    3046:	dd 23       	and	r29, r29
    3048:	31 f0       	breq	.+12     	; 0x3056 <protocol_main_loop+0xe6>
          // Throw away all (except EOL) comment characters and overflow characters.
          if (c == ')') {
    304a:	89 32       	cpi	r24, 0x29	; 41
    304c:	31 f5       	brne	.+76     	; 0x309a <protocol_main_loop+0x12a>
            // End of '()' comment. Resume line allowed.
            if (line_flags & LINE_FLAG_COMMENT_PARENTHESES) { line_flags &= ~(LINE_FLAG_COMMENT_PARENTHESES); }
    304e:	d1 ff       	sbrs	r29, 1
    3050:	24 c0       	rjmp	.+72     	; 0x309a <protocol_main_loop+0x12a>
    3052:	dd 7f       	andi	r29, 0xFD	; 253
    3054:	22 c0       	rjmp	.+68     	; 0x309a <protocol_main_loop+0x12a>
          }
        } else {
          if (c <= ' ') {
    3056:	81 32       	cpi	r24, 0x21	; 33
    3058:	00 f1       	brcs	.+64     	; 0x309a <protocol_main_loop+0x12a>
            // Throw away whitepace and control characters
          } else if (c == '/') {
    305a:	8f 32       	cpi	r24, 0x2F	; 47
    305c:	f1 f0       	breq	.+60     	; 0x309a <protocol_main_loop+0x12a>
            // Block delete NOT SUPPORTED. Ignore character.
            // NOTE: If supported, would simply need to check the system if block delete is enabled.
          } else if (c == '(') {
    305e:	88 32       	cpi	r24, 0x28	; 40
    3060:	11 f4       	brne	.+4      	; 0x3066 <protocol_main_loop+0xf6>
            // Enable comments flag and ignore all characters until ')' or EOL.
            // NOTE: This doesn't follow the NIST definition exactly, but is good enough for now.
            // In the future, we could simply remove the items within the comments, but retain the
            // comment control characters, so that the g-code parser can error-check it.
            line_flags |= LINE_FLAG_COMMENT_PARENTHESES;
    3062:	d2 60       	ori	r29, 0x02	; 2
    3064:	1a c0       	rjmp	.+52     	; 0x309a <protocol_main_loop+0x12a>
          } else if (c == ';') {
    3066:	8b 33       	cpi	r24, 0x3B	; 59
    3068:	11 f4       	brne	.+4      	; 0x306e <protocol_main_loop+0xfe>
            // NOTE: ';' comment to EOL is a LinuxCNC definition. Not NIST.
            line_flags |= LINE_FLAG_COMMENT_SEMICOLON;
    306a:	d4 60       	ori	r29, 0x04	; 4
    306c:	16 c0       	rjmp	.+44     	; 0x309a <protocol_main_loop+0x12a>
            // Program start-end percent sign NOT SUPPORTED.
            // NOTE: This maybe installed to tell Grbl when a program is running vs manual input,
            // where, during a program, the system auto-cycle start will continue to execute
            // everything until the next '%' sign. This will help fix resuming issues with certain
            // functions that empty the planner buffer to execute its task on-time.
          } else if (char_counter >= (LINE_BUFFER_SIZE-1)) {
    306e:	cf 3f       	cpi	r28, 0xFF	; 255
    3070:	11 f4       	brne	.+4      	; 0x3076 <protocol_main_loop+0x106>
            // Detect line buffer overflow and set flag.
            line_flags |= LINE_FLAG_OVERFLOW;
    3072:	d1 60       	ori	r29, 0x01	; 1
    3074:	12 c0       	rjmp	.+36     	; 0x309a <protocol_main_loop+0x12a>
          } else if (c >= 'a' && c <= 'z') { // Upcase lowercase
    3076:	9f e9       	ldi	r25, 0x9F	; 159
    3078:	98 0f       	add	r25, r24
    307a:	9a 31       	cpi	r25, 0x1A	; 26
    307c:	40 f4       	brcc	.+16     	; 0x308e <protocol_main_loop+0x11e>
            line[char_counter++] = c-'a'+'A';
    307e:	ec 2f       	mov	r30, r28
    3080:	f0 e0       	ldi	r31, 0x00	; 0
    3082:	e8 5f       	subi	r30, 0xF8	; 248
    3084:	fd 4f       	sbci	r31, 0xFD	; 253
    3086:	80 52       	subi	r24, 0x20	; 32
    3088:	80 83       	st	Z, r24
    308a:	cf 5f       	subi	r28, 0xFF	; 255
    308c:	06 c0       	rjmp	.+12     	; 0x309a <protocol_main_loop+0x12a>
          } else {
            line[char_counter++] = c;
    308e:	ec 2f       	mov	r30, r28
    3090:	f0 e0       	ldi	r31, 0x00	; 0
    3092:	e8 5f       	subi	r30, 0xF8	; 248
    3094:	fd 4f       	sbci	r31, 0xFD	; 253
    3096:	80 83       	st	Z, r24
  uint8_t c;
  for (;;) {

    // Process one line of incoming serial data, as the data becomes available. Performs an
    // initial filtering by removing spaces and comments and capitalizing all letters.
    while((c = serial_read()) != SERIAL_NO_DATA) {
    3098:	cf 5f       	subi	r28, 0xFF	; 255
    309a:	e5 db       	rcall	.-2102   	; 0x2866 <serial_read>
    309c:	8f 3f       	cpi	r24, 0xFF	; 255
    }

    // If there are no more characters in the serial read buffer to be processed and executed,
    // this indicates that g-code streaming has either filled the planner buffer or has
    // completed. In either case, auto-cycle start, if enabled, any queued moves.
    protocol_auto_cycle_start();
    309e:	09 f0       	breq	.+2      	; 0x30a2 <protocol_main_loop+0x132>
    30a0:	95 cf       	rjmp	.-214    	; 0x2fcc <protocol_main_loop+0x5c>

    protocol_execute_realtime();  // Runtime command check point.
    30a2:	ae dc       	rcall	.-1700   	; 0x2a00 <protocol_auto_cycle_start>
    30a4:	5f df       	rcall	.-322    	; 0x2f64 <protocol_execute_realtime>
    if (sys.abort) { return; } // Bail to main() program loop to reset system.
    30a6:	80 91 12 0c 	lds	r24, 0x0C12	; 0x800c12 <sys+0x1>
    30aa:	88 23       	and	r24, r24
    30ac:	b1 f3       	breq	.-20     	; 0x309a <protocol_main_loop+0x12a>
      sleep_check();    
    #endif
  }

  return; /* Never reached */
}
    30ae:	df 91       	pop	r29
    30b0:	cf 91       	pop	r28
    30b2:	08 95       	ret

000030b4 <protocol_buffer_synchronize>:
// Block until all buffered steps are executed or in a cycle state. Works with feed hold
// during a synchronize call, if it should happen. Also, waits for clean cycle end.
void protocol_buffer_synchronize()
{
  // If system is queued, ensure cycle resumes if the auto start flag is present.
  protocol_auto_cycle_start();
    30b4:	a5 dc       	rcall	.-1718   	; 0x2a00 <protocol_auto_cycle_start>
  do {
    protocol_execute_realtime();   // Check and execute run-time commands
    30b6:	56 df       	rcall	.-340    	; 0x2f64 <protocol_execute_realtime>
    30b8:	80 91 12 0c 	lds	r24, 0x0C12	; 0x800c12 <sys+0x1>
    if (sys.abort) { return; } // Check for system abort
    30bc:	81 11       	cpse	r24, r1
    30be:	08 c0       	rjmp	.+16     	; 0x30d0 <protocol_buffer_synchronize+0x1c>
    30c0:	0e 94 c3 28 	call	0x5186	; 0x5186 <plan_get_current_block>
  } while (plan_get_current_block() || (sys.state == STATE_CYCLE));
    30c4:	89 2b       	or	r24, r25
    30c6:	b9 f7       	brne	.-18     	; 0x30b6 <protocol_buffer_synchronize+0x2>
    30c8:	80 91 11 0c 	lds	r24, 0x0C11	; 0x800c11 <sys>
    30cc:	88 30       	cpi	r24, 0x08	; 8
    30ce:	99 f3       	breq	.-26     	; 0x30b6 <protocol_buffer_synchronize+0x2>
    30d0:	08 95       	ret

000030d2 <st_next_block_index>:


// Increments the step segment buffer block data ring buffer.
static uint8_t st_next_block_index(uint8_t block_index)
{
  block_index++;
    30d2:	8f 5f       	subi	r24, 0xFF	; 255
  if ( block_index == (SEGMENT_BUFFER_SIZE-1) ) { return(0); }
    30d4:	89 30       	cpi	r24, 0x09	; 9
    30d6:	09 f4       	brne	.+2      	; 0x30da <st_next_block_index+0x8>
    30d8:	80 e0       	ldi	r24, 0x00	; 0
  return(block_index);
}
    30da:	08 95       	ret

000030dc <st_wake_up>:
    // Initialize stepper output bits to ensure first ISR call does not step.
    for (idx = 0; idx < N_AXIS; idx++) {
      st.step_outbits[idx] = step_port_invert_mask[idx];
    }
  #else
    if (bit_istrue(settings.flags,BITFLAG_INVERT_ST_ENABLE)) { STEPPERS_DISABLE_PORT |= (1<<STEPPERS_DISABLE_BIT); }
    30dc:	80 91 fe 0e 	lds	r24, 0x0EFE	; 0x800efe <settings+0x45>
    30e0:	82 ff       	sbrs	r24, 2
    30e2:	04 c0       	rjmp	.+8      	; 0x30ec <st_wake_up+0x10>
    30e4:	85 b1       	in	r24, 0x05	; 5
    30e6:	80 68       	ori	r24, 0x80	; 128
    30e8:	85 b9       	out	0x05, r24	; 5
    30ea:	03 c0       	rjmp	.+6      	; 0x30f2 <st_wake_up+0x16>
    else { STEPPERS_DISABLE_PORT &= ~(1<<STEPPERS_DISABLE_BIT); }
    30ec:	85 b1       	in	r24, 0x05	; 5
    30ee:	8f 77       	andi	r24, 0x7F	; 127
    30f0:	85 b9       	out	0x05, r24	; 5
    // Initialize stepper output bits to ensure first ISR call does not step.
    st.step_outbits = step_port_invert_mask;
    30f2:	e3 e4       	ldi	r30, 0x43	; 67
    30f4:	f3 e0       	ldi	r31, 0x03	; 3
    30f6:	80 91 3f 03 	lds	r24, 0x033F	; 0x80033f <step_port_invert_mask>
    30fa:	86 87       	std	Z+14, r24	; 0x0e
    st.step_pulse_time = -(((settings.pulse_microseconds+STEP_PULSE_DELAY-2)*TICKS_PER_MICROSECOND) >> 3);
    // Set delay between direction pin write and step command.
    OCR0A = -(((settings.pulse_microseconds)*TICKS_PER_MICROSECOND) >> 3);
  #else // Normal operation
    // Set step pulse time. Ad hoc computation from oscilloscope. Uses two's complement.
    st.step_pulse_time = -(((settings.pulse_microseconds-2)*TICKS_PER_MICROSECOND) >> 3);
    30fc:	80 91 e9 0e 	lds	r24, 0x0EE9	; 0x800ee9 <settings+0x30>
    3100:	90 e0       	ldi	r25, 0x00	; 0
    3102:	02 97       	sbiw	r24, 0x02	; 2
    3104:	09 2e       	mov	r0, r25
    3106:	00 0c       	add	r0, r0
    3108:	aa 0b       	sbc	r26, r26
    310a:	bb 0b       	sbc	r27, r27
    310c:	88 0f       	add	r24, r24
    310e:	99 1f       	adc	r25, r25
    3110:	aa 1f       	adc	r26, r26
    3112:	bb 1f       	adc	r27, r27
    3114:	81 95       	neg	r24
    3116:	85 87       	std	Z+13, r24	; 0x0d
  #endif

  // Enable Stepper Driver Interrupt
  TIMSK1 |= (1<<OCIE1A);
    3118:	ef e6       	ldi	r30, 0x6F	; 111
    311a:	f0 e0       	ldi	r31, 0x00	; 0
    311c:	80 81       	ld	r24, Z
    311e:	82 60       	ori	r24, 0x02	; 2
    3120:	80 83       	st	Z, r24
    3122:	08 95       	ret

00003124 <st_go_idle>:

// Stepper shutdown
void st_go_idle()
{
  // Disable Stepper Driver Interrupt. Allow Stepper Port Reset Interrupt to finish, if active.
  TIMSK1 &= ~(1<<OCIE1A); // Disable Timer1 interrupt
    3124:	ef e6       	ldi	r30, 0x6F	; 111
    3126:	f0 e0       	ldi	r31, 0x00	; 0
    3128:	80 81       	ld	r24, Z
    312a:	8d 7f       	andi	r24, 0xFD	; 253
    312c:	80 83       	st	Z, r24
  TCCR1B = (TCCR1B & ~((1<<CS12) | (1<<CS11))) | (1<<CS10); // Reset clock to no prescaling.
    312e:	e1 e8       	ldi	r30, 0x81	; 129
    3130:	f0 e0       	ldi	r31, 0x00	; 0
    3132:	80 81       	ld	r24, Z
    3134:	88 7f       	andi	r24, 0xF8	; 248
    3136:	81 60       	ori	r24, 0x01	; 1
    3138:	80 83       	st	Z, r24
  busy = false;
    313a:	10 92 3d 03 	sts	0x033D, r1	; 0x80033d <busy>

  // Set stepper driver idle state, disabled or enabled, depending on settings and circumstances.
  bool pin_state = false; // Keep enabled.
  if (((settings.stepper_idle_lock_time != 0xff) || sys_rt_exec_alarm || sys.state == STATE_SLEEP) && sys.state != STATE_HOMING) {
    313e:	80 91 ec 0e 	lds	r24, 0x0EEC	; 0x800eec <settings+0x33>
    3142:	8f 3f       	cpi	r24, 0xFF	; 255
    3144:	41 f4       	brne	.+16     	; 0x3156 <st_go_idle+0x32>
    3146:	90 91 3d 0c 	lds	r25, 0x0C3D	; 0x800c3d <sys_rt_exec_alarm>
    314a:	91 11       	cpse	r25, r1
    314c:	04 c0       	rjmp	.+8      	; 0x3156 <st_go_idle+0x32>
    314e:	90 91 11 0c 	lds	r25, 0x0C11	; 0x800c11 <sys>
    3152:	90 38       	cpi	r25, 0x80	; 128
    3154:	49 f4       	brne	.+18     	; 0x3168 <st_go_idle+0x44>
    3156:	90 91 11 0c 	lds	r25, 0x0C11	; 0x800c11 <sys>
    315a:	94 30       	cpi	r25, 0x04	; 4
    315c:	39 f0       	breq	.+14     	; 0x316c <st_go_idle+0x48>
    // Force stepper dwell to lock axes for a defined amount of time to ensure the axes come to a complete
    // stop and not drift from residual inertial forces at the end of the last movement.
    delay_ms(settings.stepper_idle_lock_time);
    315e:	90 e0       	ldi	r25, 0x00	; 0
    3160:	0e 94 94 2d 	call	0x5b28	; 0x5b28 <delay_ms>
    pin_state = true; // Override. Disable steppers.
    3164:	81 e0       	ldi	r24, 0x01	; 1
    3166:	03 c0       	rjmp	.+6      	; 0x316e <st_go_idle+0x4a>
  TIMSK1 &= ~(1<<OCIE1A); // Disable Timer1 interrupt
  TCCR1B = (TCCR1B & ~((1<<CS12) | (1<<CS11))) | (1<<CS10); // Reset clock to no prescaling.
  busy = false;

  // Set stepper driver idle state, disabled or enabled, depending on settings and circumstances.
  bool pin_state = false; // Keep enabled.
    3168:	80 e0       	ldi	r24, 0x00	; 0
    316a:	01 c0       	rjmp	.+2      	; 0x316e <st_go_idle+0x4a>
    316c:	80 e0       	ldi	r24, 0x00	; 0
    // Force stepper dwell to lock axes for a defined amount of time to ensure the axes come to a complete
    // stop and not drift from residual inertial forces at the end of the last movement.
    delay_ms(settings.stepper_idle_lock_time);
    pin_state = true; // Override. Disable steppers.
  }
  if (bit_istrue(settings.flags,BITFLAG_INVERT_ST_ENABLE)) { pin_state = !pin_state; } // Apply pin invert.
    316e:	90 91 fe 0e 	lds	r25, 0x0EFE	; 0x800efe <settings+0x45>
    3172:	92 ff       	sbrs	r25, 2
    3174:	02 c0       	rjmp	.+4      	; 0x317a <st_go_idle+0x56>
    3176:	91 e0       	ldi	r25, 0x01	; 1
    3178:	89 27       	eor	r24, r25
      STEPPER_DISABLE_PORT(0) &= ~(1 << STEPPER_DISABLE_BIT(0));
      STEPPER_DISABLE_PORT(1) &= ~(1 << STEPPER_DISABLE_BIT(1));
      STEPPER_DISABLE_PORT(2) &= ~(1 << STEPPER_DISABLE_BIT(2));
    }
  #else
    if (pin_state) { STEPPERS_DISABLE_PORT |= (1<<STEPPERS_DISABLE_BIT); }
    317a:	88 23       	and	r24, r24
    317c:	21 f0       	breq	.+8      	; 0x3186 <st_go_idle+0x62>
    317e:	85 b1       	in	r24, 0x05	; 5
    3180:	80 68       	ori	r24, 0x80	; 128
    3182:	85 b9       	out	0x05, r24	; 5
    3184:	08 95       	ret
    else { STEPPERS_DISABLE_PORT &= ~(1<<STEPPERS_DISABLE_BIT); }
    3186:	85 b1       	in	r24, 0x05	; 5
    3188:	8f 77       	andi	r24, 0x7F	; 127
    318a:	85 b9       	out	0x05, r24	; 5
    318c:	08 95       	ret

0000318e <__vector_17>:
*/
// TODO: Replace direct updating of the int32 position counters in the ISR somehow. Perhaps use smaller
// int8 variables and update position counters only when a segment completes. This can get complicated
// with probing and homing cycles that require true real-time positions.
ISR(TIMER1_COMPA_vect)
{
    318e:	1f 92       	push	r1
    3190:	0f 92       	push	r0
    3192:	0f b6       	in	r0, 0x3f	; 63
    3194:	0f 92       	push	r0
    3196:	11 24       	eor	r1, r1
    3198:	0b b6       	in	r0, 0x3b	; 59
    319a:	0f 92       	push	r0
    319c:	2f 93       	push	r18
    319e:	3f 93       	push	r19
    31a0:	4f 93       	push	r20
    31a2:	5f 93       	push	r21
    31a4:	6f 93       	push	r22
    31a6:	7f 93       	push	r23
    31a8:	8f 93       	push	r24
    31aa:	9f 93       	push	r25
    31ac:	af 93       	push	r26
    31ae:	bf 93       	push	r27
    31b0:	cf 93       	push	r28
    31b2:	df 93       	push	r29
    31b4:	ef 93       	push	r30
    31b6:	ff 93       	push	r31
  #ifdef DEFAULTS_RAMPS_BOARD
    int i;
  #endif // Ramps Board

  if (busy) { return; } // The busy-flag is used to avoid reentering this interrupt
    31b8:	80 91 3d 03 	lds	r24, 0x033D	; 0x80033d <busy>
    31bc:	81 11       	cpse	r24, r1
    31be:	d0 c1       	rjmp	.+928    	; 0x3560 <__vector_17+0x3d2>
  #ifdef DEFAULTS_RAMPS_BOARD
    DIRECTION_PORT(0) = (DIRECTION_PORT(0) & ~(1 << DIRECTION_BIT(0))) | st.dir_outbits[0];
    DIRECTION_PORT(1) = (DIRECTION_PORT(1) & ~(1 << DIRECTION_BIT(1))) | st.dir_outbits[1];
    DIRECTION_PORT(2) = (DIRECTION_PORT(2) & ~(1 << DIRECTION_BIT(2))) | st.dir_outbits[2];
  #else
    DIRECTION_PORT = (DIRECTION_PORT & ~DIRECTION_MASK) | (st.dir_outbits & DIRECTION_MASK);
    31c0:	98 b1       	in	r25, 0x08	; 8
    31c2:	e3 e4       	ldi	r30, 0x43	; 67
    31c4:	f3 e0       	ldi	r31, 0x03	; 3
    31c6:	87 85       	ldd	r24, Z+15	; 0x0f
    31c8:	9f 71       	andi	r25, 0x1F	; 31
    31ca:	80 7e       	andi	r24, 0xE0	; 224
    31cc:	89 2b       	or	r24, r25
    31ce:	88 b9       	out	0x08, r24	; 8
    #endif
  #else  
    #ifdef STEP_PULSE_DELAY
      st.step_bits = (STEP_PORT & ~STEP_MASK) | st.step_outbits; // Store out_bits to prevent overwriting.
    #else  // Normal operation
      STEP_PORT = (STEP_PORT & ~STEP_MASK) | st.step_outbits;
    31d0:	82 b1       	in	r24, 0x02	; 2
    31d2:	96 85       	ldd	r25, Z+14	; 0x0e
    31d4:	83 7e       	andi	r24, 0xE3	; 227
    31d6:	89 2b       	or	r24, r25
    31d8:	82 b9       	out	0x02, r24	; 2
    #endif
  #endif // Ramps Board

  // Enable step pulse reset timer so that The Stepper Port Reset Interrupt can reset the signal after
  // exactly settings.pulse_microseconds microseconds, independent of the main Timer1 prescaler.
  TCNT0 = st.step_pulse_time; // Reload Timer0 counter
    31da:	85 85       	ldd	r24, Z+13	; 0x0d
    31dc:	86 bd       	out	0x26, r24	; 38
  TCCR0B = (1<<CS01); // Begin Timer0. Full speed, 1/8 prescaler
    31de:	82 e0       	ldi	r24, 0x02	; 2
    31e0:	85 bd       	out	0x25, r24	; 37

  busy = true;
    31e2:	81 e0       	ldi	r24, 0x01	; 1
    31e4:	80 93 3d 03 	sts	0x033D, r24	; 0x80033d <busy>
  sei(); // Re-enable interrupts to allow Stepper Port Reset Interrupt to fire on-time.
    31e8:	78 94       	sei
         // NOTE: The remaining code in this ISR will finish before returning to main program.

  // If there is no step segment, attempt to pop one from the stepper buffer
  if (st.exec_segment == NULL) {
    31ea:	81 a1       	ldd	r24, Z+33	; 0x21
    31ec:	92 a1       	ldd	r25, Z+34	; 0x22
    31ee:	89 2b       	or	r24, r25
    31f0:	09 f0       	breq	.+2      	; 0x31f4 <__vector_17+0x66>
    31f2:	a9 c0       	rjmp	.+338    	; 0x3346 <__vector_17+0x1b8>
    // Anything in the buffer? If so, load and initialize next step segment.
    if (segment_buffer_head != segment_buffer_tail) {
    31f4:	90 91 41 03 	lds	r25, 0x0341	; 0x800341 <segment_buffer_head>
    31f8:	80 91 42 03 	lds	r24, 0x0342	; 0x800342 <segment_buffer_tail>
    31fc:	98 17       	cp	r25, r24
    31fe:	09 f4       	brne	.+2      	; 0x3202 <__vector_17+0x74>
    3200:	93 c0       	rjmp	.+294    	; 0x3328 <__vector_17+0x19a>
      // Initialize new step segment and load number of steps to execute
      st.exec_segment = &segment_buffer[segment_buffer_tail];
    3202:	e0 91 42 03 	lds	r30, 0x0342	; 0x800342 <segment_buffer_tail>
    3206:	f0 e0       	ldi	r31, 0x00	; 0
    3208:	ee 0f       	add	r30, r30
    320a:	ff 1f       	adc	r31, r31
    320c:	ee 0f       	add	r30, r30
    320e:	ff 1f       	adc	r31, r31
    3210:	ee 0f       	add	r30, r30
    3212:	ff 1f       	adc	r31, r31
    3214:	ea 59       	subi	r30, 0x9A	; 154
    3216:	fc 4f       	sbci	r31, 0xFC	; 252
    3218:	a3 e4       	ldi	r26, 0x43	; 67
    321a:	b3 e0       	ldi	r27, 0x03	; 3
    321c:	92 96       	adiw	r26, 0x22	; 34
    321e:	fc 93       	st	X, r31
    3220:	ee 93       	st	-X, r30
    3222:	91 97       	sbiw	r26, 0x21	; 33
        // With AMASS is disabled, set timer prescaler for segments with slow step frequencies (< 250Hz).
        TCCR1B = (TCCR1B & ~(0x07<<CS10)) | (st.exec_segment->prescaler<<CS10);
      #endif

      // Initialize step segment timing per step and load number of steps to execute.
      OCR1A = st.exec_segment->cycles_per_tick;
    3224:	82 81       	ldd	r24, Z+2	; 0x02
    3226:	93 81       	ldd	r25, Z+3	; 0x03
    3228:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x7c0089>
    322c:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7c0088>
      st.step_count = st.exec_segment->n_step; // NOTE: Can sometimes be zero when moving slow.
    3230:	80 81       	ld	r24, Z
    3232:	91 81       	ldd	r25, Z+1	; 0x01
    3234:	5d 96       	adiw	r26, 0x1d	; 29
    3236:	9c 93       	st	X, r25
    3238:	8e 93       	st	-X, r24
    323a:	5c 97       	sbiw	r26, 0x1c	; 28
      // If the new segment starts a new planner block, initialize stepper variables and counters.
      // NOTE: When the segment data index changes, this indicates a new planner block.
      if ( st.exec_block_index != st.exec_segment->st_block_index ) {
    323c:	5e 96       	adiw	r26, 0x1e	; 30
    323e:	9c 91       	ld	r25, X
    3240:	5e 97       	sbiw	r26, 0x1e	; 30
    3242:	84 81       	ldd	r24, Z+4	; 0x04
    3244:	98 17       	cp	r25, r24
    3246:	49 f1       	breq	.+82     	; 0x329a <__vector_17+0x10c>
        st.exec_block_index = st.exec_segment->st_block_index;
    3248:	ed 01       	movw	r28, r26
    324a:	8e 8f       	std	Y+30, r24	; 0x1e
        st.exec_block = &st_block_buffer[st.exec_block_index];
    324c:	90 e0       	ldi	r25, 0x00	; 0
    324e:	88 0f       	add	r24, r24
    3250:	99 1f       	adc	r25, r25
    3252:	dc 01       	movw	r26, r24
    3254:	aa 0f       	add	r26, r26
    3256:	bb 1f       	adc	r27, r27
    3258:	aa 0f       	add	r26, r26
    325a:	bb 1f       	adc	r27, r27
    325c:	aa 0f       	add	r26, r26
    325e:	bb 1f       	adc	r27, r27
    3260:	8a 0f       	add	r24, r26
    3262:	9b 1f       	adc	r25, r27
    3264:	dc 01       	movw	r26, r24
    3266:	aa 54       	subi	r26, 0x4A	; 74
    3268:	bc 4f       	sbci	r27, 0xFC	; 252
    326a:	b8 a3       	std	Y+32, r27	; 0x20
    326c:	af 8f       	std	Y+31, r26	; 0x1f

        // Initialize Bresenham line and distance counters
        st.counter_x = st.counter_y = st.counter_z = (st.exec_block->step_event_count >> 1);
    326e:	1c 96       	adiw	r26, 0x0c	; 12
    3270:	8d 91       	ld	r24, X+
    3272:	9d 91       	ld	r25, X+
    3274:	0d 90       	ld	r0, X+
    3276:	bc 91       	ld	r27, X
    3278:	a0 2d       	mov	r26, r0
    327a:	b6 95       	lsr	r27
    327c:	a7 95       	ror	r26
    327e:	97 95       	ror	r25
    3280:	87 95       	ror	r24
    3282:	88 87       	std	Y+8, r24	; 0x08
    3284:	99 87       	std	Y+9, r25	; 0x09
    3286:	aa 87       	std	Y+10, r26	; 0x0a
    3288:	bb 87       	std	Y+11, r27	; 0x0b
    328a:	8c 83       	std	Y+4, r24	; 0x04
    328c:	9d 83       	std	Y+5, r25	; 0x05
    328e:	ae 83       	std	Y+6, r26	; 0x06
    3290:	bf 83       	std	Y+7, r27	; 0x07
    3292:	88 83       	st	Y, r24
    3294:	99 83       	std	Y+1, r25	; 0x01
    3296:	aa 83       	std	Y+2, r26	; 0x02
    3298:	bb 83       	std	Y+3, r27	; 0x03
      }
      #ifdef DEFAULTS_RAMPS_BOARD
        for (i = 0; i < N_AXIS; i++)
          st.dir_outbits[i] = st.exec_block->direction_bits[i] ^ dir_port_invert_mask[i];
      #else
        st.dir_outbits = st.exec_block->direction_bits ^ dir_port_invert_mask;
    329a:	a3 e4       	ldi	r26, 0x43	; 67
    329c:	b3 e0       	ldi	r27, 0x03	; 3
    329e:	5f 96       	adiw	r26, 0x1f	; 31
    32a0:	cd 91       	ld	r28, X+
    32a2:	dc 91       	ld	r29, X
    32a4:	90 97       	sbiw	r26, 0x20	; 32
    32a6:	88 89       	ldd	r24, Y+16	; 0x10
    32a8:	90 91 3e 03 	lds	r25, 0x033E	; 0x80033e <dir_port_invert_mask>
    32ac:	89 27       	eor	r24, r25
    32ae:	1f 96       	adiw	r26, 0x0f	; 15
    32b0:	8c 93       	st	X, r24
    32b2:	1f 97       	sbiw	r26, 0x0f	; 15
      #endif // Ramps Board

      #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
        // With AMASS enabled, adjust Bresenham axis increment counters according to AMASS level.
        st.steps[X_AXIS] = st.exec_block->steps[X_AXIS] >> st.exec_segment->amass_level;
    32b4:	48 81       	ld	r20, Y
    32b6:	59 81       	ldd	r21, Y+1	; 0x01
    32b8:	6a 81       	ldd	r22, Y+2	; 0x02
    32ba:	7b 81       	ldd	r23, Y+3	; 0x03
    32bc:	05 80       	ldd	r0, Z+5	; 0x05
    32be:	04 c0       	rjmp	.+8      	; 0x32c8 <__vector_17+0x13a>
    32c0:	76 95       	lsr	r23
    32c2:	67 95       	ror	r22
    32c4:	57 95       	ror	r21
    32c6:	47 95       	ror	r20
    32c8:	0a 94       	dec	r0
    32ca:	d2 f7       	brpl	.-12     	; 0x32c0 <__vector_17+0x132>
    32cc:	50 96       	adiw	r26, 0x10	; 16
    32ce:	4d 93       	st	X+, r20
    32d0:	5d 93       	st	X+, r21
    32d2:	6d 93       	st	X+, r22
    32d4:	7c 93       	st	X, r23
    32d6:	53 97       	sbiw	r26, 0x13	; 19
        st.steps[Y_AXIS] = st.exec_block->steps[Y_AXIS] >> st.exec_segment->amass_level;
    32d8:	4c 81       	ldd	r20, Y+4	; 0x04
    32da:	5d 81       	ldd	r21, Y+5	; 0x05
    32dc:	6e 81       	ldd	r22, Y+6	; 0x06
    32de:	7f 81       	ldd	r23, Y+7	; 0x07
    32e0:	05 80       	ldd	r0, Z+5	; 0x05
    32e2:	04 c0       	rjmp	.+8      	; 0x32ec <__vector_17+0x15e>
    32e4:	76 95       	lsr	r23
    32e6:	67 95       	ror	r22
    32e8:	57 95       	ror	r21
    32ea:	47 95       	ror	r20
    32ec:	0a 94       	dec	r0
    32ee:	d2 f7       	brpl	.-12     	; 0x32e4 <__vector_17+0x156>
    32f0:	54 96       	adiw	r26, 0x14	; 20
    32f2:	4d 93       	st	X+, r20
    32f4:	5d 93       	st	X+, r21
    32f6:	6d 93       	st	X+, r22
    32f8:	7c 93       	st	X, r23
    32fa:	57 97       	sbiw	r26, 0x17	; 23
        st.steps[Z_AXIS] = st.exec_block->steps[Z_AXIS] >> st.exec_segment->amass_level;
    32fc:	48 85       	ldd	r20, Y+8	; 0x08
    32fe:	59 85       	ldd	r21, Y+9	; 0x09
    3300:	6a 85       	ldd	r22, Y+10	; 0x0a
    3302:	7b 85       	ldd	r23, Y+11	; 0x0b
    3304:	05 80       	ldd	r0, Z+5	; 0x05
    3306:	04 c0       	rjmp	.+8      	; 0x3310 <__vector_17+0x182>
    3308:	76 95       	lsr	r23
    330a:	67 95       	ror	r22
    330c:	57 95       	ror	r21
    330e:	47 95       	ror	r20
    3310:	0a 94       	dec	r0
    3312:	d2 f7       	brpl	.-12     	; 0x3308 <__vector_17+0x17a>
    3314:	58 96       	adiw	r26, 0x18	; 24
    3316:	4d 93       	st	X+, r20
    3318:	5d 93       	st	X+, r21
    331a:	6d 93       	st	X+, r22
    331c:	7c 93       	st	X, r23
    331e:	5b 97       	sbiw	r26, 0x1b	; 27
      #endif

      // Set real-time spindle output as segment is loaded, just prior to the first step.
      spindle_set_speed(st.exec_segment->spindle_pwm);
    3320:	86 81       	ldd	r24, Z+6	; 0x06
    3322:	97 81       	ldd	r25, Z+7	; 0x07
    3324:	fa d8       	rcall	.-3596   	; 0x251a <spindle_set_speed>
    3326:	0f c0       	rjmp	.+30     	; 0x3346 <__vector_17+0x1b8>

    } else {
      // Segment buffer empty. Shutdown.
      st_go_idle();
    3328:	fd de       	rcall	.-518    	; 0x3124 <st_go_idle>
    332a:	e0 91 62 03 	lds	r30, 0x0362	; 0x800362 <st+0x1f>
      // Ensure pwm is set properly upon completion of rate-controlled motion.
      if (st.exec_block->is_pwm_rate_adjusted) { spindle_set_speed(SPINDLE_PWM_OFF_VALUE); }
    332e:	f0 91 63 03 	lds	r31, 0x0363	; 0x800363 <st+0x20>
    3332:	81 89       	ldd	r24, Z+17	; 0x11
    3334:	88 23       	and	r24, r24
    3336:	19 f0       	breq	.+6      	; 0x333e <__vector_17+0x1b0>
    3338:	80 e0       	ldi	r24, 0x00	; 0
    333a:	90 e0       	ldi	r25, 0x00	; 0
    333c:	ee d8       	rcall	.-3620   	; 0x251a <spindle_set_speed>
    333e:	84 e0       	ldi	r24, 0x04	; 4
      system_set_exec_state_flag(EXEC_CYCLE_STOP); // Flag main program for cycle end
    3340:	0e 94 4b 39 	call	0x7296	; 0x7296 <system_set_exec_state_flag>
    3344:	0d c1       	rjmp	.+538    	; 0x3560 <__vector_17+0x3d2>
      return; // Nothing to do but exit.
    3346:	80 91 24 0c 	lds	r24, 0x0C24	; 0x800c24 <sys_probe_state>
    }
  }


  // Check probing state.
  if (sys_probe_state == PROBE_ACTIVE) { probe_state_monitor(); }
    334a:	81 30       	cpi	r24, 0x01	; 1
    334c:	11 f4       	brne	.+4      	; 0x3352 <__vector_17+0x1c4>
    334e:	0e 94 0c 33 	call	0x6618	; 0x6618 <probe_state_monitor>
    3352:	e3 e4       	ldi	r30, 0x43	; 67
  // Reset step out bits.
  #ifdef DEFAULTS_RAMPS_BOARD
    for (i = 0; i < N_AXIS; i++)
      st.step_outbits[i] = 0;
  #else
    st.step_outbits = 0;
    3354:	f3 e0       	ldi	r31, 0x03	; 3
    3356:	16 86       	std	Z+14, r1	; 0x0e
    3358:	40 89       	ldd	r20, Z+16	; 0x10
  #endif // Ramps Board

  // Execute step displacement profile by Bresenham line algorithm
  #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    st.counter_x += st.steps[X_AXIS];
    335a:	51 89       	ldd	r21, Z+17	; 0x11
    335c:	62 89       	ldd	r22, Z+18	; 0x12
    335e:	73 89       	ldd	r23, Z+19	; 0x13
    3360:	80 81       	ld	r24, Z
    3362:	91 81       	ldd	r25, Z+1	; 0x01
    3364:	a2 81       	ldd	r26, Z+2	; 0x02
    3366:	b3 81       	ldd	r27, Z+3	; 0x03
    3368:	84 0f       	add	r24, r20
    336a:	95 1f       	adc	r25, r21
    336c:	a6 1f       	adc	r26, r22
    336e:	b7 1f       	adc	r27, r23
    3370:	80 83       	st	Z, r24
    3372:	91 83       	std	Z+1, r25	; 0x01
    3374:	a2 83       	std	Z+2, r26	; 0x02
    3376:	b3 83       	std	Z+3, r27	; 0x03
    3378:	07 8c       	ldd	r0, Z+31	; 0x1f
      st.counter_x -= st.exec_block->step_event_count;
      if (st.exec_block->direction_bits[X_AXIS] & (1<<DIRECTION_BIT(X_AXIS))) { sys_position[X_AXIS]--; }
      else { sys_position[X_AXIS]++; }
    }
  #else
    if (st.counter_x > st.exec_block->step_event_count) {
    337a:	f0 a1       	ldd	r31, Z+32	; 0x20
    337c:	e0 2d       	mov	r30, r0
    337e:	44 85       	ldd	r20, Z+12	; 0x0c
    3380:	55 85       	ldd	r21, Z+13	; 0x0d
    3382:	66 85       	ldd	r22, Z+14	; 0x0e
    3384:	77 85       	ldd	r23, Z+15	; 0x0f
    3386:	48 17       	cp	r20, r24
    3388:	59 07       	cpc	r21, r25
    338a:	6a 07       	cpc	r22, r26
    338c:	7b 07       	cpc	r23, r27
    338e:	70 f5       	brcc	.+92     	; 0x33ec <__vector_17+0x25e>
    3390:	c3 e4       	ldi	r28, 0x43	; 67
      st.step_outbits |= (1<<X_STEP_BIT);
    3392:	d3 e0       	ldi	r29, 0x03	; 3
    3394:	24 e0       	ldi	r18, 0x04	; 4
    3396:	2e 87       	std	Y+14, r18	; 0x0e
    3398:	44 85       	ldd	r20, Z+12	; 0x0c
      st.counter_x -= st.exec_block->step_event_count;
    339a:	55 85       	ldd	r21, Z+13	; 0x0d
    339c:	66 85       	ldd	r22, Z+14	; 0x0e
    339e:	77 85       	ldd	r23, Z+15	; 0x0f
    33a0:	84 1b       	sub	r24, r20
    33a2:	95 0b       	sbc	r25, r21
    33a4:	a6 0b       	sbc	r26, r22
    33a6:	b7 0b       	sbc	r27, r23
    33a8:	88 83       	st	Y, r24
    33aa:	99 83       	std	Y+1, r25	; 0x01
    33ac:	aa 83       	std	Y+2, r26	; 0x02
    33ae:	bb 83       	std	Y+3, r27	; 0x03
    33b0:	80 89       	ldd	r24, Z+16	; 0x10
      if (st.exec_block->direction_bits & (1<<X_DIRECTION_BIT)) { sys_position[X_AXIS]--; }
    33b2:	88 23       	and	r24, r24
    33b4:	74 f4       	brge	.+28     	; 0x33d2 <__vector_17+0x244>
    33b6:	c1 e3       	ldi	r28, 0x31	; 49
    33b8:	dc e0       	ldi	r29, 0x0C	; 12
    33ba:	88 81       	ld	r24, Y
    33bc:	99 81       	ldd	r25, Y+1	; 0x01
    33be:	aa 81       	ldd	r26, Y+2	; 0x02
    33c0:	bb 81       	ldd	r27, Y+3	; 0x03
    33c2:	01 97       	sbiw	r24, 0x01	; 1
    33c4:	a1 09       	sbc	r26, r1
    33c6:	b1 09       	sbc	r27, r1
    33c8:	88 83       	st	Y, r24
    33ca:	99 83       	std	Y+1, r25	; 0x01
    33cc:	aa 83       	std	Y+2, r26	; 0x02
    33ce:	bb 83       	std	Y+3, r27	; 0x03
    33d0:	0d c0       	rjmp	.+26     	; 0x33ec <__vector_17+0x25e>
    33d2:	c1 e3       	ldi	r28, 0x31	; 49
      else { sys_position[X_AXIS]++; }
    33d4:	dc e0       	ldi	r29, 0x0C	; 12
    33d6:	88 81       	ld	r24, Y
    33d8:	99 81       	ldd	r25, Y+1	; 0x01
    33da:	aa 81       	ldd	r26, Y+2	; 0x02
    33dc:	bb 81       	ldd	r27, Y+3	; 0x03
    33de:	01 96       	adiw	r24, 0x01	; 1
    33e0:	a1 1d       	adc	r26, r1
    33e2:	b1 1d       	adc	r27, r1
    33e4:	88 83       	st	Y, r24
    33e6:	99 83       	std	Y+1, r25	; 0x01
    33e8:	aa 83       	std	Y+2, r26	; 0x02
    33ea:	bb 83       	std	Y+3, r27	; 0x03
    33ec:	c3 e4       	ldi	r28, 0x43	; 67
    }
  #endif // Ramps Board

  #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    st.counter_y += st.steps[Y_AXIS];
    33ee:	d3 e0       	ldi	r29, 0x03	; 3
    33f0:	4c 89       	ldd	r20, Y+20	; 0x14
    33f2:	5d 89       	ldd	r21, Y+21	; 0x15
    33f4:	6e 89       	ldd	r22, Y+22	; 0x16
    33f6:	7f 89       	ldd	r23, Y+23	; 0x17
    33f8:	8c 81       	ldd	r24, Y+4	; 0x04
    33fa:	9d 81       	ldd	r25, Y+5	; 0x05
    33fc:	ae 81       	ldd	r26, Y+6	; 0x06
    33fe:	bf 81       	ldd	r27, Y+7	; 0x07
    3400:	84 0f       	add	r24, r20
    3402:	95 1f       	adc	r25, r21
    3404:	a6 1f       	adc	r26, r22
    3406:	b7 1f       	adc	r27, r23
    3408:	8c 83       	std	Y+4, r24	; 0x04
    340a:	9d 83       	std	Y+5, r25	; 0x05
    340c:	ae 83       	std	Y+6, r26	; 0x06
    340e:	bf 83       	std	Y+7, r27	; 0x07
    3410:	44 85       	ldd	r20, Z+12	; 0x0c
      st.counter_y -= st.exec_block->step_event_count;
      if (st.exec_block->direction_bits[Y_AXIS] & (1<<DIRECTION_BIT(Y_AXIS))) { sys_position[Y_AXIS]--; }
      else { sys_position[Y_AXIS]++; }
    }
  #else
    if (st.counter_y > st.exec_block->step_event_count) {
    3412:	55 85       	ldd	r21, Z+13	; 0x0d
    3414:	66 85       	ldd	r22, Z+14	; 0x0e
    3416:	77 85       	ldd	r23, Z+15	; 0x0f
    3418:	48 17       	cp	r20, r24
    341a:	59 07       	cpc	r21, r25
    341c:	6a 07       	cpc	r22, r26
    341e:	7b 07       	cpc	r23, r27
    3420:	68 f5       	brcc	.+90     	; 0x347c <__vector_17+0x2ee>
    3422:	2e 85       	ldd	r18, Y+14	; 0x0e
      st.step_outbits |= (1<<Y_STEP_BIT);
    3424:	28 60       	ori	r18, 0x08	; 8
    3426:	2e 87       	std	Y+14, r18	; 0x0e
    3428:	44 85       	ldd	r20, Z+12	; 0x0c
      st.counter_y -= st.exec_block->step_event_count;
    342a:	55 85       	ldd	r21, Z+13	; 0x0d
    342c:	66 85       	ldd	r22, Z+14	; 0x0e
    342e:	77 85       	ldd	r23, Z+15	; 0x0f
    3430:	84 1b       	sub	r24, r20
    3432:	95 0b       	sbc	r25, r21
    3434:	a6 0b       	sbc	r26, r22
    3436:	b7 0b       	sbc	r27, r23
    3438:	8c 83       	std	Y+4, r24	; 0x04
    343a:	9d 83       	std	Y+5, r25	; 0x05
    343c:	ae 83       	std	Y+6, r26	; 0x06
    343e:	bf 83       	std	Y+7, r27	; 0x07
    3440:	80 89       	ldd	r24, Z+16	; 0x10
      if (st.exec_block->direction_bits & (1<<Y_DIRECTION_BIT)) { sys_position[Y_AXIS]--; }
    3442:	86 ff       	sbrs	r24, 6
    3444:	0e c0       	rjmp	.+28     	; 0x3462 <__vector_17+0x2d4>
    3446:	c1 e3       	ldi	r28, 0x31	; 49
    3448:	dc e0       	ldi	r29, 0x0C	; 12
    344a:	8c 81       	ldd	r24, Y+4	; 0x04
    344c:	9d 81       	ldd	r25, Y+5	; 0x05
    344e:	ae 81       	ldd	r26, Y+6	; 0x06
    3450:	bf 81       	ldd	r27, Y+7	; 0x07
    3452:	01 97       	sbiw	r24, 0x01	; 1
    3454:	a1 09       	sbc	r26, r1
    3456:	b1 09       	sbc	r27, r1
    3458:	8c 83       	std	Y+4, r24	; 0x04
    345a:	9d 83       	std	Y+5, r25	; 0x05
    345c:	ae 83       	std	Y+6, r26	; 0x06
    345e:	bf 83       	std	Y+7, r27	; 0x07
    3460:	0d c0       	rjmp	.+26     	; 0x347c <__vector_17+0x2ee>
    3462:	c1 e3       	ldi	r28, 0x31	; 49
      else { sys_position[Y_AXIS]++; }
    3464:	dc e0       	ldi	r29, 0x0C	; 12
    3466:	8c 81       	ldd	r24, Y+4	; 0x04
    3468:	9d 81       	ldd	r25, Y+5	; 0x05
    346a:	ae 81       	ldd	r26, Y+6	; 0x06
    346c:	bf 81       	ldd	r27, Y+7	; 0x07
    346e:	01 96       	adiw	r24, 0x01	; 1
    3470:	a1 1d       	adc	r26, r1
    3472:	b1 1d       	adc	r27, r1
    3474:	8c 83       	std	Y+4, r24	; 0x04
    3476:	9d 83       	std	Y+5, r25	; 0x05
    3478:	ae 83       	std	Y+6, r26	; 0x06
    347a:	bf 83       	std	Y+7, r27	; 0x07
    347c:	c3 e4       	ldi	r28, 0x43	; 67
    }
  #endif // Ramps Board
  #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    st.counter_z += st.steps[Z_AXIS];
    347e:	d3 e0       	ldi	r29, 0x03	; 3
    3480:	48 8d       	ldd	r20, Y+24	; 0x18
    3482:	59 8d       	ldd	r21, Y+25	; 0x19
    3484:	6a 8d       	ldd	r22, Y+26	; 0x1a
    3486:	7b 8d       	ldd	r23, Y+27	; 0x1b
    3488:	88 85       	ldd	r24, Y+8	; 0x08
    348a:	99 85       	ldd	r25, Y+9	; 0x09
    348c:	aa 85       	ldd	r26, Y+10	; 0x0a
    348e:	bb 85       	ldd	r27, Y+11	; 0x0b
    3490:	84 0f       	add	r24, r20
    3492:	95 1f       	adc	r25, r21
    3494:	a6 1f       	adc	r26, r22
    3496:	b7 1f       	adc	r27, r23
    3498:	88 87       	std	Y+8, r24	; 0x08
    349a:	99 87       	std	Y+9, r25	; 0x09
    349c:	aa 87       	std	Y+10, r26	; 0x0a
    349e:	bb 87       	std	Y+11, r27	; 0x0b
    34a0:	44 85       	ldd	r20, Z+12	; 0x0c
      st.counter_z -= st.exec_block->step_event_count;
      if (st.exec_block->direction_bits[Z_AXIS] & (1<<DIRECTION_BIT(Z_AXIS))) { sys_position[Z_AXIS]--; }
      else { sys_position[Z_AXIS]++; }
    }
  #else
    if (st.counter_z > st.exec_block->step_event_count) {
    34a2:	55 85       	ldd	r21, Z+13	; 0x0d
    34a4:	66 85       	ldd	r22, Z+14	; 0x0e
    34a6:	77 85       	ldd	r23, Z+15	; 0x0f
    34a8:	48 17       	cp	r20, r24
    34aa:	59 07       	cpc	r21, r25
    34ac:	6a 07       	cpc	r22, r26
    34ae:	7b 07       	cpc	r23, r27
    34b0:	68 f5       	brcc	.+90     	; 0x350c <__vector_17+0x37e>
    34b2:	2e 85       	ldd	r18, Y+14	; 0x0e
      st.step_outbits |= (1<<Z_STEP_BIT);
    34b4:	20 61       	ori	r18, 0x10	; 16
    34b6:	2e 87       	std	Y+14, r18	; 0x0e
    34b8:	44 85       	ldd	r20, Z+12	; 0x0c
      st.counter_z -= st.exec_block->step_event_count;
    34ba:	55 85       	ldd	r21, Z+13	; 0x0d
    34bc:	66 85       	ldd	r22, Z+14	; 0x0e
    34be:	77 85       	ldd	r23, Z+15	; 0x0f
    34c0:	84 1b       	sub	r24, r20
    34c2:	95 0b       	sbc	r25, r21
    34c4:	a6 0b       	sbc	r26, r22
    34c6:	b7 0b       	sbc	r27, r23
    34c8:	88 87       	std	Y+8, r24	; 0x08
    34ca:	99 87       	std	Y+9, r25	; 0x09
    34cc:	aa 87       	std	Y+10, r26	; 0x0a
    34ce:	bb 87       	std	Y+11, r27	; 0x0b
    34d0:	80 89       	ldd	r24, Z+16	; 0x10
      if (st.exec_block->direction_bits & (1<<Z_DIRECTION_BIT)) { sys_position[Z_AXIS]--; }
    34d2:	85 ff       	sbrs	r24, 5
    34d4:	0e c0       	rjmp	.+28     	; 0x34f2 <__vector_17+0x364>
    34d6:	e1 e3       	ldi	r30, 0x31	; 49
    34d8:	fc e0       	ldi	r31, 0x0C	; 12
    34da:	80 85       	ldd	r24, Z+8	; 0x08
    34dc:	91 85       	ldd	r25, Z+9	; 0x09
    34de:	a2 85       	ldd	r26, Z+10	; 0x0a
    34e0:	b3 85       	ldd	r27, Z+11	; 0x0b
    34e2:	01 97       	sbiw	r24, 0x01	; 1
    34e4:	a1 09       	sbc	r26, r1
    34e6:	b1 09       	sbc	r27, r1
    34e8:	80 87       	std	Z+8, r24	; 0x08
    34ea:	91 87       	std	Z+9, r25	; 0x09
    34ec:	a2 87       	std	Z+10, r26	; 0x0a
    34ee:	b3 87       	std	Z+11, r27	; 0x0b
    34f0:	0d c0       	rjmp	.+26     	; 0x350c <__vector_17+0x37e>
    34f2:	e1 e3       	ldi	r30, 0x31	; 49
      else { sys_position[Z_AXIS]++; }
    34f4:	fc e0       	ldi	r31, 0x0C	; 12
    34f6:	80 85       	ldd	r24, Z+8	; 0x08
    34f8:	91 85       	ldd	r25, Z+9	; 0x09
    34fa:	a2 85       	ldd	r26, Z+10	; 0x0a
    34fc:	b3 85       	ldd	r27, Z+11	; 0x0b
    34fe:	01 96       	adiw	r24, 0x01	; 1
    3500:	a1 1d       	adc	r26, r1
    3502:	b1 1d       	adc	r27, r1
    3504:	80 87       	std	Z+8, r24	; 0x08
    3506:	91 87       	std	Z+9, r25	; 0x09
    3508:	a2 87       	std	Z+10, r26	; 0x0a
    350a:	b3 87       	std	Z+11, r27	; 0x0b
    350c:	80 91 11 0c 	lds	r24, 0x0C11	; 0x800c11 <sys>
  // During a homing cycle, lock out and prevent desired axes from moving.
  #ifdef DEFAULTS_RAMPS_BOARD
    for (i = 0; i < N_AXIS; i++)
    if (sys.state == STATE_HOMING) { st.step_outbits[i] &= sys.homing_axis_lock[i]; }
  #else
    if (sys.state == STATE_HOMING) { st.step_outbits &= sys.homing_axis_lock; }
    3510:	84 30       	cpi	r24, 0x04	; 4
    3512:	39 f4       	brne	.+14     	; 0x3522 <__vector_17+0x394>
    3514:	80 91 17 0c 	lds	r24, 0x0C17	; 0x800c17 <sys+0x6>
    3518:	e3 e4       	ldi	r30, 0x43	; 67
    351a:	f3 e0       	ldi	r31, 0x03	; 3
    351c:	96 85       	ldd	r25, Z+14	; 0x0e
    351e:	89 23       	and	r24, r25
    3520:	86 87       	std	Z+14, r24	; 0x0e
    3522:	e3 e4       	ldi	r30, 0x43	; 67
  #endif // Ramps Board
  st.step_count--; // Decrement step events count
    3524:	f3 e0       	ldi	r31, 0x03	; 3
    3526:	84 8d       	ldd	r24, Z+28	; 0x1c
    3528:	95 8d       	ldd	r25, Z+29	; 0x1d
    352a:	01 97       	sbiw	r24, 0x01	; 1
    352c:	95 8f       	std	Z+29, r25	; 0x1d
    352e:	84 8f       	std	Z+28, r24	; 0x1c
    3530:	89 2b       	or	r24, r25
  if (st.step_count == 0) {
    3532:	69 f4       	brne	.+26     	; 0x354e <__vector_17+0x3c0>
    3534:	10 92 65 03 	sts	0x0365, r1	; 0x800365 <st+0x22>
    // Segment is complete. Discard current segment and advance segment indexing.
    st.exec_segment = NULL;
    3538:	10 92 64 03 	sts	0x0364, r1	; 0x800364 <st+0x21>
    353c:	80 91 42 03 	lds	r24, 0x0342	; 0x800342 <segment_buffer_tail>
    if ( ++segment_buffer_tail == SEGMENT_BUFFER_SIZE) { segment_buffer_tail = 0; }
    3540:	8f 5f       	subi	r24, 0xFF	; 255
    3542:	80 93 42 03 	sts	0x0342, r24	; 0x800342 <segment_buffer_tail>
    3546:	8a 30       	cpi	r24, 0x0A	; 10
    3548:	11 f4       	brne	.+4      	; 0x354e <__vector_17+0x3c0>
    354a:	10 92 42 03 	sts	0x0342, r1	; 0x800342 <segment_buffer_tail>
    354e:	e3 e4       	ldi	r30, 0x43	; 67
  }
  #ifdef DEFAULTS_RAMPS_BOARD
    for (i = 0; i < N_AXIS; i++)
      st.step_outbits[i] ^= step_port_invert_mask[i];  // Apply step port invert mask
  #else
    st.step_outbits ^= step_port_invert_mask;  // Apply step port invert mask
    3550:	f3 e0       	ldi	r31, 0x03	; 3
    3552:	96 85       	ldd	r25, Z+14	; 0x0e
    3554:	80 91 3f 03 	lds	r24, 0x033F	; 0x80033f <step_port_invert_mask>
    3558:	89 27       	eor	r24, r25
    355a:	86 87       	std	Z+14, r24	; 0x0e
    355c:	10 92 3d 03 	sts	0x033D, r1	; 0x80033d <busy>
  #endif // Ramps Board
  busy = false;
    3560:	ff 91       	pop	r31
}
    3562:	ef 91       	pop	r30
    3564:	df 91       	pop	r29
    3566:	cf 91       	pop	r28
    3568:	bf 91       	pop	r27
    356a:	af 91       	pop	r26
    356c:	9f 91       	pop	r25
    356e:	8f 91       	pop	r24
    3570:	7f 91       	pop	r23
    3572:	6f 91       	pop	r22
    3574:	5f 91       	pop	r21
    3576:	4f 91       	pop	r20
    3578:	3f 91       	pop	r19
    357a:	2f 91       	pop	r18
    357c:	0f 90       	pop	r0
    357e:	0b be       	out	0x3b, r0	; 59
    3580:	0f 90       	pop	r0
    3582:	0f be       	out	0x3f, r0	; 63
    3584:	0f 90       	pop	r0
    3586:	1f 90       	pop	r1
    3588:	18 95       	reti

0000358a <__vector_23>:
    358a:	1f 92       	push	r1
*/
// This interrupt is enabled by ISR_TIMER1_COMPAREA when it sets the motor port bits to execute
// a step. This ISR resets the motor port after a short period (settings.pulse_microseconds)
// completing one step cycle.
ISR(TIMER0_OVF_vect)
{
    358c:	0f 92       	push	r0
    358e:	0f b6       	in	r0, 0x3f	; 63
    3590:	0f 92       	push	r0
    3592:	11 24       	eor	r1, r1
    3594:	8f 93       	push	r24
    3596:	9f 93       	push	r25
  #ifdef DEFAULTS_RAMPS_BOARD
    STEP_PORT(0) = (STEP_PORT(0) & ~(1 << STEP_BIT(0))) | step_port_invert_mask[0];
    STEP_PORT(1) = (STEP_PORT(1) & ~(1 << STEP_BIT(1))) | step_port_invert_mask[1];
    STEP_PORT(2) = (STEP_PORT(2) & ~(1 << STEP_BIT(2))) | step_port_invert_mask[2];
  #else
    STEP_PORT = (STEP_PORT & ~STEP_MASK) | (step_port_invert_mask & STEP_MASK);
    3598:	82 b1       	in	r24, 0x02	; 2
    359a:	90 91 3f 03 	lds	r25, 0x033F	; 0x80033f <step_port_invert_mask>
    359e:	9c 71       	andi	r25, 0x1C	; 28
    35a0:	83 7e       	andi	r24, 0xE3	; 227
    35a2:	89 2b       	or	r24, r25
    35a4:	82 b9       	out	0x02, r24	; 2
  #endif // Ramps Board
  TCCR0B = 0; // Disable Timer0 to prevent re-entering this interrupt when it's not needed.
    35a6:	15 bc       	out	0x25, r1	; 37
}
    35a8:	9f 91       	pop	r25
    35aa:	8f 91       	pop	r24
    35ac:	0f 90       	pop	r0
    35ae:	0f be       	out	0x3f, r0	; 63
    35b0:	0f 90       	pop	r0
    35b2:	1f 90       	pop	r1
    35b4:	18 95       	reti

000035b6 <st_generate_step_dir_invert_masks>:
#endif


// Generates the step and direction port invert masks used in the Stepper Interrupt Driver.
void st_generate_step_dir_invert_masks()
{
    35b6:	0f 93       	push	r16
    35b8:	1f 93       	push	r17
    35ba:	cf 93       	push	r28

      if (bit_istrue(settings.dir_invert_mask,bit(idx))) { dir_port_invert_mask[idx] = get_direction_pin_mask(idx); }
      else { dir_port_invert_mask[idx] = 0; }
    }
  #else
    step_port_invert_mask = 0;
    35bc:	10 92 3f 03 	sts	0x033F, r1	; 0x80033f <step_port_invert_mask>
    dir_port_invert_mask = 0;
    35c0:	10 92 3e 03 	sts	0x033E, r1	; 0x80033e <dir_port_invert_mask>
    for (idx=0; idx<N_AXIS; idx++) {
    35c4:	c0 e0       	ldi	r28, 0x00	; 0
    35c6:	27 c0       	rjmp	.+78     	; 0x3616 <st_generate_step_dir_invert_masks+0x60>
      if (bit_istrue(settings.step_invert_mask,bit(idx))) { step_port_invert_mask |= get_step_pin_mask(idx); }
    35c8:	80 91 ea 0e 	lds	r24, 0x0EEA	; 0x800eea <settings+0x31>
    35cc:	0c 2f       	mov	r16, r28
    35ce:	90 e0       	ldi	r25, 0x00	; 0
    35d0:	0c 2e       	mov	r0, r28
    35d2:	02 c0       	rjmp	.+4      	; 0x35d8 <st_generate_step_dir_invert_masks+0x22>
    35d4:	95 95       	asr	r25
    35d6:	87 95       	ror	r24
    35d8:	0a 94       	dec	r0
    35da:	e2 f7       	brpl	.-8      	; 0x35d4 <st_generate_step_dir_invert_masks+0x1e>
    35dc:	80 ff       	sbrs	r24, 0
    35de:	08 c0       	rjmp	.+16     	; 0x35f0 <st_generate_step_dir_invert_masks+0x3a>
    35e0:	8c 2f       	mov	r24, r28
    35e2:	0e 94 d2 26 	call	0x4da4	; 0x4da4 <get_step_pin_mask>
    35e6:	90 91 3f 03 	lds	r25, 0x033F	; 0x80033f <step_port_invert_mask>
    35ea:	89 2b       	or	r24, r25
    35ec:	80 93 3f 03 	sts	0x033F, r24	; 0x80033f <step_port_invert_mask>
      if (bit_istrue(settings.dir_invert_mask,bit(idx))) { dir_port_invert_mask |= get_direction_pin_mask(idx); }
    35f0:	80 91 eb 0e 	lds	r24, 0x0EEB	; 0x800eeb <settings+0x32>
    35f4:	90 e0       	ldi	r25, 0x00	; 0
    35f6:	02 c0       	rjmp	.+4      	; 0x35fc <st_generate_step_dir_invert_masks+0x46>
    35f8:	95 95       	asr	r25
    35fa:	87 95       	ror	r24
    35fc:	0a 95       	dec	r16
    35fe:	e2 f7       	brpl	.-8      	; 0x35f8 <st_generate_step_dir_invert_masks+0x42>
    3600:	80 ff       	sbrs	r24, 0
    3602:	08 c0       	rjmp	.+16     	; 0x3614 <st_generate_step_dir_invert_masks+0x5e>
    3604:	8c 2f       	mov	r24, r28
    3606:	0e 94 dc 26 	call	0x4db8	; 0x4db8 <get_direction_pin_mask>
    360a:	90 91 3e 03 	lds	r25, 0x033E	; 0x80033e <dir_port_invert_mask>
    360e:	89 2b       	or	r24, r25
    3610:	80 93 3e 03 	sts	0x033E, r24	; 0x80033e <dir_port_invert_mask>
      else { dir_port_invert_mask[idx] = 0; }
    }
  #else
    step_port_invert_mask = 0;
    dir_port_invert_mask = 0;
    for (idx=0; idx<N_AXIS; idx++) {
    3614:	cf 5f       	subi	r28, 0xFF	; 255
    3616:	c3 30       	cpi	r28, 0x03	; 3
    3618:	b8 f2       	brcs	.-82     	; 0x35c8 <st_generate_step_dir_invert_masks+0x12>
      if (bit_istrue(settings.step_invert_mask,bit(idx))) { step_port_invert_mask |= get_step_pin_mask(idx); }
      if (bit_istrue(settings.dir_invert_mask,bit(idx))) { dir_port_invert_mask |= get_direction_pin_mask(idx); }
    }
  #endif // Ramps Board
}
    361a:	cf 91       	pop	r28
    361c:	1f 91       	pop	r17
    361e:	0f 91       	pop	r16
    3620:	08 95       	ret

00003622 <st_reset>:


// Reset and clear stepper subsystem variables
void st_reset()
{
    3622:	cf 93       	push	r28
    3624:	df 93       	push	r29
  #ifdef DEFAULTS_RAMPS_BOARD
    uint8_t idx;
  #endif // Ramps Board

  // Initialize stepper driver idle state.
  st_go_idle();
    3626:	7e dd       	rcall	.-1284   	; 0x3124 <st_go_idle>

  // Initialize stepper algorithm variables.
  memset(&prep, 0, sizeof(st_prep_t));
    3628:	81 e3       	ldi	r24, 0x31	; 49
    362a:	e8 e0       	ldi	r30, 0x08	; 8
    362c:	f3 e0       	ldi	r31, 0x03	; 3
    362e:	df 01       	movw	r26, r30
    3630:	1d 92       	st	X+, r1
    3632:	8a 95       	dec	r24
    3634:	e9 f7       	brne	.-6      	; 0x3630 <st_reset+0xe>
  memset(&st, 0, sizeof(stepper_t));
    3636:	c3 e4       	ldi	r28, 0x43	; 67
    3638:	d3 e0       	ldi	r29, 0x03	; 3
    363a:	83 e2       	ldi	r24, 0x23	; 35
    363c:	fe 01       	movw	r30, r28
    363e:	11 92       	st	Z+, r1
    3640:	8a 95       	dec	r24
    3642:	e9 f7       	brne	.-6      	; 0x363e <st_reset+0x1c>
  st.exec_segment = NULL;
  pl_block = NULL;  // Planner block pointer used by segment buffer
    3644:	10 92 3c 03 	sts	0x033C, r1	; 0x80033c <pl_block+0x1>
    3648:	10 92 3b 03 	sts	0x033B, r1	; 0x80033b <pl_block>
  segment_buffer_tail = 0;
    364c:	10 92 42 03 	sts	0x0342, r1	; 0x800342 <segment_buffer_tail>
  segment_buffer_head = 0; // empty = tail
    3650:	10 92 41 03 	sts	0x0341, r1	; 0x800341 <segment_buffer_head>
  segment_next_head = 1;
    3654:	81 e0       	ldi	r24, 0x01	; 1
    3656:	80 93 40 03 	sts	0x0340, r24	; 0x800340 <segment_next_head>
  busy = false;
    365a:	10 92 3d 03 	sts	0x033D, r1	; 0x80033d <busy>

  st_generate_step_dir_invert_masks();
    365e:	ab df       	rcall	.-170    	; 0x35b6 <st_generate_step_dir_invert_masks>
    DIRECTION_PORT(1) = (DIRECTION_PORT(1) & ~(1 << DIRECTION_BIT(1))) | dir_port_invert_mask[1];
  
    STEP_PORT(2) = (STEP_PORT(2) & ~(1 << STEP_BIT(2))) | step_port_invert_mask[2];
    DIRECTION_PORT(2) = (DIRECTION_PORT(2) & ~(1 << DIRECTION_BIT(2))) | dir_port_invert_mask[2];
  #else
    st.dir_outbits = dir_port_invert_mask; // Initialize direction bits to default.
    3660:	80 91 3e 03 	lds	r24, 0x033E	; 0x80033e <dir_port_invert_mask>
    3664:	8f 87       	std	Y+15, r24	; 0x0f

    // Initialize step and direction port pins.
    STEP_PORT = (STEP_PORT & ~STEP_MASK) | step_port_invert_mask;
    3666:	82 b1       	in	r24, 0x02	; 2
    3668:	83 7e       	andi	r24, 0xE3	; 227
    366a:	90 91 3f 03 	lds	r25, 0x033F	; 0x80033f <step_port_invert_mask>
    366e:	89 2b       	or	r24, r25
    3670:	82 b9       	out	0x02, r24	; 2
    DIRECTION_PORT = (DIRECTION_PORT & ~DIRECTION_MASK) | dir_port_invert_mask;
    3672:	88 b1       	in	r24, 0x08	; 8
    3674:	8f 71       	andi	r24, 0x1F	; 31
    3676:	90 91 3e 03 	lds	r25, 0x033E	; 0x80033e <dir_port_invert_mask>
    367a:	89 2b       	or	r24, r25
    367c:	88 b9       	out	0x08, r24	; 8
  #endif // Ramps Board
}
    367e:	df 91       	pop	r29
    3680:	cf 91       	pop	r28
    3682:	08 95       	ret

00003684 <stepper_init>:
  
    DIRECTION_DDR(0) |= 1<<DIRECTION_BIT(0);
    DIRECTION_DDR(1) |= 1<<DIRECTION_BIT(1);
    DIRECTION_DDR(2) |= 1<<DIRECTION_BIT(2);
  #else
    STEP_DDR |= STEP_MASK;
    3684:	81 b1       	in	r24, 0x01	; 1
    3686:	8c 61       	ori	r24, 0x1C	; 28
    3688:	81 b9       	out	0x01, r24	; 1
    STEPPERS_DISABLE_DDR |= 1<<STEPPERS_DISABLE_BIT;
    368a:	84 b1       	in	r24, 0x04	; 4
    368c:	80 68       	ori	r24, 0x80	; 128
    368e:	84 b9       	out	0x04, r24	; 4
    DIRECTION_DDR |= DIRECTION_MASK;
    3690:	87 b1       	in	r24, 0x07	; 7
    3692:	80 6e       	ori	r24, 0xE0	; 224
    3694:	87 b9       	out	0x07, r24	; 7
  #endif // Ramps Board

  // Configure Timer 1: Stepper Driver Interrupt
  TCCR1B &= ~(1<<WGM13); // waveform generation = 0100 = CTC
    3696:	e1 e8       	ldi	r30, 0x81	; 129
    3698:	f0 e0       	ldi	r31, 0x00	; 0
    369a:	80 81       	ld	r24, Z
    369c:	8f 7e       	andi	r24, 0xEF	; 239
    369e:	80 83       	st	Z, r24
  TCCR1B |=  (1<<WGM12);
    36a0:	80 81       	ld	r24, Z
    36a2:	88 60       	ori	r24, 0x08	; 8
    36a4:	80 83       	st	Z, r24
  TCCR1A &= ~((1<<WGM11) | (1<<WGM10));
    36a6:	e0 e8       	ldi	r30, 0x80	; 128
    36a8:	f0 e0       	ldi	r31, 0x00	; 0
    36aa:	80 81       	ld	r24, Z
    36ac:	8c 7f       	andi	r24, 0xFC	; 252
    36ae:	80 83       	st	Z, r24
  TCCR1A &= ~((1<<COM1A1) | (1<<COM1A0) | (1<<COM1B1) | (1<<COM1B0)); // Disconnect OC1 output
    36b0:	80 81       	ld	r24, Z
    36b2:	8f 70       	andi	r24, 0x0F	; 15
    36b4:	80 83       	st	Z, r24
  // TCCR1B = (TCCR1B & ~((1<<CS12) | (1<<CS11))) | (1<<CS10); // Set in st_go_idle().
  // TIMSK1 &= ~(1<<OCIE1A);  // Set in st_go_idle().

  // Configure Timer 0: Stepper Port Reset Interrupt
  TIMSK0 &= ~((1<<OCIE0B) | (1<<OCIE0A) | (1<<TOIE0)); // Disconnect OC0 outputs and OVF interrupt.
    36b6:	ee e6       	ldi	r30, 0x6E	; 110
    36b8:	f0 e0       	ldi	r31, 0x00	; 0
    36ba:	80 81       	ld	r24, Z
    36bc:	88 7f       	andi	r24, 0xF8	; 248
    36be:	80 83       	st	Z, r24
  TCCR0A = 0; // Normal operation
    36c0:	14 bc       	out	0x24, r1	; 36
  TCCR0B = 0; // Disable Timer0 until needed
    36c2:	15 bc       	out	0x25, r1	; 37
  TIMSK0 |= (1<<TOIE0); // Enable Timer0 overflow interrupt
    36c4:	80 81       	ld	r24, Z
    36c6:	81 60       	ori	r24, 0x01	; 1
    36c8:	80 83       	st	Z, r24
    36ca:	08 95       	ret

000036cc <st_update_plan_block_parameters>:
}


// Called by planner_recalculate() when the executing block is updated by the new plan.
void st_update_plan_block_parameters()
{
    36cc:	cf 93       	push	r28
    36ce:	df 93       	push	r29
  if (pl_block != NULL) { // Ignore if at start of a new block.
    36d0:	c0 91 3b 03 	lds	r28, 0x033B	; 0x80033b <pl_block>
    36d4:	d0 91 3c 03 	lds	r29, 0x033C	; 0x80033c <pl_block+0x1>
    36d8:	20 97       	sbiw	r28, 0x00	; 0
    36da:	a9 f0       	breq	.+42     	; 0x3706 <st_update_plan_block_parameters+0x3a>
    prep.recalculate_flag |= PREP_FLAG_RECALCULATE;
    36dc:	e8 e0       	ldi	r30, 0x08	; 8
    36de:	f3 e0       	ldi	r31, 0x03	; 3
    36e0:	81 81       	ldd	r24, Z+1	; 0x01
    36e2:	81 60       	ori	r24, 0x01	; 1
    36e4:	81 83       	std	Z+1, r24	; 0x01
    pl_block->entry_speed_sqr = prep.current_speed*prep.current_speed; // Update entry speed.
    36e6:	67 89       	ldd	r22, Z+23	; 0x17
    36e8:	70 8d       	ldd	r23, Z+24	; 0x18
    36ea:	81 8d       	ldd	r24, Z+25	; 0x19
    36ec:	92 8d       	ldd	r25, Z+26	; 0x1a
    36ee:	9b 01       	movw	r18, r22
    36f0:	ac 01       	movw	r20, r24
    36f2:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
    36f6:	6e 8b       	std	Y+22, r22	; 0x16
    36f8:	7f 8b       	std	Y+23, r23	; 0x17
    36fa:	88 8f       	std	Y+24, r24	; 0x18
    36fc:	99 8f       	std	Y+25, r25	; 0x19
    pl_block = NULL; // Flag st_prep_segment() to load and check active velocity profile.
    36fe:	10 92 3c 03 	sts	0x033C, r1	; 0x80033c <pl_block+0x1>
    3702:	10 92 3b 03 	sts	0x033B, r1	; 0x80033b <pl_block>
  }
}
    3706:	df 91       	pop	r29
    3708:	cf 91       	pop	r28
    370a:	08 95       	ret

0000370c <st_prep_buffer>:
   longer than the time it takes the stepper algorithm to empty it before refilling it.
   Currently, the segment buffer conservatively holds roughly up to 40-50 msec of steps.
   NOTE: Computation units are in steps, millimeters, and minutes.
*/
void st_prep_buffer()
{
    370c:	2f 92       	push	r2
    370e:	3f 92       	push	r3
    3710:	4f 92       	push	r4
    3712:	5f 92       	push	r5
    3714:	6f 92       	push	r6
    3716:	7f 92       	push	r7
    3718:	8f 92       	push	r8
    371a:	9f 92       	push	r9
    371c:	af 92       	push	r10
    371e:	bf 92       	push	r11
    3720:	cf 92       	push	r12
    3722:	df 92       	push	r13
    3724:	ef 92       	push	r14
    3726:	ff 92       	push	r15
    3728:	0f 93       	push	r16
    372a:	1f 93       	push	r17
    372c:	cf 93       	push	r28
    372e:	df 93       	push	r29
    3730:	cd b7       	in	r28, 0x3d	; 61
    3732:	de b7       	in	r29, 0x3e	; 62
    3734:	6f 97       	sbiw	r28, 0x1f	; 31
    3736:	0f b6       	in	r0, 0x3f	; 63
    3738:	f8 94       	cli
    373a:	de bf       	out	0x3e, r29	; 62
    373c:	0f be       	out	0x3f, r0	; 63
    373e:	cd bf       	out	0x3d, r28	; 61
  // Block step prep buffer, while in a suspend state and there is no suspend motion to execute.
  if (bit_istrue(sys.step_control,STEP_CONTROL_END_MOTION)) { return; }
    3740:	80 91 15 0c 	lds	r24, 0x0C15	; 0x800c15 <sys+0x4>
    3744:	80 ff       	sbrs	r24, 0
    3746:	ec c7       	rjmp	.+4056   	; 0x4720 <st_prep_buffer+0x1014>
    3748:	f1 c7       	rjmp	.+4066   	; 0x472c <st_prep_buffer+0x1020>

  while (segment_buffer_tail != segment_next_head) { // Check if we need to fill the buffer.

    // Determine if we need to load a new planner block or if the block needs to be recomputed.
    if (pl_block == NULL) {
    374a:	80 91 3b 03 	lds	r24, 0x033B	; 0x80033b <pl_block>
    374e:	90 91 3c 03 	lds	r25, 0x033C	; 0x80033c <pl_block+0x1>
    3752:	89 2b       	or	r24, r25
    3754:	09 f0       	breq	.+2      	; 0x3758 <st_prep_buffer+0x4c>
    3756:	40 c3       	rjmp	.+1664   	; 0x3dd8 <st_prep_buffer+0x6cc>

      // Query planner for a queued block
      if (sys.step_control & STEP_CONTROL_EXECUTE_SYS_MOTION) { pl_block = plan_get_system_motion_block(); }
    3758:	80 91 15 0c 	lds	r24, 0x0C15	; 0x800c15 <sys+0x4>
    375c:	82 ff       	sbrs	r24, 2
    375e:	07 c0       	rjmp	.+14     	; 0x376e <st_prep_buffer+0x62>
    3760:	0e 94 ba 28 	call	0x5174	; 0x5174 <plan_get_system_motion_block>
    3764:	90 93 3c 03 	sts	0x033C, r25	; 0x80033c <pl_block+0x1>
    3768:	80 93 3b 03 	sts	0x033B, r24	; 0x80033b <pl_block>
    376c:	06 c0       	rjmp	.+12     	; 0x377a <st_prep_buffer+0x6e>
      else { pl_block = plan_get_current_block(); }
    376e:	0e 94 c3 28 	call	0x5186	; 0x5186 <plan_get_current_block>
    3772:	90 93 3c 03 	sts	0x033C, r25	; 0x80033c <pl_block+0x1>
    3776:	80 93 3b 03 	sts	0x033B, r24	; 0x80033b <pl_block>
      if (pl_block == NULL) { return; } // No planner blocks. Exit.
    377a:	e0 90 3b 03 	lds	r14, 0x033B	; 0x80033b <pl_block>
    377e:	f0 90 3c 03 	lds	r15, 0x033C	; 0x80033c <pl_block+0x1>
    3782:	e1 14       	cp	r14, r1
    3784:	f1 04       	cpc	r15, r1
    3786:	09 f4       	brne	.+2      	; 0x378a <st_prep_buffer+0x7e>
    3788:	d1 c7       	rjmp	.+4002   	; 0x472c <st_prep_buffer+0x1020>

      // Check if we need to only recompute the velocity profile or load a new block.
      if (prep.recalculate_flag & PREP_FLAG_RECALCULATE) {
    378a:	80 91 09 03 	lds	r24, 0x0309	; 0x800309 <prep+0x1>
    378e:	80 ff       	sbrs	r24, 0
    3790:	03 c0       	rjmp	.+6      	; 0x3798 <st_prep_buffer+0x8c>

        #ifdef PARKING_ENABLE
          if (prep.recalculate_flag & PREP_FLAG_PARKING) { prep.recalculate_flag &= ~(PREP_FLAG_RECALCULATE); }
          else { prep.recalculate_flag = false; }
        #else
          prep.recalculate_flag = false;
    3792:	10 92 09 03 	sts	0x0309, r1	; 0x800309 <prep+0x1>
    3796:	ed c0       	rjmp	.+474    	; 0x3972 <st_prep_buffer+0x266>
        #endif

      } else {

        // Load the Bresenham stepping data for the block.
        prep.st_block_index = st_next_block_index(prep.st_block_index);
    3798:	08 e0       	ldi	r16, 0x08	; 8
    379a:	13 e0       	ldi	r17, 0x03	; 3
    379c:	d8 01       	movw	r26, r16
    379e:	8c 91       	ld	r24, X
    37a0:	98 dc       	rcall	.-1744   	; 0x30d2 <st_next_block_index>
    37a2:	f8 01       	movw	r30, r16
    37a4:	80 83       	st	Z, r24

        // Prepare and copy Bresenham algorithm segment data from the new planner block, so that
        // when the segment buffer completes the planner block, it may be discarded when the
        // segment buffer finishes the prepped block, but the stepper ISR is still executing it.
        st_prep_block = &st_block_buffer[prep.st_block_index];
    37a6:	90 e0       	ldi	r25, 0x00	; 0
    37a8:	88 0f       	add	r24, r24
    37aa:	99 1f       	adc	r25, r25
    37ac:	fc 01       	movw	r30, r24
    37ae:	ee 0f       	add	r30, r30
    37b0:	ff 1f       	adc	r31, r31
    37b2:	ee 0f       	add	r30, r30
    37b4:	ff 1f       	adc	r31, r31
    37b6:	ee 0f       	add	r30, r30
    37b8:	ff 1f       	adc	r31, r31
    37ba:	e8 0f       	add	r30, r24
    37bc:	f9 1f       	adc	r31, r25
    37be:	ea 54       	subi	r30, 0x4A	; 74
    37c0:	fc 4f       	sbci	r31, 0xFC	; 252
    37c2:	f0 93 3a 03 	sts	0x033A, r31	; 0x80033a <st_prep_block+0x1>
    37c6:	e0 93 39 03 	sts	0x0339, r30	; 0x800339 <st_prep_block>
        #ifdef DEFAULTS_RAMPS_BOARD
          for (idx=0; idx<N_AXIS; idx++) {
            st_prep_block->direction_bits[idx] = pl_block->direction_bits[idx];
          }
        #else
          st_prep_block->direction_bits = pl_block->direction_bits;
    37ca:	d7 01       	movw	r26, r14
    37cc:	50 96       	adiw	r26, 0x10	; 16
    37ce:	8c 91       	ld	r24, X
    37d0:	80 8b       	std	Z+16, r24	; 0x10
          st_prep_block->step_event_count = (pl_block->step_event_count << 1);
        #else
          // With AMASS enabled, simply bit-shift multiply all Bresenham data by the max AMASS
          // level, such that we never divide beyond the original data anywhere in the algorithm.
          // If the original data is divided, we can lose a step from integer roundoff.
          for (idx=0; idx<N_AXIS; idx++) { st_prep_block->steps[idx] = pl_block->steps[idx] << MAX_AMASS_LEVEL; }
    37d2:	20 e0       	ldi	r18, 0x00	; 0
    37d4:	fa 82       	std	Y+2, r15	; 0x02
    37d6:	e9 82       	std	Y+1, r14	; 0x01
    37d8:	23 c0       	rjmp	.+70     	; 0x3820 <st_prep_buffer+0x114>
    37da:	82 2f       	mov	r24, r18
    37dc:	90 e0       	ldi	r25, 0x00	; 0
    37de:	88 0f       	add	r24, r24
    37e0:	99 1f       	adc	r25, r25
    37e2:	88 0f       	add	r24, r24
    37e4:	99 1f       	adc	r25, r25
    37e6:	a9 81       	ldd	r26, Y+1	; 0x01
    37e8:	ba 81       	ldd	r27, Y+2	; 0x02
    37ea:	a8 0f       	add	r26, r24
    37ec:	b9 1f       	adc	r27, r25
    37ee:	4d 91       	ld	r20, X+
    37f0:	5d 91       	ld	r21, X+
    37f2:	6d 91       	ld	r22, X+
    37f4:	7c 91       	ld	r23, X
    37f6:	44 0f       	add	r20, r20
    37f8:	55 1f       	adc	r21, r21
    37fa:	66 1f       	adc	r22, r22
    37fc:	77 1f       	adc	r23, r23
    37fe:	44 0f       	add	r20, r20
    3800:	55 1f       	adc	r21, r21
    3802:	66 1f       	adc	r22, r22
    3804:	77 1f       	adc	r23, r23
    3806:	44 0f       	add	r20, r20
    3808:	55 1f       	adc	r21, r21
    380a:	66 1f       	adc	r22, r22
    380c:	77 1f       	adc	r23, r23
    380e:	df 01       	movw	r26, r30
    3810:	a8 0f       	add	r26, r24
    3812:	b9 1f       	adc	r27, r25
    3814:	4d 93       	st	X+, r20
    3816:	5d 93       	st	X+, r21
    3818:	6d 93       	st	X+, r22
    381a:	7c 93       	st	X, r23
    381c:	13 97       	sbiw	r26, 0x03	; 3
    381e:	2f 5f       	subi	r18, 0xFF	; 255
    3820:	23 30       	cpi	r18, 0x03	; 3
    3822:	d8 f2       	brcs	.-74     	; 0x37da <st_prep_buffer+0xce>
    3824:	e9 80       	ldd	r14, Y+1	; 0x01
    3826:	fa 80       	ldd	r15, Y+2	; 0x02
          st_prep_block->step_event_count = pl_block->step_event_count << MAX_AMASS_LEVEL;
    3828:	d7 01       	movw	r26, r14
    382a:	1c 96       	adiw	r26, 0x0c	; 12
    382c:	4d 91       	ld	r20, X+
    382e:	5d 91       	ld	r21, X+
    3830:	6d 91       	ld	r22, X+
    3832:	7c 91       	ld	r23, X
    3834:	1f 97       	sbiw	r26, 0x0f	; 15
    3836:	db 01       	movw	r26, r22
    3838:	ca 01       	movw	r24, r20
    383a:	88 0f       	add	r24, r24
    383c:	99 1f       	adc	r25, r25
    383e:	aa 1f       	adc	r26, r26
    3840:	bb 1f       	adc	r27, r27
    3842:	88 0f       	add	r24, r24
    3844:	99 1f       	adc	r25, r25
    3846:	aa 1f       	adc	r26, r26
    3848:	bb 1f       	adc	r27, r27
    384a:	88 0f       	add	r24, r24
    384c:	99 1f       	adc	r25, r25
    384e:	aa 1f       	adc	r26, r26
    3850:	bb 1f       	adc	r27, r27
    3852:	84 87       	std	Z+12, r24	; 0x0c
    3854:	95 87       	std	Z+13, r25	; 0x0d
    3856:	a6 87       	std	Z+14, r26	; 0x0e
    3858:	b7 87       	std	Z+15, r27	; 0x0f
        #endif

        // Initialize segment buffer data for generating the segments.
        prep.steps_remaining = (float)pl_block->step_event_count;
    385a:	f7 01       	movw	r30, r14
    385c:	64 85       	ldd	r22, Z+12	; 0x0c
    385e:	75 85       	ldd	r23, Z+13	; 0x0d
    3860:	86 85       	ldd	r24, Z+14	; 0x0e
    3862:	97 85       	ldd	r25, Z+15	; 0x0f
    3864:	0e 94 ae 3d 	call	0x7b5c	; 0x7b5c <__floatunsisf>
    3868:	08 e0       	ldi	r16, 0x08	; 8
    386a:	13 e0       	ldi	r17, 0x03	; 3
    386c:	d8 01       	movw	r26, r16
    386e:	16 96       	adiw	r26, 0x06	; 6
    3870:	6d 93       	st	X+, r22
    3872:	7d 93       	st	X+, r23
    3874:	8d 93       	st	X+, r24
    3876:	9c 93       	st	X, r25
    3878:	19 97       	sbiw	r26, 0x09	; 9
        prep.step_per_mm = prep.steps_remaining/pl_block->millimeters;
    387a:	f7 01       	movw	r30, r14
    387c:	22 a1       	ldd	r18, Z+34	; 0x22
    387e:	33 a1       	ldd	r19, Z+35	; 0x23
    3880:	44 a1       	ldd	r20, Z+36	; 0x24
    3882:	55 a1       	ldd	r21, Z+37	; 0x25
    3884:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <__divsf3>
    3888:	9b 01       	movw	r18, r22
    388a:	ac 01       	movw	r20, r24
    388c:	d8 01       	movw	r26, r16
    388e:	1a 96       	adiw	r26, 0x0a	; 10
    3890:	6d 93       	st	X+, r22
    3892:	7d 93       	st	X+, r23
    3894:	8d 93       	st	X+, r24
    3896:	9c 93       	st	X, r25
    3898:	1d 97       	sbiw	r26, 0x0d	; 13
        prep.req_mm_increment = REQ_MM_INCREMENT_SCALAR/prep.step_per_mm;
    389a:	60 e0       	ldi	r22, 0x00	; 0
    389c:	70 e0       	ldi	r23, 0x00	; 0
    389e:	80 ea       	ldi	r24, 0xA0	; 160
    38a0:	9f e3       	ldi	r25, 0x3F	; 63
    38a2:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <__divsf3>
    38a6:	f8 01       	movw	r30, r16
    38a8:	66 87       	std	Z+14, r22	; 0x0e
    38aa:	77 87       	std	Z+15, r23	; 0x0f
    38ac:	80 8b       	std	Z+16, r24	; 0x10
    38ae:	91 8b       	std	Z+17, r25	; 0x11
        prep.dt_remainder = 0.0; // Reset for new segment block
    38b0:	12 82       	std	Z+2, r1	; 0x02
    38b2:	13 82       	std	Z+3, r1	; 0x03
    38b4:	14 82       	std	Z+4, r1	; 0x04
    38b6:	15 82       	std	Z+5, r1	; 0x05

        if ((sys.step_control & STEP_CONTROL_EXECUTE_HOLD) || (prep.recalculate_flag & PREP_FLAG_DECEL_OVERRIDE)) {
    38b8:	80 91 15 0c 	lds	r24, 0x0C15	; 0x800c15 <sys+0x4>
    38bc:	81 fd       	sbrc	r24, 1
    38be:	04 c0       	rjmp	.+8      	; 0x38c8 <st_prep_buffer+0x1bc>
    38c0:	80 91 09 03 	lds	r24, 0x0309	; 0x800309 <prep+0x1>
    38c4:	83 ff       	sbrs	r24, 3
    38c6:	1c c0       	rjmp	.+56     	; 0x3900 <st_prep_buffer+0x1f4>
          // New block loaded mid-hold. Override planner block entry speed to enforce deceleration.
          prep.current_speed = prep.exit_speed;
    38c8:	08 e0       	ldi	r16, 0x08	; 8
    38ca:	13 e0       	ldi	r17, 0x03	; 3
    38cc:	f8 01       	movw	r30, r16
    38ce:	67 8d       	ldd	r22, Z+31	; 0x1f
    38d0:	70 a1       	ldd	r23, Z+32	; 0x20
    38d2:	81 a1       	ldd	r24, Z+33	; 0x21
    38d4:	92 a1       	ldd	r25, Z+34	; 0x22
    38d6:	67 8b       	std	Z+23, r22	; 0x17
    38d8:	70 8f       	std	Z+24, r23	; 0x18
    38da:	81 8f       	std	Z+25, r24	; 0x19
    38dc:	92 8f       	std	Z+26, r25	; 0x1a
          pl_block->entry_speed_sqr = prep.exit_speed*prep.exit_speed;
    38de:	9b 01       	movw	r18, r22
    38e0:	ac 01       	movw	r20, r24
    38e2:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
    38e6:	f7 01       	movw	r30, r14
    38e8:	66 8b       	std	Z+22, r22	; 0x16
    38ea:	77 8b       	std	Z+23, r23	; 0x17
    38ec:	80 8f       	std	Z+24, r24	; 0x18
    38ee:	91 8f       	std	Z+25, r25	; 0x19
          prep.recalculate_flag &= ~(PREP_FLAG_DECEL_OVERRIDE);
    38f0:	d8 01       	movw	r26, r16
    38f2:	11 96       	adiw	r26, 0x01	; 1
    38f4:	8c 91       	ld	r24, X
    38f6:	11 97       	sbiw	r26, 0x01	; 1
    38f8:	87 7f       	andi	r24, 0xF7	; 247
    38fa:	11 96       	adiw	r26, 0x01	; 1
    38fc:	8c 93       	st	X, r24
    38fe:	0f c0       	rjmp	.+30     	; 0x391e <st_prep_buffer+0x212>
        } else {
          prep.current_speed = sqrt(pl_block->entry_speed_sqr);
    3900:	f7 01       	movw	r30, r14
    3902:	66 89       	ldd	r22, Z+22	; 0x16
    3904:	77 89       	ldd	r23, Z+23	; 0x17
    3906:	80 8d       	ldd	r24, Z+24	; 0x18
    3908:	91 8d       	ldd	r25, Z+25	; 0x19
    390a:	0e 94 d9 3f 	call	0x7fb2	; 0x7fb2 <sqrt>
    390e:	60 93 1f 03 	sts	0x031F, r22	; 0x80031f <prep+0x17>
    3912:	70 93 20 03 	sts	0x0320, r23	; 0x800320 <prep+0x18>
    3916:	80 93 21 03 	sts	0x0321, r24	; 0x800321 <prep+0x19>
    391a:	90 93 22 03 	sts	0x0322, r25	; 0x800322 <prep+0x1a>
        }
        
        // Setup laser mode variables. PWM rate adjusted motions will always complete a motion with the
        // spindle off. 
        st_prep_block->is_pwm_rate_adjusted = false;
    391e:	80 91 39 03 	lds	r24, 0x0339	; 0x800339 <st_prep_block>
    3922:	90 91 3a 03 	lds	r25, 0x033A	; 0x80033a <st_prep_block+0x1>
    3926:	9a 83       	std	Y+2, r25	; 0x02
    3928:	89 83       	std	Y+1, r24	; 0x01
    392a:	dc 01       	movw	r26, r24
    392c:	51 96       	adiw	r26, 0x11	; 17
    392e:	1c 92       	st	X, r1
        if (settings.flags & BITFLAG_LASER_MODE) {
    3930:	80 91 fe 0e 	lds	r24, 0x0EFE	; 0x800efe <settings+0x45>
    3934:	81 ff       	sbrs	r24, 1
    3936:	1d c0       	rjmp	.+58     	; 0x3972 <st_prep_buffer+0x266>
          if (pl_block->condition & PL_COND_FLAG_SPINDLE_CCW) { 
    3938:	e0 91 3b 03 	lds	r30, 0x033B	; 0x80033b <pl_block>
    393c:	f0 91 3c 03 	lds	r31, 0x033C	; 0x80033c <pl_block+0x1>
    3940:	81 89       	ldd	r24, Z+17	; 0x11
    3942:	85 ff       	sbrs	r24, 5
    3944:	16 c0       	rjmp	.+44     	; 0x3972 <st_prep_buffer+0x266>
            // Pre-compute inverse programmed rate to speed up PWM updating per step segment.
            prep.inv_rate = 1.0/pl_block->programmed_rate;
    3946:	26 a5       	ldd	r18, Z+46	; 0x2e
    3948:	37 a5       	ldd	r19, Z+47	; 0x2f
    394a:	40 a9       	ldd	r20, Z+48	; 0x30
    394c:	51 a9       	ldd	r21, Z+49	; 0x31
    394e:	60 e0       	ldi	r22, 0x00	; 0
    3950:	70 e0       	ldi	r23, 0x00	; 0
    3952:	80 e8       	ldi	r24, 0x80	; 128
    3954:	9f e3       	ldi	r25, 0x3F	; 63
    3956:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <__divsf3>
    395a:	60 93 33 03 	sts	0x0333, r22	; 0x800333 <prep+0x2b>
    395e:	70 93 34 03 	sts	0x0334, r23	; 0x800334 <prep+0x2c>
    3962:	80 93 35 03 	sts	0x0335, r24	; 0x800335 <prep+0x2d>
    3966:	90 93 36 03 	sts	0x0336, r25	; 0x800336 <prep+0x2e>
            st_prep_block->is_pwm_rate_adjusted = true; 
    396a:	81 e0       	ldi	r24, 0x01	; 1
    396c:	e9 81       	ldd	r30, Y+1	; 0x01
    396e:	fa 81       	ldd	r31, Y+2	; 0x02
    3970:	81 8b       	std	Z+17, r24	; 0x11
			 Compute the velocity profile of a new planner block based on its entry and exit
			 speeds, or recompute the profile of a partially-completed planner block if the
			 planner has updated it. For a commanded forced-deceleration, such as from a feed
			 hold, override the planner velocities and decelerate to the target exit speed.
			*/
			prep.mm_complete = 0.0; // Default velocity profile complete at 0.0mm from end of block.
    3972:	10 92 1b 03 	sts	0x031B, r1	; 0x80031b <prep+0x13>
    3976:	10 92 1c 03 	sts	0x031C, r1	; 0x80031c <prep+0x14>
    397a:	10 92 1d 03 	sts	0x031D, r1	; 0x80031d <prep+0x15>
    397e:	10 92 1e 03 	sts	0x031E, r1	; 0x80031e <prep+0x16>
			float inv_2_accel = 0.5/pl_block->acceleration;
    3982:	80 91 3b 03 	lds	r24, 0x033B	; 0x80033b <pl_block>
    3986:	90 91 3c 03 	lds	r25, 0x033C	; 0x80033c <pl_block+0x1>
    398a:	9e 83       	std	Y+6, r25	; 0x06
    398c:	8d 83       	std	Y+5, r24	; 0x05
    398e:	dc 01       	movw	r26, r24
    3990:	5e 96       	adiw	r26, 0x1e	; 30
    3992:	cd 90       	ld	r12, X+
    3994:	dd 90       	ld	r13, X+
    3996:	ed 90       	ld	r14, X+
    3998:	fc 90       	ld	r15, X
    399a:	91 97       	sbiw	r26, 0x21	; 33
    399c:	a7 01       	movw	r20, r14
    399e:	96 01       	movw	r18, r12
    39a0:	60 e0       	ldi	r22, 0x00	; 0
    39a2:	70 e0       	ldi	r23, 0x00	; 0
    39a4:	80 e0       	ldi	r24, 0x00	; 0
    39a6:	9f e3       	ldi	r25, 0x3F	; 63
    39a8:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <__divsf3>
    39ac:	69 83       	std	Y+1, r22	; 0x01
    39ae:	7a 83       	std	Y+2, r23	; 0x02
    39b0:	8b 83       	std	Y+3, r24	; 0x03
    39b2:	9c 83       	std	Y+4, r25	; 0x04
			if (sys.step_control & STEP_CONTROL_EXECUTE_HOLD) { // [Forced Deceleration to Zero Velocity]
    39b4:	80 91 15 0c 	lds	r24, 0x0C15	; 0x800c15 <sys+0x4>
    39b8:	81 ff       	sbrs	r24, 1
    39ba:	52 c0       	rjmp	.+164    	; 0x3a60 <st_prep_buffer+0x354>
				// Compute velocity profile parameters for a feed hold in-progress. This profile overrides
				// the planner block profile, enforcing a deceleration to zero speed.
				prep.ramp_type = RAMP_DECEL;
    39bc:	82 e0       	ldi	r24, 0x02	; 2
    39be:	80 93 1a 03 	sts	0x031A, r24	; 0x80031a <prep+0x12>
				// Compute decelerate distance relative to end of block.
				float decel_dist = pl_block->millimeters - inv_2_accel*pl_block->entry_speed_sqr;
    39c2:	ed 81       	ldd	r30, Y+5	; 0x05
    39c4:	fe 81       	ldd	r31, Y+6	; 0x06
    39c6:	42 a0       	ldd	r4, Z+34	; 0x22
    39c8:	53 a0       	ldd	r5, Z+35	; 0x23
    39ca:	64 a0       	ldd	r6, Z+36	; 0x24
    39cc:	75 a0       	ldd	r7, Z+37	; 0x25
    39ce:	86 88       	ldd	r8, Z+22	; 0x16
    39d0:	97 88       	ldd	r9, Z+23	; 0x17
    39d2:	a0 8c       	ldd	r10, Z+24	; 0x18
    39d4:	b1 8c       	ldd	r11, Z+25	; 0x19
    39d6:	a5 01       	movw	r20, r10
    39d8:	94 01       	movw	r18, r8
    39da:	69 81       	ldd	r22, Y+1	; 0x01
    39dc:	7a 81       	ldd	r23, Y+2	; 0x02
    39de:	8b 81       	ldd	r24, Y+3	; 0x03
    39e0:	9c 81       	ldd	r25, Y+4	; 0x04
    39e2:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
    39e6:	9b 01       	movw	r18, r22
    39e8:	ac 01       	movw	r20, r24
    39ea:	c3 01       	movw	r24, r6
    39ec:	b2 01       	movw	r22, r4
    39ee:	0e 94 34 3c 	call	0x7868	; 0x7868 <__subsf3>
    39f2:	69 83       	std	Y+1, r22	; 0x01
    39f4:	7a 83       	std	Y+2, r23	; 0x02
    39f6:	8b 83       	std	Y+3, r24	; 0x03
    39f8:	9c 83       	std	Y+4, r25	; 0x04
				if (decel_dist < 0.0) {
    39fa:	20 e0       	ldi	r18, 0x00	; 0
    39fc:	30 e0       	ldi	r19, 0x00	; 0
    39fe:	a9 01       	movw	r20, r18
    3a00:	0e 94 0e 3d 	call	0x7a1c	; 0x7a1c <__cmpsf2>
    3a04:	88 23       	and	r24, r24
    3a06:	ec f4       	brge	.+58     	; 0x3a42 <st_prep_buffer+0x336>
					// Deceleration through entire planner block. End of feed hold is not in this block.
					prep.exit_speed = sqrt(pl_block->entry_speed_sqr-2*pl_block->acceleration*pl_block->millimeters);
    3a08:	a7 01       	movw	r20, r14
    3a0a:	96 01       	movw	r18, r12
    3a0c:	c7 01       	movw	r24, r14
    3a0e:	b6 01       	movw	r22, r12
    3a10:	0e 94 35 3c 	call	0x786a	; 0x786a <__addsf3>
    3a14:	9b 01       	movw	r18, r22
    3a16:	ac 01       	movw	r20, r24
    3a18:	c3 01       	movw	r24, r6
    3a1a:	b2 01       	movw	r22, r4
    3a1c:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
    3a20:	9b 01       	movw	r18, r22
    3a22:	ac 01       	movw	r20, r24
    3a24:	c5 01       	movw	r24, r10
    3a26:	b4 01       	movw	r22, r8
    3a28:	0e 94 34 3c 	call	0x7868	; 0x7868 <__subsf3>
    3a2c:	0e 94 d9 3f 	call	0x7fb2	; 0x7fb2 <sqrt>
    3a30:	60 93 27 03 	sts	0x0327, r22	; 0x800327 <prep+0x1f>
    3a34:	70 93 28 03 	sts	0x0328, r23	; 0x800328 <prep+0x20>
    3a38:	80 93 29 03 	sts	0x0329, r24	; 0x800329 <prep+0x21>
    3a3c:	90 93 2a 03 	sts	0x032A, r25	; 0x80032a <prep+0x22>
    3a40:	c6 c1       	rjmp	.+908    	; 0x3dce <st_prep_buffer+0x6c2>
				} else {
					prep.mm_complete = decel_dist; // End of feed hold.
    3a42:	e8 e0       	ldi	r30, 0x08	; 8
    3a44:	f3 e0       	ldi	r31, 0x03	; 3
    3a46:	89 81       	ldd	r24, Y+1	; 0x01
    3a48:	9a 81       	ldd	r25, Y+2	; 0x02
    3a4a:	ab 81       	ldd	r26, Y+3	; 0x03
    3a4c:	bc 81       	ldd	r27, Y+4	; 0x04
    3a4e:	83 8b       	std	Z+19, r24	; 0x13
    3a50:	94 8b       	std	Z+20, r25	; 0x14
    3a52:	a5 8b       	std	Z+21, r26	; 0x15
    3a54:	b6 8b       	std	Z+22, r27	; 0x16
					prep.exit_speed = 0.0;
    3a56:	17 8e       	std	Z+31, r1	; 0x1f
    3a58:	10 a2       	std	Z+32, r1	; 0x20
    3a5a:	11 a2       	std	Z+33, r1	; 0x21
    3a5c:	12 a2       	std	Z+34, r1	; 0x22
    3a5e:	b7 c1       	rjmp	.+878    	; 0x3dce <st_prep_buffer+0x6c2>
				}
			} else { // [Normal Operation]
				// Compute or recompute velocity profile parameters of the prepped planner block.
				prep.ramp_type = RAMP_ACCEL; // Initialize as acceleration ramp.
    3a60:	e8 e0       	ldi	r30, 0x08	; 8
    3a62:	f3 e0       	ldi	r31, 0x03	; 3
    3a64:	12 8a       	std	Z+18, r1	; 0x12
				prep.accelerate_until = pl_block->millimeters;
    3a66:	ad 81       	ldd	r26, Y+5	; 0x05
    3a68:	be 81       	ldd	r27, Y+6	; 0x06
    3a6a:	92 96       	adiw	r26, 0x22	; 34
    3a6c:	4d 91       	ld	r20, X+
    3a6e:	5d 91       	ld	r21, X+
    3a70:	6d 91       	ld	r22, X+
    3a72:	7c 91       	ld	r23, X
    3a74:	95 97       	sbiw	r26, 0x25	; 37
    3a76:	43 a3       	std	Z+35, r20	; 0x23
    3a78:	54 a3       	std	Z+36, r21	; 0x24
    3a7a:	65 a3       	std	Z+37, r22	; 0x25
    3a7c:	76 a3       	std	Z+38, r23	; 0x26

				float exit_speed_sqr;
				float nominal_speed;
        if (sys.step_control & STEP_CONTROL_EXECUTE_SYS_MOTION) {
    3a7e:	82 ff       	sbrs	r24, 2
    3a80:	0d c0       	rjmp	.+26     	; 0x3a9c <st_prep_buffer+0x390>
          prep.exit_speed = exit_speed_sqr = 0.0; // Enforce stop at end of system motion.
    3a82:	10 92 27 03 	sts	0x0327, r1	; 0x800327 <prep+0x1f>
    3a86:	10 92 28 03 	sts	0x0328, r1	; 0x800328 <prep+0x20>
    3a8a:	10 92 29 03 	sts	0x0329, r1	; 0x800329 <prep+0x21>
    3a8e:	10 92 2a 03 	sts	0x032A, r1	; 0x80032a <prep+0x22>
    3a92:	1d 86       	std	Y+13, r1	; 0x0d
    3a94:	1e 86       	std	Y+14, r1	; 0x0e
    3a96:	1f 86       	std	Y+15, r1	; 0x0f
    3a98:	18 8a       	std	Y+16, r1	; 0x10
    3a9a:	10 c0       	rjmp	.+32     	; 0x3abc <st_prep_buffer+0x3b0>
        } else {
          exit_speed_sqr = plan_get_exec_block_exit_speed_sqr();
    3a9c:	0e 94 d3 28 	call	0x51a6	; 0x51a6 <plan_get_exec_block_exit_speed_sqr>
    3aa0:	6d 87       	std	Y+13, r22	; 0x0d
    3aa2:	7e 87       	std	Y+14, r23	; 0x0e
    3aa4:	8f 87       	std	Y+15, r24	; 0x0f
    3aa6:	98 8b       	std	Y+16, r25	; 0x10
          prep.exit_speed = sqrt(exit_speed_sqr);
    3aa8:	0e 94 d9 3f 	call	0x7fb2	; 0x7fb2 <sqrt>
    3aac:	60 93 27 03 	sts	0x0327, r22	; 0x800327 <prep+0x1f>
    3ab0:	70 93 28 03 	sts	0x0328, r23	; 0x800328 <prep+0x20>
    3ab4:	80 93 29 03 	sts	0x0329, r24	; 0x800329 <prep+0x21>
    3ab8:	90 93 2a 03 	sts	0x032A, r25	; 0x80032a <prep+0x22>
        }

        nominal_speed = plan_compute_profile_nominal_speed(pl_block);
    3abc:	80 91 3b 03 	lds	r24, 0x033B	; 0x80033b <pl_block>
    3ac0:	90 91 3c 03 	lds	r25, 0x033C	; 0x80033c <pl_block+0x1>
    3ac4:	0e 94 f3 28 	call	0x51e6	; 0x51e6 <plan_compute_profile_nominal_speed>
    3ac8:	6b 01       	movw	r12, r22
    3aca:	7c 01       	movw	r14, r24
				float nominal_speed_sqr = nominal_speed*nominal_speed;
    3acc:	9b 01       	movw	r18, r22
    3ace:	ac 01       	movw	r20, r24
    3ad0:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
    3ad4:	6d 83       	std	Y+5, r22	; 0x05
    3ad6:	7e 83       	std	Y+6, r23	; 0x06
    3ad8:	8f 83       	std	Y+7, r24	; 0x07
    3ada:	98 87       	std	Y+8, r25	; 0x08
				float intersect_distance =
								0.5*(pl_block->millimeters+inv_2_accel*(pl_block->entry_speed_sqr-exit_speed_sqr));
    3adc:	00 91 3b 03 	lds	r16, 0x033B	; 0x80033b <pl_block>
    3ae0:	10 91 3c 03 	lds	r17, 0x033C	; 0x80033c <pl_block+0x1>
    3ae4:	f8 01       	movw	r30, r16
    3ae6:	82 a0       	ldd	r8, Z+34	; 0x22
    3ae8:	93 a0       	ldd	r9, Z+35	; 0x23
    3aea:	a4 a0       	ldd	r10, Z+36	; 0x24
    3aec:	b5 a0       	ldd	r11, Z+37	; 0x25
    3aee:	46 88       	ldd	r4, Z+22	; 0x16
    3af0:	57 88       	ldd	r5, Z+23	; 0x17
    3af2:	60 8c       	ldd	r6, Z+24	; 0x18
    3af4:	71 8c       	ldd	r7, Z+25	; 0x19
    3af6:	2d 85       	ldd	r18, Y+13	; 0x0d
    3af8:	3e 85       	ldd	r19, Y+14	; 0x0e
    3afa:	4f 85       	ldd	r20, Y+15	; 0x0f
    3afc:	58 89       	ldd	r21, Y+16	; 0x10
    3afe:	c3 01       	movw	r24, r6
    3b00:	b2 01       	movw	r22, r4
    3b02:	0e 94 34 3c 	call	0x7868	; 0x7868 <__subsf3>
    3b06:	9b 01       	movw	r18, r22
    3b08:	ac 01       	movw	r20, r24
    3b0a:	69 81       	ldd	r22, Y+1	; 0x01
    3b0c:	7a 81       	ldd	r23, Y+2	; 0x02
    3b0e:	8b 81       	ldd	r24, Y+3	; 0x03
    3b10:	9c 81       	ldd	r25, Y+4	; 0x04
    3b12:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
    3b16:	9b 01       	movw	r18, r22
    3b18:	ac 01       	movw	r20, r24
    3b1a:	c5 01       	movw	r24, r10
    3b1c:	b4 01       	movw	r22, r8
    3b1e:	0e 94 35 3c 	call	0x786a	; 0x786a <__addsf3>
          prep.exit_speed = sqrt(exit_speed_sqr);
        }

        nominal_speed = plan_compute_profile_nominal_speed(pl_block);
				float nominal_speed_sqr = nominal_speed*nominal_speed;
				float intersect_distance =
    3b22:	20 e0       	ldi	r18, 0x00	; 0
    3b24:	30 e0       	ldi	r19, 0x00	; 0
    3b26:	40 e0       	ldi	r20, 0x00	; 0
    3b28:	5f e3       	ldi	r21, 0x3F	; 63
    3b2a:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
    3b2e:	69 87       	std	Y+9, r22	; 0x09
    3b30:	7a 87       	std	Y+10, r23	; 0x0a
    3b32:	8b 87       	std	Y+11, r24	; 0x0b
    3b34:	9c 87       	std	Y+12, r25	; 0x0c
								0.5*(pl_block->millimeters+inv_2_accel*(pl_block->entry_speed_sqr-exit_speed_sqr));

        if (pl_block->entry_speed_sqr > nominal_speed_sqr) { // Only occurs during override reductions.
    3b36:	a3 01       	movw	r20, r6
    3b38:	92 01       	movw	r18, r4
    3b3a:	6d 81       	ldd	r22, Y+5	; 0x05
    3b3c:	7e 81       	ldd	r23, Y+6	; 0x06
    3b3e:	8f 81       	ldd	r24, Y+7	; 0x07
    3b40:	98 85       	ldd	r25, Y+8	; 0x08
    3b42:	0e 94 0e 3d 	call	0x7a1c	; 0x7a1c <__cmpsf2>
    3b46:	88 23       	and	r24, r24
    3b48:	0c f0       	brlt	.+2      	; 0x3b4c <st_prep_buffer+0x440>
    3b4a:	75 c0       	rjmp	.+234    	; 0x3c36 <st_prep_buffer+0x52a>
          prep.accelerate_until = pl_block->millimeters - inv_2_accel*(pl_block->entry_speed_sqr-nominal_speed_sqr);
    3b4c:	2d 81       	ldd	r18, Y+5	; 0x05
    3b4e:	3e 81       	ldd	r19, Y+6	; 0x06
    3b50:	4f 81       	ldd	r20, Y+7	; 0x07
    3b52:	58 85       	ldd	r21, Y+8	; 0x08
    3b54:	c3 01       	movw	r24, r6
    3b56:	b2 01       	movw	r22, r4
    3b58:	0e 94 34 3c 	call	0x7868	; 0x7868 <__subsf3>
    3b5c:	9b 01       	movw	r18, r22
    3b5e:	ac 01       	movw	r20, r24
    3b60:	69 81       	ldd	r22, Y+1	; 0x01
    3b62:	7a 81       	ldd	r23, Y+2	; 0x02
    3b64:	8b 81       	ldd	r24, Y+3	; 0x03
    3b66:	9c 81       	ldd	r25, Y+4	; 0x04
    3b68:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
    3b6c:	9b 01       	movw	r18, r22
    3b6e:	ac 01       	movw	r20, r24
    3b70:	c5 01       	movw	r24, r10
    3b72:	b4 01       	movw	r22, r8
    3b74:	0e 94 34 3c 	call	0x7868	; 0x7868 <__subsf3>
    3b78:	60 93 2b 03 	sts	0x032B, r22	; 0x80032b <prep+0x23>
    3b7c:	70 93 2c 03 	sts	0x032C, r23	; 0x80032c <prep+0x24>
    3b80:	80 93 2d 03 	sts	0x032D, r24	; 0x80032d <prep+0x25>
    3b84:	90 93 2e 03 	sts	0x032E, r25	; 0x80032e <prep+0x26>
          if (prep.accelerate_until <= 0.0) { // Deceleration-only.
    3b88:	20 e0       	ldi	r18, 0x00	; 0
    3b8a:	30 e0       	ldi	r19, 0x00	; 0
    3b8c:	a9 01       	movw	r20, r18
    3b8e:	0e 94 0e 3d 	call	0x7a1c	; 0x7a1c <__cmpsf2>
    3b92:	18 16       	cp	r1, r24
    3b94:	8c f1       	brlt	.+98     	; 0x3bf8 <st_prep_buffer+0x4ec>
            prep.ramp_type = RAMP_DECEL;
    3b96:	82 e0       	ldi	r24, 0x02	; 2
    3b98:	80 93 1a 03 	sts	0x031A, r24	; 0x80031a <prep+0x12>
            // prep.decelerate_after = pl_block->millimeters;
            // prep.maximum_speed = prep.current_speed;

            // Compute override block exit speed since it doesn't match the planner exit speed.
            prep.exit_speed = sqrt(pl_block->entry_speed_sqr - 2*pl_block->acceleration*pl_block->millimeters);
    3b9c:	d8 01       	movw	r26, r16
    3b9e:	56 96       	adiw	r26, 0x16	; 22
    3ba0:	cd 90       	ld	r12, X+
    3ba2:	dd 90       	ld	r13, X+
    3ba4:	ed 90       	ld	r14, X+
    3ba6:	fc 90       	ld	r15, X
    3ba8:	59 97       	sbiw	r26, 0x19	; 25
    3baa:	5e 96       	adiw	r26, 0x1e	; 30
    3bac:	6d 91       	ld	r22, X+
    3bae:	7d 91       	ld	r23, X+
    3bb0:	8d 91       	ld	r24, X+
    3bb2:	9c 91       	ld	r25, X
    3bb4:	91 97       	sbiw	r26, 0x21	; 33
    3bb6:	9b 01       	movw	r18, r22
    3bb8:	ac 01       	movw	r20, r24
    3bba:	0e 94 35 3c 	call	0x786a	; 0x786a <__addsf3>
    3bbe:	f8 01       	movw	r30, r16
    3bc0:	22 a1       	ldd	r18, Z+34	; 0x22
    3bc2:	33 a1       	ldd	r19, Z+35	; 0x23
    3bc4:	44 a1       	ldd	r20, Z+36	; 0x24
    3bc6:	55 a1       	ldd	r21, Z+37	; 0x25
    3bc8:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
    3bcc:	9b 01       	movw	r18, r22
    3bce:	ac 01       	movw	r20, r24
    3bd0:	c7 01       	movw	r24, r14
    3bd2:	b6 01       	movw	r22, r12
    3bd4:	0e 94 34 3c 	call	0x7868	; 0x7868 <__subsf3>
    3bd8:	0e 94 d9 3f 	call	0x7fb2	; 0x7fb2 <sqrt>
    3bdc:	60 93 27 03 	sts	0x0327, r22	; 0x800327 <prep+0x1f>
    3be0:	70 93 28 03 	sts	0x0328, r23	; 0x800328 <prep+0x20>
    3be4:	80 93 29 03 	sts	0x0329, r24	; 0x800329 <prep+0x21>
    3be8:	90 93 2a 03 	sts	0x032A, r25	; 0x80032a <prep+0x22>
            prep.recalculate_flag |= PREP_FLAG_DECEL_OVERRIDE; // Flag to load next block as deceleration override.
    3bec:	80 91 09 03 	lds	r24, 0x0309	; 0x800309 <prep+0x1>
    3bf0:	88 60       	ori	r24, 0x08	; 8
    3bf2:	80 93 09 03 	sts	0x0309, r24	; 0x800309 <prep+0x1>
    3bf6:	eb c0       	rjmp	.+470    	; 0x3dce <st_prep_buffer+0x6c2>
            // Can be tricky since entry speed will be current speed, as in feed holds.
            // Also, look into near-zero speed handling issues with this.

          } else {
            // Decelerate to cruise or cruise-decelerate types. Guaranteed to intersect updated plan.
            prep.decelerate_after = inv_2_accel*(nominal_speed_sqr-exit_speed_sqr);
    3bf8:	2d 85       	ldd	r18, Y+13	; 0x0d
    3bfa:	3e 85       	ldd	r19, Y+14	; 0x0e
    3bfc:	4f 85       	ldd	r20, Y+15	; 0x0f
    3bfe:	58 89       	ldd	r21, Y+16	; 0x10
    3c00:	6d 81       	ldd	r22, Y+5	; 0x05
    3c02:	7e 81       	ldd	r23, Y+6	; 0x06
    3c04:	8f 81       	ldd	r24, Y+7	; 0x07
    3c06:	98 85       	ldd	r25, Y+8	; 0x08
    3c08:	0e 94 34 3c 	call	0x7868	; 0x7868 <__subsf3>
    3c0c:	9b 01       	movw	r18, r22
    3c0e:	ac 01       	movw	r20, r24
    3c10:	69 81       	ldd	r22, Y+1	; 0x01
    3c12:	7a 81       	ldd	r23, Y+2	; 0x02
    3c14:	8b 81       	ldd	r24, Y+3	; 0x03
    3c16:	9c 81       	ldd	r25, Y+4	; 0x04
    3c18:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
    3c1c:	e8 e0       	ldi	r30, 0x08	; 8
    3c1e:	f3 e0       	ldi	r31, 0x03	; 3
    3c20:	67 a3       	std	Z+39, r22	; 0x27
    3c22:	70 a7       	std	Z+40, r23	; 0x28
    3c24:	81 a7       	std	Z+41, r24	; 0x29
    3c26:	92 a7       	std	Z+42, r25	; 0x2a
            prep.maximum_speed = nominal_speed;
    3c28:	c3 8e       	std	Z+27, r12	; 0x1b
    3c2a:	d4 8e       	std	Z+28, r13	; 0x1c
    3c2c:	e5 8e       	std	Z+29, r14	; 0x1d
    3c2e:	f6 8e       	std	Z+30, r15	; 0x1e
            prep.ramp_type = RAMP_DECEL_OVERRIDE;
    3c30:	83 e0       	ldi	r24, 0x03	; 3
    3c32:	82 8b       	std	Z+18, r24	; 0x12
    3c34:	cc c0       	rjmp	.+408    	; 0x3dce <st_prep_buffer+0x6c2>
          }
				} else if (intersect_distance > 0.0) {
    3c36:	20 e0       	ldi	r18, 0x00	; 0
    3c38:	30 e0       	ldi	r19, 0x00	; 0
    3c3a:	a9 01       	movw	r20, r18
    3c3c:	69 85       	ldd	r22, Y+9	; 0x09
    3c3e:	7a 85       	ldd	r23, Y+10	; 0x0a
    3c40:	8b 85       	ldd	r24, Y+11	; 0x0b
    3c42:	9c 85       	ldd	r25, Y+12	; 0x0c
    3c44:	0e 94 11 3f 	call	0x7e22	; 0x7e22 <__gesf2>
    3c48:	18 16       	cp	r1, r24
    3c4a:	0c f0       	brlt	.+2      	; 0x3c4e <st_prep_buffer+0x542>
    3c4c:	b2 c0       	rjmp	.+356    	; 0x3db2 <st_prep_buffer+0x6a6>
					if (intersect_distance < pl_block->millimeters) { // Either trapezoid or triangle types
    3c4e:	29 85       	ldd	r18, Y+9	; 0x09
    3c50:	3a 85       	ldd	r19, Y+10	; 0x0a
    3c52:	4b 85       	ldd	r20, Y+11	; 0x0b
    3c54:	5c 85       	ldd	r21, Y+12	; 0x0c
    3c56:	c5 01       	movw	r24, r10
    3c58:	b4 01       	movw	r22, r8
    3c5a:	0e 94 11 3f 	call	0x7e22	; 0x7e22 <__gesf2>
    3c5e:	18 16       	cp	r1, r24
    3c60:	0c f0       	brlt	.+2      	; 0x3c64 <st_prep_buffer+0x558>
    3c62:	a3 c0       	rjmp	.+326    	; 0x3daa <st_prep_buffer+0x69e>
						// NOTE: For acceleration-cruise and cruise-only types, following calculation will be 0.0.
						prep.decelerate_after = inv_2_accel*(nominal_speed_sqr-exit_speed_sqr);
    3c64:	2d 85       	ldd	r18, Y+13	; 0x0d
    3c66:	3e 85       	ldd	r19, Y+14	; 0x0e
    3c68:	4f 85       	ldd	r20, Y+15	; 0x0f
    3c6a:	58 89       	ldd	r21, Y+16	; 0x10
    3c6c:	6d 81       	ldd	r22, Y+5	; 0x05
    3c6e:	7e 81       	ldd	r23, Y+6	; 0x06
    3c70:	8f 81       	ldd	r24, Y+7	; 0x07
    3c72:	98 85       	ldd	r25, Y+8	; 0x08
    3c74:	0e 94 34 3c 	call	0x7868	; 0x7868 <__subsf3>
    3c78:	9b 01       	movw	r18, r22
    3c7a:	ac 01       	movw	r20, r24
    3c7c:	69 81       	ldd	r22, Y+1	; 0x01
    3c7e:	7a 81       	ldd	r23, Y+2	; 0x02
    3c80:	8b 81       	ldd	r24, Y+3	; 0x03
    3c82:	9c 81       	ldd	r25, Y+4	; 0x04
    3c84:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
    3c88:	9b 01       	movw	r18, r22
    3c8a:	ac 01       	movw	r20, r24
    3c8c:	60 93 2f 03 	sts	0x032F, r22	; 0x80032f <prep+0x27>
    3c90:	70 93 30 03 	sts	0x0330, r23	; 0x800330 <prep+0x28>
    3c94:	80 93 31 03 	sts	0x0331, r24	; 0x800331 <prep+0x29>
    3c98:	90 93 32 03 	sts	0x0332, r25	; 0x800332 <prep+0x2a>
						if (prep.decelerate_after < intersect_distance) { // Trapezoid type
    3c9c:	69 85       	ldd	r22, Y+9	; 0x09
    3c9e:	7a 85       	ldd	r23, Y+10	; 0x0a
    3ca0:	8b 85       	ldd	r24, Y+11	; 0x0b
    3ca2:	9c 85       	ldd	r25, Y+12	; 0x0c
    3ca4:	0e 94 11 3f 	call	0x7e22	; 0x7e22 <__gesf2>
    3ca8:	18 16       	cp	r1, r24
    3caa:	0c f0       	brlt	.+2      	; 0x3cae <st_prep_buffer+0x5a2>
    3cac:	42 c0       	rjmp	.+132    	; 0x3d32 <st_prep_buffer+0x626>
							prep.maximum_speed = nominal_speed;
    3cae:	c0 92 23 03 	sts	0x0323, r12	; 0x800323 <prep+0x1b>
    3cb2:	d0 92 24 03 	sts	0x0324, r13	; 0x800324 <prep+0x1c>
    3cb6:	e0 92 25 03 	sts	0x0325, r14	; 0x800325 <prep+0x1d>
    3cba:	f0 92 26 03 	sts	0x0326, r15	; 0x800326 <prep+0x1e>
							if (pl_block->entry_speed_sqr == nominal_speed_sqr) {
    3cbe:	d8 01       	movw	r26, r16
    3cc0:	56 96       	adiw	r26, 0x16	; 22
    3cc2:	4d 90       	ld	r4, X+
    3cc4:	5d 90       	ld	r5, X+
    3cc6:	6d 90       	ld	r6, X+
    3cc8:	7c 90       	ld	r7, X
    3cca:	59 97       	sbiw	r26, 0x19	; 25
    3ccc:	a3 01       	movw	r20, r6
    3cce:	92 01       	movw	r18, r4
    3cd0:	6d 81       	ldd	r22, Y+5	; 0x05
    3cd2:	7e 81       	ldd	r23, Y+6	; 0x06
    3cd4:	8f 81       	ldd	r24, Y+7	; 0x07
    3cd6:	98 85       	ldd	r25, Y+8	; 0x08
    3cd8:	0e 94 0e 3d 	call	0x7a1c	; 0x7a1c <__cmpsf2>
    3cdc:	81 11       	cpse	r24, r1
    3cde:	04 c0       	rjmp	.+8      	; 0x3ce8 <st_prep_buffer+0x5dc>
								// Cruise-deceleration or cruise-only type.
								prep.ramp_type = RAMP_CRUISE;
    3ce0:	81 e0       	ldi	r24, 0x01	; 1
    3ce2:	80 93 1a 03 	sts	0x031A, r24	; 0x80031a <prep+0x12>
    3ce6:	73 c0       	rjmp	.+230    	; 0x3dce <st_prep_buffer+0x6c2>
							} else {
								// Full-trapezoid or acceleration-cruise types
								prep.accelerate_until -= inv_2_accel*(nominal_speed_sqr-pl_block->entry_speed_sqr);
    3ce8:	a3 01       	movw	r20, r6
    3cea:	92 01       	movw	r18, r4
    3cec:	6d 81       	ldd	r22, Y+5	; 0x05
    3cee:	7e 81       	ldd	r23, Y+6	; 0x06
    3cf0:	8f 81       	ldd	r24, Y+7	; 0x07
    3cf2:	98 85       	ldd	r25, Y+8	; 0x08
    3cf4:	0e 94 34 3c 	call	0x7868	; 0x7868 <__subsf3>
    3cf8:	9b 01       	movw	r18, r22
    3cfa:	ac 01       	movw	r20, r24
    3cfc:	69 81       	ldd	r22, Y+1	; 0x01
    3cfe:	7a 81       	ldd	r23, Y+2	; 0x02
    3d00:	8b 81       	ldd	r24, Y+3	; 0x03
    3d02:	9c 81       	ldd	r25, Y+4	; 0x04
    3d04:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
    3d08:	9b 01       	movw	r18, r22
    3d0a:	ac 01       	movw	r20, r24
    3d0c:	60 91 2b 03 	lds	r22, 0x032B	; 0x80032b <prep+0x23>
    3d10:	70 91 2c 03 	lds	r23, 0x032C	; 0x80032c <prep+0x24>
    3d14:	80 91 2d 03 	lds	r24, 0x032D	; 0x80032d <prep+0x25>
    3d18:	90 91 2e 03 	lds	r25, 0x032E	; 0x80032e <prep+0x26>
    3d1c:	0e 94 34 3c 	call	0x7868	; 0x7868 <__subsf3>
    3d20:	60 93 2b 03 	sts	0x032B, r22	; 0x80032b <prep+0x23>
    3d24:	70 93 2c 03 	sts	0x032C, r23	; 0x80032c <prep+0x24>
    3d28:	80 93 2d 03 	sts	0x032D, r24	; 0x80032d <prep+0x25>
    3d2c:	90 93 2e 03 	sts	0x032E, r25	; 0x80032e <prep+0x26>
    3d30:	4e c0       	rjmp	.+156    	; 0x3dce <st_prep_buffer+0x6c2>
							}
						} else { // Triangle type
							prep.accelerate_until = intersect_distance;
    3d32:	89 85       	ldd	r24, Y+9	; 0x09
    3d34:	9a 85       	ldd	r25, Y+10	; 0x0a
    3d36:	ab 85       	ldd	r26, Y+11	; 0x0b
    3d38:	bc 85       	ldd	r27, Y+12	; 0x0c
    3d3a:	80 93 2b 03 	sts	0x032B, r24	; 0x80032b <prep+0x23>
    3d3e:	90 93 2c 03 	sts	0x032C, r25	; 0x80032c <prep+0x24>
    3d42:	a0 93 2d 03 	sts	0x032D, r26	; 0x80032d <prep+0x25>
    3d46:	b0 93 2e 03 	sts	0x032E, r27	; 0x80032e <prep+0x26>
							prep.decelerate_after = intersect_distance;
    3d4a:	80 93 2f 03 	sts	0x032F, r24	; 0x80032f <prep+0x27>
    3d4e:	90 93 30 03 	sts	0x0330, r25	; 0x800330 <prep+0x28>
    3d52:	a0 93 31 03 	sts	0x0331, r26	; 0x800331 <prep+0x29>
    3d56:	b0 93 32 03 	sts	0x0332, r27	; 0x800332 <prep+0x2a>
							prep.maximum_speed = sqrt(2.0*pl_block->acceleration*intersect_distance+exit_speed_sqr);
    3d5a:	d8 01       	movw	r26, r16
    3d5c:	5e 96       	adiw	r26, 0x1e	; 30
    3d5e:	6d 91       	ld	r22, X+
    3d60:	7d 91       	ld	r23, X+
    3d62:	8d 91       	ld	r24, X+
    3d64:	9c 91       	ld	r25, X
    3d66:	91 97       	sbiw	r26, 0x21	; 33
    3d68:	9b 01       	movw	r18, r22
    3d6a:	ac 01       	movw	r20, r24
    3d6c:	0e 94 35 3c 	call	0x786a	; 0x786a <__addsf3>
    3d70:	9b 01       	movw	r18, r22
    3d72:	ac 01       	movw	r20, r24
    3d74:	69 85       	ldd	r22, Y+9	; 0x09
    3d76:	7a 85       	ldd	r23, Y+10	; 0x0a
    3d78:	8b 85       	ldd	r24, Y+11	; 0x0b
    3d7a:	9c 85       	ldd	r25, Y+12	; 0x0c
    3d7c:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
    3d80:	6b 01       	movw	r12, r22
    3d82:	7c 01       	movw	r14, r24
    3d84:	a7 01       	movw	r20, r14
    3d86:	96 01       	movw	r18, r12
    3d88:	6d 85       	ldd	r22, Y+13	; 0x0d
    3d8a:	7e 85       	ldd	r23, Y+14	; 0x0e
    3d8c:	8f 85       	ldd	r24, Y+15	; 0x0f
    3d8e:	98 89       	ldd	r25, Y+16	; 0x10
    3d90:	0e 94 35 3c 	call	0x786a	; 0x786a <__addsf3>
    3d94:	0e 94 d9 3f 	call	0x7fb2	; 0x7fb2 <sqrt>
    3d98:	60 93 23 03 	sts	0x0323, r22	; 0x800323 <prep+0x1b>
    3d9c:	70 93 24 03 	sts	0x0324, r23	; 0x800324 <prep+0x1c>
    3da0:	80 93 25 03 	sts	0x0325, r24	; 0x800325 <prep+0x1d>
    3da4:	90 93 26 03 	sts	0x0326, r25	; 0x800326 <prep+0x1e>
    3da8:	12 c0       	rjmp	.+36     	; 0x3dce <st_prep_buffer+0x6c2>
						}
					} else { // Deceleration-only type
            prep.ramp_type = RAMP_DECEL;
    3daa:	82 e0       	ldi	r24, 0x02	; 2
    3dac:	80 93 1a 03 	sts	0x031A, r24	; 0x80031a <prep+0x12>
    3db0:	0e c0       	rjmp	.+28     	; 0x3dce <st_prep_buffer+0x6c2>
            // prep.decelerate_after = pl_block->millimeters;
            // prep.maximum_speed = prep.current_speed;
					}
				} else { // Acceleration-only type
					prep.accelerate_until = 0.0;
    3db2:	e8 e0       	ldi	r30, 0x08	; 8
    3db4:	f3 e0       	ldi	r31, 0x03	; 3
    3db6:	13 a2       	std	Z+35, r1	; 0x23
    3db8:	14 a2       	std	Z+36, r1	; 0x24
    3dba:	15 a2       	std	Z+37, r1	; 0x25
    3dbc:	16 a2       	std	Z+38, r1	; 0x26
					// prep.decelerate_after = 0.0;
					prep.maximum_speed = prep.exit_speed;
    3dbe:	87 8d       	ldd	r24, Z+31	; 0x1f
    3dc0:	90 a1       	ldd	r25, Z+32	; 0x20
    3dc2:	a1 a1       	ldd	r26, Z+33	; 0x21
    3dc4:	b2 a1       	ldd	r27, Z+34	; 0x22
    3dc6:	83 8f       	std	Z+27, r24	; 0x1b
    3dc8:	94 8f       	std	Z+28, r25	; 0x1c
    3dca:	a5 8f       	std	Z+29, r26	; 0x1d
    3dcc:	b6 8f       	std	Z+30, r27	; 0x1e
				}
			}
      
      bit_true(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM); // Force update whenever updating block.
    3dce:	e1 e1       	ldi	r30, 0x11	; 17
    3dd0:	fc e0       	ldi	r31, 0x0C	; 12
    3dd2:	84 81       	ldd	r24, Z+4	; 0x04
    3dd4:	88 60       	ori	r24, 0x08	; 8
    3dd6:	84 83       	std	Z+4, r24	; 0x04
    }
    
    // Initialize new segment
    segment_t *prep_segment = &segment_buffer[segment_buffer_head];
    3dd8:	e0 91 41 03 	lds	r30, 0x0341	; 0x800341 <segment_buffer_head>
    3ddc:	8e 2f       	mov	r24, r30
    3dde:	90 e0       	ldi	r25, 0x00	; 0
    3de0:	9e 8f       	std	Y+30, r25	; 0x1e
    3de2:	8d 8f       	std	Y+29, r24	; 0x1d

    // Set new segment to point to the current segment data block.
    prep_segment->st_block_index = prep.st_block_index;
    3de4:	a8 e0       	ldi	r26, 0x08	; 8
    3de6:	b3 e0       	ldi	r27, 0x03	; 3
    3de8:	8c 91       	ld	r24, X
    3dea:	ed 8d       	ldd	r30, Y+29	; 0x1d
    3dec:	fe 8d       	ldd	r31, Y+30	; 0x1e
    3dee:	ee 0f       	add	r30, r30
    3df0:	ff 1f       	adc	r31, r31
    3df2:	ee 0f       	add	r30, r30
    3df4:	ff 1f       	adc	r31, r31
    3df6:	ee 0f       	add	r30, r30
    3df8:	ff 1f       	adc	r31, r31
    3dfa:	ea 59       	subi	r30, 0x9A	; 154
    3dfc:	fc 4f       	sbci	r31, 0xFC	; 252
    3dfe:	84 83       	std	Z+4, r24	; 0x04
    float dt_max = DT_SEGMENT; // Maximum segment time
    float dt = 0.0; // Initialize segment time
    float time_var = dt_max; // Time worker variable
    float mm_var; // mm-Distance worker variable
    float speed_var; // Speed worker variable
    float mm_remaining = pl_block->millimeters; // New segment distance from end of block.
    3e00:	e0 91 3b 03 	lds	r30, 0x033B	; 0x80033b <pl_block>
    3e04:	f0 91 3c 03 	lds	r31, 0x033C	; 0x80033c <pl_block+0x1>
    3e08:	fe 87       	std	Y+14, r31	; 0x0e
    3e0a:	ed 87       	std	Y+13, r30	; 0x0d
    3e0c:	f2 a1       	ldd	r31, Z+34	; 0x22
    3e0e:	f9 8f       	std	Y+25, r31	; 0x19
    3e10:	ed 85       	ldd	r30, Y+13	; 0x0d
    3e12:	fe 85       	ldd	r31, Y+14	; 0x0e
    3e14:	f3 a1       	ldd	r31, Z+35	; 0x23
    3e16:	fa 8f       	std	Y+26, r31	; 0x1a
    3e18:	ed 85       	ldd	r30, Y+13	; 0x0d
    3e1a:	fe 85       	ldd	r31, Y+14	; 0x0e
    3e1c:	f4 a1       	ldd	r31, Z+36	; 0x24
    3e1e:	fb 8f       	std	Y+27, r31	; 0x1b
    3e20:	ed 85       	ldd	r30, Y+13	; 0x0d
    3e22:	fe 85       	ldd	r31, Y+14	; 0x0e
    3e24:	f5 a1       	ldd	r31, Z+37	; 0x25
    3e26:	fc 8f       	std	Y+28, r31	; 0x1c
    float minimum_mm = mm_remaining-prep.req_mm_increment; // Guarantee at least one step.
    3e28:	1e 96       	adiw	r26, 0x0e	; 14
    3e2a:	2d 91       	ld	r18, X+
    3e2c:	3d 91       	ld	r19, X+
    3e2e:	4d 91       	ld	r20, X+
    3e30:	5c 91       	ld	r21, X
    3e32:	51 97       	sbiw	r26, 0x11	; 17
    3e34:	69 8d       	ldd	r22, Y+25	; 0x19
    3e36:	7a 8d       	ldd	r23, Y+26	; 0x1a
    3e38:	8b 8d       	ldd	r24, Y+27	; 0x1b
    3e3a:	9f 2f       	mov	r25, r31
    3e3c:	0e 94 34 3c 	call	0x7868	; 0x7868 <__subsf3>
    3e40:	6d 8b       	std	Y+21, r22	; 0x15
    3e42:	7e 8b       	std	Y+22, r23	; 0x16
    3e44:	8f 8b       	std	Y+23, r24	; 0x17
    3e46:	98 8f       	std	Y+24, r25	; 0x18
    if (minimum_mm < 0.0) { minimum_mm = 0.0; }
    3e48:	20 e0       	ldi	r18, 0x00	; 0
    3e4a:	30 e0       	ldi	r19, 0x00	; 0
    3e4c:	a9 01       	movw	r20, r18
    3e4e:	0e 94 0e 3d 	call	0x7a1c	; 0x7a1c <__cmpsf2>
    3e52:	88 23       	and	r24, r24
    3e54:	24 f4       	brge	.+8      	; 0x3e5e <st_prep_buffer+0x752>
    3e56:	1d 8a       	std	Y+21, r1	; 0x15
    3e58:	1e 8a       	std	Y+22, r1	; 0x16
    3e5a:	1f 8a       	std	Y+23, r1	; 0x17
    3e5c:	18 8e       	std	Y+24, r1	; 0x18
    3e5e:	a9 8c       	ldd	r10, Y+25	; 0x19
    3e60:	ba 8c       	ldd	r11, Y+26	; 0x1a
    3e62:	2b 8c       	ldd	r2, Y+27	; 0x1b
    3e64:	3c 8c       	ldd	r3, Y+28	; 0x1c
    3e66:	8e e3       	ldi	r24, 0x3E	; 62
    3e68:	93 ec       	ldi	r25, 0xC3	; 195
    3e6a:	ae e2       	ldi	r26, 0x2E	; 46
    3e6c:	b9 e3       	ldi	r27, 0x39	; 57
    3e6e:	89 87       	std	Y+9, r24	; 0x09
    3e70:	9a 87       	std	Y+10, r25	; 0x0a
    3e72:	ab 87       	std	Y+11, r26	; 0x0b
    3e74:	bc 87       	std	Y+12, r27	; 0x0c
    3e76:	19 82       	std	Y+1, r1	; 0x01
    3e78:	1a 82       	std	Y+2, r1	; 0x02
    3e7a:	1b 82       	std	Y+3, r1	; 0x03
    3e7c:	1c 82       	std	Y+4, r1	; 0x04
    3e7e:	8d 83       	std	Y+5, r24	; 0x05
    3e80:	9e 83       	std	Y+6, r25	; 0x06
    3e82:	af 83       	std	Y+7, r26	; 0x07
    3e84:	b8 87       	std	Y+8, r27	; 0x08
    3e86:	0f 2e       	mov	r0, r31
    3e88:	fe e3       	ldi	r31, 0x3E	; 62
    3e8a:	cf 2e       	mov	r12, r31
    3e8c:	f3 ec       	ldi	r31, 0xC3	; 195
    3e8e:	df 2e       	mov	r13, r31
    3e90:	fe e2       	ldi	r31, 0x2E	; 46
    3e92:	ef 2e       	mov	r14, r31
    3e94:	f9 e3       	ldi	r31, 0x39	; 57
    3e96:	ff 2e       	mov	r15, r31
    3e98:	f0 2d       	mov	r31, r0
    3e9a:	7a 2c       	mov	r7, r10
    3e9c:	6b 2c       	mov	r6, r11
    3e9e:	52 2c       	mov	r5, r2
    3ea0:	43 2c       	mov	r4, r3

    do {
      switch (prep.ramp_type) {
    3ea2:	80 91 1a 03 	lds	r24, 0x031A	; 0x80031a <prep+0x12>
    3ea6:	81 30       	cpi	r24, 0x01	; 1
    3ea8:	09 f4       	brne	.+2      	; 0x3eac <st_prep_buffer+0x7a0>
    3eaa:	48 c1       	rjmp	.+656    	; 0x413c <st_prep_buffer+0xa30>
    3eac:	08 f4       	brcc	.+2      	; 0x3eb0 <st_prep_buffer+0x7a4>
    3eae:	9c c0       	rjmp	.+312    	; 0x3fe8 <st_prep_buffer+0x8dc>
    3eb0:	83 30       	cpi	r24, 0x03	; 3
    3eb2:	09 f0       	breq	.+2      	; 0x3eb6 <st_prep_buffer+0x7aa>
    3eb4:	8c c1       	rjmp	.+792    	; 0x41ce <st_prep_buffer+0xac2>
        case RAMP_DECEL_OVERRIDE:
          speed_var = pl_block->acceleration*time_var;
    3eb6:	ad 85       	ldd	r26, Y+13	; 0x0d
    3eb8:	be 85       	ldd	r27, Y+14	; 0x0e
    3eba:	5e 96       	adiw	r26, 0x1e	; 30
    3ebc:	2d 91       	ld	r18, X+
    3ebe:	3d 91       	ld	r19, X+
    3ec0:	4d 91       	ld	r20, X+
    3ec2:	5c 91       	ld	r21, X
    3ec4:	91 97       	sbiw	r26, 0x21	; 33
    3ec6:	c7 01       	movw	r24, r14
    3ec8:	b6 01       	movw	r22, r12
    3eca:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
    3ece:	69 8b       	std	Y+17, r22	; 0x11
    3ed0:	7a 8b       	std	Y+18, r23	; 0x12
    3ed2:	8b 8b       	std	Y+19, r24	; 0x13
    3ed4:	9c 8b       	std	Y+20, r25	; 0x14
          if (prep.current_speed-prep.maximum_speed <= speed_var) {
    3ed6:	e8 e0       	ldi	r30, 0x08	; 8
    3ed8:	f3 e0       	ldi	r31, 0x03	; 3
    3eda:	87 89       	ldd	r24, Z+23	; 0x17
    3edc:	90 8d       	ldd	r25, Z+24	; 0x18
    3ede:	a1 8d       	ldd	r26, Z+25	; 0x19
    3ee0:	b2 8d       	ldd	r27, Z+26	; 0x1a
    3ee2:	89 87       	std	Y+9, r24	; 0x09
    3ee4:	9a 87       	std	Y+10, r25	; 0x0a
    3ee6:	ab 87       	std	Y+11, r26	; 0x0b
    3ee8:	bc 87       	std	Y+12, r27	; 0x0c
    3eea:	83 8c       	ldd	r8, Z+27	; 0x1b
    3eec:	94 8c       	ldd	r9, Z+28	; 0x1c
    3eee:	a5 8c       	ldd	r10, Z+29	; 0x1d
    3ef0:	b6 8c       	ldd	r11, Z+30	; 0x1e
    3ef2:	a5 01       	movw	r20, r10
    3ef4:	94 01       	movw	r18, r8
    3ef6:	bc 01       	movw	r22, r24
    3ef8:	cd 01       	movw	r24, r26
    3efa:	0e 94 34 3c 	call	0x7868	; 0x7868 <__subsf3>
    3efe:	9b 01       	movw	r18, r22
    3f00:	ac 01       	movw	r20, r24
    3f02:	69 89       	ldd	r22, Y+17	; 0x11
    3f04:	7a 89       	ldd	r23, Y+18	; 0x12
    3f06:	8b 89       	ldd	r24, Y+19	; 0x13
    3f08:	9c 89       	ldd	r25, Y+20	; 0x14
    3f0a:	0e 94 11 3f 	call	0x7e22	; 0x7e22 <__gesf2>
    3f0e:	88 23       	and	r24, r24
    3f10:	a4 f1       	brlt	.+104    	; 0x3f7a <st_prep_buffer+0x86e>
            // Cruise or cruise-deceleration types only for deceleration override.
            mm_remaining = prep.accelerate_until;
    3f12:	70 90 2b 03 	lds	r7, 0x032B	; 0x80032b <prep+0x23>
    3f16:	60 90 2c 03 	lds	r6, 0x032C	; 0x80032c <prep+0x24>
    3f1a:	50 90 2d 03 	lds	r5, 0x032D	; 0x80032d <prep+0x25>
    3f1e:	40 90 2e 03 	lds	r4, 0x032E	; 0x80032e <prep+0x26>
            time_var = 2.0*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
    3f22:	27 2d       	mov	r18, r7
    3f24:	36 2d       	mov	r19, r6
    3f26:	45 2d       	mov	r20, r5
    3f28:	54 2d       	mov	r21, r4
    3f2a:	69 8d       	ldd	r22, Y+25	; 0x19
    3f2c:	7a 8d       	ldd	r23, Y+26	; 0x1a
    3f2e:	8b 8d       	ldd	r24, Y+27	; 0x1b
    3f30:	9c 8d       	ldd	r25, Y+28	; 0x1c
    3f32:	0e 94 34 3c 	call	0x7868	; 0x7868 <__subsf3>
    3f36:	9b 01       	movw	r18, r22
    3f38:	ac 01       	movw	r20, r24
    3f3a:	0e 94 35 3c 	call	0x786a	; 0x786a <__addsf3>
    3f3e:	6b 01       	movw	r12, r22
    3f40:	7c 01       	movw	r14, r24
    3f42:	a5 01       	movw	r20, r10
    3f44:	94 01       	movw	r18, r8
    3f46:	69 85       	ldd	r22, Y+9	; 0x09
    3f48:	7a 85       	ldd	r23, Y+10	; 0x0a
    3f4a:	8b 85       	ldd	r24, Y+11	; 0x0b
    3f4c:	9c 85       	ldd	r25, Y+12	; 0x0c
    3f4e:	0e 94 35 3c 	call	0x786a	; 0x786a <__addsf3>
    3f52:	9b 01       	movw	r18, r22
    3f54:	ac 01       	movw	r20, r24
    3f56:	c7 01       	movw	r24, r14
    3f58:	b6 01       	movw	r22, r12
    3f5a:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <__divsf3>
    3f5e:	6b 01       	movw	r12, r22
    3f60:	7c 01       	movw	r14, r24
            prep.ramp_type = RAMP_CRUISE;
    3f62:	81 e0       	ldi	r24, 0x01	; 1
    3f64:	80 93 1a 03 	sts	0x031A, r24	; 0x80031a <prep+0x12>
            prep.current_speed = prep.maximum_speed;
    3f68:	80 92 1f 03 	sts	0x031F, r8	; 0x80031f <prep+0x17>
    3f6c:	90 92 20 03 	sts	0x0320, r9	; 0x800320 <prep+0x18>
    3f70:	a0 92 21 03 	sts	0x0321, r10	; 0x800321 <prep+0x19>
    3f74:	b0 92 22 03 	sts	0x0322, r11	; 0x800322 <prep+0x1a>
    3f78:	d1 c1       	rjmp	.+930    	; 0x431c <st_prep_buffer+0xc10>
          } else { // Mid-deceleration override ramp.
            mm_remaining -= time_var*(prep.current_speed - 0.5*speed_var);
    3f7a:	20 e0       	ldi	r18, 0x00	; 0
    3f7c:	30 e0       	ldi	r19, 0x00	; 0
    3f7e:	40 e0       	ldi	r20, 0x00	; 0
    3f80:	5f e3       	ldi	r21, 0x3F	; 63
    3f82:	69 89       	ldd	r22, Y+17	; 0x11
    3f84:	7a 89       	ldd	r23, Y+18	; 0x12
    3f86:	8b 89       	ldd	r24, Y+19	; 0x13
    3f88:	9c 89       	ldd	r25, Y+20	; 0x14
    3f8a:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
    3f8e:	9b 01       	movw	r18, r22
    3f90:	ac 01       	movw	r20, r24
    3f92:	69 85       	ldd	r22, Y+9	; 0x09
    3f94:	7a 85       	ldd	r23, Y+10	; 0x0a
    3f96:	8b 85       	ldd	r24, Y+11	; 0x0b
    3f98:	9c 85       	ldd	r25, Y+12	; 0x0c
    3f9a:	0e 94 34 3c 	call	0x7868	; 0x7868 <__subsf3>
    3f9e:	9b 01       	movw	r18, r22
    3fa0:	ac 01       	movw	r20, r24
    3fa2:	c7 01       	movw	r24, r14
    3fa4:	b6 01       	movw	r22, r12
    3fa6:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
    3faa:	9b 01       	movw	r18, r22
    3fac:	ac 01       	movw	r20, r24
    3fae:	67 2d       	mov	r22, r7
    3fb0:	76 2d       	mov	r23, r6
    3fb2:	85 2d       	mov	r24, r5
    3fb4:	94 2d       	mov	r25, r4
    3fb6:	0e 94 34 3c 	call	0x7868	; 0x7868 <__subsf3>
    3fba:	76 2e       	mov	r7, r22
    3fbc:	67 2e       	mov	r6, r23
    3fbe:	58 2e       	mov	r5, r24
    3fc0:	49 2e       	mov	r4, r25
            prep.current_speed -= speed_var;
    3fc2:	29 89       	ldd	r18, Y+17	; 0x11
    3fc4:	3a 89       	ldd	r19, Y+18	; 0x12
    3fc6:	4b 89       	ldd	r20, Y+19	; 0x13
    3fc8:	5c 89       	ldd	r21, Y+20	; 0x14
    3fca:	69 85       	ldd	r22, Y+9	; 0x09
    3fcc:	7a 85       	ldd	r23, Y+10	; 0x0a
    3fce:	8b 85       	ldd	r24, Y+11	; 0x0b
    3fd0:	9c 85       	ldd	r25, Y+12	; 0x0c
    3fd2:	0e 94 34 3c 	call	0x7868	; 0x7868 <__subsf3>
    3fd6:	60 93 1f 03 	sts	0x031F, r22	; 0x80031f <prep+0x17>
    3fda:	70 93 20 03 	sts	0x0320, r23	; 0x800320 <prep+0x18>
    3fde:	80 93 21 03 	sts	0x0321, r24	; 0x800321 <prep+0x19>
    3fe2:	90 93 22 03 	sts	0x0322, r25	; 0x800322 <prep+0x1a>
    3fe6:	9a c1       	rjmp	.+820    	; 0x431c <st_prep_buffer+0xc10>
          }
          break;
        case RAMP_ACCEL:
          // NOTE: Acceleration ramp only computes during first do-while loop.
          speed_var = pl_block->acceleration*time_var;
    3fe8:	ad 85       	ldd	r26, Y+13	; 0x0d
    3fea:	be 85       	ldd	r27, Y+14	; 0x0e
    3fec:	5e 96       	adiw	r26, 0x1e	; 30
    3fee:	2d 91       	ld	r18, X+
    3ff0:	3d 91       	ld	r19, X+
    3ff2:	4d 91       	ld	r20, X+
    3ff4:	5c 91       	ld	r21, X
    3ff6:	91 97       	sbiw	r26, 0x21	; 33
    3ff8:	c7 01       	movw	r24, r14
    3ffa:	b6 01       	movw	r22, r12
    3ffc:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
    4000:	4b 01       	movw	r8, r22
    4002:	5c 01       	movw	r10, r24
          mm_remaining -= time_var*(prep.current_speed + 0.5*speed_var);
    4004:	80 91 1f 03 	lds	r24, 0x031F	; 0x80031f <prep+0x17>
    4008:	90 91 20 03 	lds	r25, 0x0320	; 0x800320 <prep+0x18>
    400c:	a0 91 21 03 	lds	r26, 0x0321	; 0x800321 <prep+0x19>
    4010:	b0 91 22 03 	lds	r27, 0x0322	; 0x800322 <prep+0x1a>
    4014:	89 87       	std	Y+9, r24	; 0x09
    4016:	9a 87       	std	Y+10, r25	; 0x0a
    4018:	ab 87       	std	Y+11, r26	; 0x0b
    401a:	bc 87       	std	Y+12, r27	; 0x0c
    401c:	20 e0       	ldi	r18, 0x00	; 0
    401e:	30 e0       	ldi	r19, 0x00	; 0
    4020:	40 e0       	ldi	r20, 0x00	; 0
    4022:	5f e3       	ldi	r21, 0x3F	; 63
    4024:	c5 01       	movw	r24, r10
    4026:	b4 01       	movw	r22, r8
    4028:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
    402c:	9b 01       	movw	r18, r22
    402e:	ac 01       	movw	r20, r24
    4030:	69 85       	ldd	r22, Y+9	; 0x09
    4032:	7a 85       	ldd	r23, Y+10	; 0x0a
    4034:	8b 85       	ldd	r24, Y+11	; 0x0b
    4036:	9c 85       	ldd	r25, Y+12	; 0x0c
    4038:	0e 94 35 3c 	call	0x786a	; 0x786a <__addsf3>
    403c:	9b 01       	movw	r18, r22
    403e:	ac 01       	movw	r20, r24
    4040:	c7 01       	movw	r24, r14
    4042:	b6 01       	movw	r22, r12
    4044:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
    4048:	9b 01       	movw	r18, r22
    404a:	ac 01       	movw	r20, r24
    404c:	67 2d       	mov	r22, r7
    404e:	76 2d       	mov	r23, r6
    4050:	85 2d       	mov	r24, r5
    4052:	94 2d       	mov	r25, r4
    4054:	0e 94 34 3c 	call	0x7868	; 0x7868 <__subsf3>
    4058:	76 2e       	mov	r7, r22
    405a:	67 2e       	mov	r6, r23
    405c:	58 2e       	mov	r5, r24
    405e:	49 2e       	mov	r4, r25
          if (mm_remaining < prep.accelerate_until) { // End of acceleration ramp.
    4060:	30 90 2b 03 	lds	r3, 0x032B	; 0x80032b <prep+0x23>
    4064:	20 90 2c 03 	lds	r2, 0x032C	; 0x80032c <prep+0x24>
    4068:	10 91 2d 03 	lds	r17, 0x032D	; 0x80032d <prep+0x25>
    406c:	00 91 2e 03 	lds	r16, 0x032E	; 0x80032e <prep+0x26>
    4070:	23 2d       	mov	r18, r3
    4072:	32 2d       	mov	r19, r2
    4074:	41 2f       	mov	r20, r17
    4076:	50 2f       	mov	r21, r16
    4078:	0e 94 0e 3d 	call	0x7a1c	; 0x7a1c <__cmpsf2>
    407c:	88 23       	and	r24, r24
    407e:	0c f0       	brlt	.+2      	; 0x4082 <st_prep_buffer+0x976>
    4080:	4c c0       	rjmp	.+152    	; 0x411a <st_prep_buffer+0xa0e>
            // Acceleration-cruise, acceleration-deceleration ramp junction, or end of block.
            mm_remaining = prep.accelerate_until; // NOTE: 0.0 at EOB
            time_var = 2.0*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
    4082:	23 2d       	mov	r18, r3
    4084:	32 2d       	mov	r19, r2
    4086:	41 2f       	mov	r20, r17
    4088:	50 2f       	mov	r21, r16
    408a:	69 8d       	ldd	r22, Y+25	; 0x19
    408c:	7a 8d       	ldd	r23, Y+26	; 0x1a
    408e:	8b 8d       	ldd	r24, Y+27	; 0x1b
    4090:	9c 8d       	ldd	r25, Y+28	; 0x1c
    4092:	0e 94 34 3c 	call	0x7868	; 0x7868 <__subsf3>
    4096:	9b 01       	movw	r18, r22
    4098:	ac 01       	movw	r20, r24
    409a:	0e 94 35 3c 	call	0x786a	; 0x786a <__addsf3>
    409e:	6b 01       	movw	r12, r22
    40a0:	7c 01       	movw	r14, r24
    40a2:	40 90 23 03 	lds	r4, 0x0323	; 0x800323 <prep+0x1b>
    40a6:	50 90 24 03 	lds	r5, 0x0324	; 0x800324 <prep+0x1c>
    40aa:	60 90 25 03 	lds	r6, 0x0325	; 0x800325 <prep+0x1d>
    40ae:	70 90 26 03 	lds	r7, 0x0326	; 0x800326 <prep+0x1e>
    40b2:	a3 01       	movw	r20, r6
    40b4:	92 01       	movw	r18, r4
    40b6:	69 85       	ldd	r22, Y+9	; 0x09
    40b8:	7a 85       	ldd	r23, Y+10	; 0x0a
    40ba:	8b 85       	ldd	r24, Y+11	; 0x0b
    40bc:	9c 85       	ldd	r25, Y+12	; 0x0c
    40be:	0e 94 35 3c 	call	0x786a	; 0x786a <__addsf3>
    40c2:	9b 01       	movw	r18, r22
    40c4:	ac 01       	movw	r20, r24
    40c6:	c7 01       	movw	r24, r14
    40c8:	b6 01       	movw	r22, r12
    40ca:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <__divsf3>
    40ce:	6b 01       	movw	r12, r22
    40d0:	7c 01       	movw	r14, r24
            if (mm_remaining == prep.decelerate_after) { prep.ramp_type = RAMP_DECEL; }
    40d2:	20 91 2f 03 	lds	r18, 0x032F	; 0x80032f <prep+0x27>
    40d6:	30 91 30 03 	lds	r19, 0x0330	; 0x800330 <prep+0x28>
    40da:	40 91 31 03 	lds	r20, 0x0331	; 0x800331 <prep+0x29>
    40de:	50 91 32 03 	lds	r21, 0x0332	; 0x800332 <prep+0x2a>
    40e2:	63 2d       	mov	r22, r3
    40e4:	72 2d       	mov	r23, r2
    40e6:	81 2f       	mov	r24, r17
    40e8:	90 2f       	mov	r25, r16
    40ea:	0e 94 0e 3d 	call	0x7a1c	; 0x7a1c <__cmpsf2>
    40ee:	81 11       	cpse	r24, r1
    40f0:	04 c0       	rjmp	.+8      	; 0x40fa <st_prep_buffer+0x9ee>
    40f2:	82 e0       	ldi	r24, 0x02	; 2
    40f4:	80 93 1a 03 	sts	0x031A, r24	; 0x80031a <prep+0x12>
    40f8:	03 c0       	rjmp	.+6      	; 0x4100 <st_prep_buffer+0x9f4>
            else { prep.ramp_type = RAMP_CRUISE; }
    40fa:	81 e0       	ldi	r24, 0x01	; 1
    40fc:	80 93 1a 03 	sts	0x031A, r24	; 0x80031a <prep+0x12>
            prep.current_speed = prep.maximum_speed;
    4100:	40 92 1f 03 	sts	0x031F, r4	; 0x80031f <prep+0x17>
    4104:	50 92 20 03 	sts	0x0320, r5	; 0x800320 <prep+0x18>
    4108:	60 92 21 03 	sts	0x0321, r6	; 0x800321 <prep+0x19>
    410c:	70 92 22 03 	sts	0x0322, r7	; 0x800322 <prep+0x1a>
          // NOTE: Acceleration ramp only computes during first do-while loop.
          speed_var = pl_block->acceleration*time_var;
          mm_remaining -= time_var*(prep.current_speed + 0.5*speed_var);
          if (mm_remaining < prep.accelerate_until) { // End of acceleration ramp.
            // Acceleration-cruise, acceleration-deceleration ramp junction, or end of block.
            mm_remaining = prep.accelerate_until; // NOTE: 0.0 at EOB
    4110:	73 2c       	mov	r7, r3
    4112:	62 2c       	mov	r6, r2
    4114:	51 2e       	mov	r5, r17
    4116:	40 2e       	mov	r4, r16
    4118:	01 c1       	rjmp	.+514    	; 0x431c <st_prep_buffer+0xc10>
            time_var = 2.0*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
            if (mm_remaining == prep.decelerate_after) { prep.ramp_type = RAMP_DECEL; }
            else { prep.ramp_type = RAMP_CRUISE; }
            prep.current_speed = prep.maximum_speed;
          } else { // Acceleration only.
            prep.current_speed += speed_var;
    411a:	29 85       	ldd	r18, Y+9	; 0x09
    411c:	3a 85       	ldd	r19, Y+10	; 0x0a
    411e:	4b 85       	ldd	r20, Y+11	; 0x0b
    4120:	5c 85       	ldd	r21, Y+12	; 0x0c
    4122:	c5 01       	movw	r24, r10
    4124:	b4 01       	movw	r22, r8
    4126:	0e 94 35 3c 	call	0x786a	; 0x786a <__addsf3>
    412a:	60 93 1f 03 	sts	0x031F, r22	; 0x80031f <prep+0x17>
    412e:	70 93 20 03 	sts	0x0320, r23	; 0x800320 <prep+0x18>
    4132:	80 93 21 03 	sts	0x0321, r24	; 0x800321 <prep+0x19>
    4136:	90 93 22 03 	sts	0x0322, r25	; 0x800322 <prep+0x1a>
    413a:	f0 c0       	rjmp	.+480    	; 0x431c <st_prep_buffer+0xc10>
          break;
        case RAMP_CRUISE:
          // NOTE: mm_var used to retain the last mm_remaining for incomplete segment time_var calculations.
          // NOTE: If maximum_speed*time_var value is too low, round-off can cause mm_var to not change. To
          //   prevent this, simply enforce a minimum speed threshold in the planner.
          mm_var = mm_remaining - prep.maximum_speed*time_var;
    413c:	80 91 23 03 	lds	r24, 0x0323	; 0x800323 <prep+0x1b>
    4140:	90 91 24 03 	lds	r25, 0x0324	; 0x800324 <prep+0x1c>
    4144:	a0 91 25 03 	lds	r26, 0x0325	; 0x800325 <prep+0x1d>
    4148:	b0 91 26 03 	lds	r27, 0x0326	; 0x800326 <prep+0x1e>
    414c:	89 87       	std	Y+9, r24	; 0x09
    414e:	9a 87       	std	Y+10, r25	; 0x0a
    4150:	ab 87       	std	Y+11, r26	; 0x0b
    4152:	bc 87       	std	Y+12, r27	; 0x0c
    4154:	9c 01       	movw	r18, r24
    4156:	ad 01       	movw	r20, r26
    4158:	c7 01       	movw	r24, r14
    415a:	b6 01       	movw	r22, r12
    415c:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
    4160:	9b 01       	movw	r18, r22
    4162:	ac 01       	movw	r20, r24
    4164:	67 2d       	mov	r22, r7
    4166:	76 2d       	mov	r23, r6
    4168:	85 2d       	mov	r24, r5
    416a:	94 2d       	mov	r25, r4
    416c:	0e 94 34 3c 	call	0x7868	; 0x7868 <__subsf3>
    4170:	26 2e       	mov	r2, r22
    4172:	87 2e       	mov	r8, r23
    4174:	98 2e       	mov	r9, r24
    4176:	a9 2e       	mov	r10, r25
          if (mm_var < prep.decelerate_after) { // End of cruise.
    4178:	30 90 2f 03 	lds	r3, 0x032F	; 0x80032f <prep+0x27>
    417c:	b0 90 30 03 	lds	r11, 0x0330	; 0x800330 <prep+0x28>
    4180:	00 91 31 03 	lds	r16, 0x0331	; 0x800331 <prep+0x29>
    4184:	10 91 32 03 	lds	r17, 0x0332	; 0x800332 <prep+0x2a>
    4188:	23 2d       	mov	r18, r3
    418a:	3b 2d       	mov	r19, r11
    418c:	40 2f       	mov	r20, r16
    418e:	51 2f       	mov	r21, r17
    4190:	0e 94 0e 3d 	call	0x7a1c	; 0x7a1c <__cmpsf2>
    4194:	88 23       	and	r24, r24
    4196:	0c f0       	brlt	.+2      	; 0x419a <st_prep_buffer+0xa8e>
    4198:	bd c0       	rjmp	.+378    	; 0x4314 <st_prep_buffer+0xc08>
            // Cruise-deceleration junction or end of block.
            time_var = (mm_remaining - prep.decelerate_after)/prep.maximum_speed;
    419a:	23 2d       	mov	r18, r3
    419c:	3b 2d       	mov	r19, r11
    419e:	40 2f       	mov	r20, r16
    41a0:	51 2f       	mov	r21, r17
    41a2:	67 2d       	mov	r22, r7
    41a4:	76 2d       	mov	r23, r6
    41a6:	85 2d       	mov	r24, r5
    41a8:	94 2d       	mov	r25, r4
    41aa:	0e 94 34 3c 	call	0x7868	; 0x7868 <__subsf3>
    41ae:	29 85       	ldd	r18, Y+9	; 0x09
    41b0:	3a 85       	ldd	r19, Y+10	; 0x0a
    41b2:	4b 85       	ldd	r20, Y+11	; 0x0b
    41b4:	5c 85       	ldd	r21, Y+12	; 0x0c
    41b6:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <__divsf3>
    41ba:	6b 01       	movw	r12, r22
    41bc:	7c 01       	movw	r14, r24
            mm_remaining = prep.decelerate_after; // NOTE: 0.0 at EOB
            prep.ramp_type = RAMP_DECEL;
    41be:	82 e0       	ldi	r24, 0x02	; 2
    41c0:	80 93 1a 03 	sts	0x031A, r24	; 0x80031a <prep+0x12>
          //   prevent this, simply enforce a minimum speed threshold in the planner.
          mm_var = mm_remaining - prep.maximum_speed*time_var;
          if (mm_var < prep.decelerate_after) { // End of cruise.
            // Cruise-deceleration junction or end of block.
            time_var = (mm_remaining - prep.decelerate_after)/prep.maximum_speed;
            mm_remaining = prep.decelerate_after; // NOTE: 0.0 at EOB
    41c4:	73 2c       	mov	r7, r3
    41c6:	6b 2c       	mov	r6, r11
    41c8:	50 2e       	mov	r5, r16
    41ca:	41 2e       	mov	r4, r17
    41cc:	a7 c0       	rjmp	.+334    	; 0x431c <st_prep_buffer+0xc10>
            mm_remaining = mm_var;
          }
          break;
        default: // case RAMP_DECEL:
          // NOTE: mm_var used as a misc worker variable to prevent errors when near zero speed.
          speed_var = pl_block->acceleration*time_var; // Used as delta speed (mm/min)
    41ce:	ad 85       	ldd	r26, Y+13	; 0x0d
    41d0:	be 85       	ldd	r27, Y+14	; 0x0e
    41d2:	5e 96       	adiw	r26, 0x1e	; 30
    41d4:	2d 91       	ld	r18, X+
    41d6:	3d 91       	ld	r19, X+
    41d8:	4d 91       	ld	r20, X+
    41da:	5c 91       	ld	r21, X
    41dc:	91 97       	sbiw	r26, 0x21	; 33
    41de:	c7 01       	movw	r24, r14
    41e0:	b6 01       	movw	r22, r12
    41e2:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
    41e6:	4b 01       	movw	r8, r22
    41e8:	5c 01       	movw	r10, r24
          if (prep.current_speed > speed_var) { // Check if at or below zero speed.
    41ea:	80 91 1f 03 	lds	r24, 0x031F	; 0x80031f <prep+0x17>
    41ee:	90 91 20 03 	lds	r25, 0x0320	; 0x800320 <prep+0x18>
    41f2:	a0 91 21 03 	lds	r26, 0x0321	; 0x800321 <prep+0x19>
    41f6:	b0 91 22 03 	lds	r27, 0x0322	; 0x800322 <prep+0x1a>
    41fa:	89 87       	std	Y+9, r24	; 0x09
    41fc:	9a 87       	std	Y+10, r25	; 0x0a
    41fe:	ab 87       	std	Y+11, r26	; 0x0b
    4200:	bc 87       	std	Y+12, r27	; 0x0c
    4202:	9c 01       	movw	r18, r24
    4204:	ad 01       	movw	r20, r26
    4206:	c5 01       	movw	r24, r10
    4208:	b4 01       	movw	r22, r8
    420a:	0e 94 0e 3d 	call	0x7a1c	; 0x7a1c <__cmpsf2>
    420e:	88 23       	and	r24, r24
    4210:	0c f0       	brlt	.+2      	; 0x4214 <st_prep_buffer+0xb08>
    4212:	43 c0       	rjmp	.+134    	; 0x429a <st_prep_buffer+0xb8e>
            // Compute distance from end of segment to end of block.
            mm_var = mm_remaining - time_var*(prep.current_speed - 0.5*speed_var); // (mm)
    4214:	20 e0       	ldi	r18, 0x00	; 0
    4216:	30 e0       	ldi	r19, 0x00	; 0
    4218:	40 e0       	ldi	r20, 0x00	; 0
    421a:	5f e3       	ldi	r21, 0x3F	; 63
    421c:	c5 01       	movw	r24, r10
    421e:	b4 01       	movw	r22, r8
    4220:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
    4224:	9b 01       	movw	r18, r22
    4226:	ac 01       	movw	r20, r24
    4228:	69 85       	ldd	r22, Y+9	; 0x09
    422a:	7a 85       	ldd	r23, Y+10	; 0x0a
    422c:	8b 85       	ldd	r24, Y+11	; 0x0b
    422e:	9c 85       	ldd	r25, Y+12	; 0x0c
    4230:	0e 94 34 3c 	call	0x7868	; 0x7868 <__subsf3>
    4234:	9b 01       	movw	r18, r22
    4236:	ac 01       	movw	r20, r24
    4238:	c7 01       	movw	r24, r14
    423a:	b6 01       	movw	r22, r12
    423c:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
    4240:	9b 01       	movw	r18, r22
    4242:	ac 01       	movw	r20, r24
    4244:	67 2d       	mov	r22, r7
    4246:	76 2d       	mov	r23, r6
    4248:	85 2d       	mov	r24, r5
    424a:	94 2d       	mov	r25, r4
    424c:	0e 94 34 3c 	call	0x7868	; 0x7868 <__subsf3>
    4250:	06 2f       	mov	r16, r22
    4252:	17 2f       	mov	r17, r23
    4254:	8f 8f       	std	Y+31, r24	; 0x1f
    4256:	99 8b       	std	Y+17, r25	; 0x11
            if (mm_var > prep.mm_complete) { // Typical case. In deceleration ramp.
    4258:	20 91 1b 03 	lds	r18, 0x031B	; 0x80031b <prep+0x13>
    425c:	30 91 1c 03 	lds	r19, 0x031C	; 0x80031c <prep+0x14>
    4260:	40 91 1d 03 	lds	r20, 0x031D	; 0x80031d <prep+0x15>
    4264:	50 91 1e 03 	lds	r21, 0x031E	; 0x80031e <prep+0x16>
    4268:	0e 94 11 3f 	call	0x7e22	; 0x7e22 <__gesf2>
    426c:	18 16       	cp	r1, r24
    426e:	ac f4       	brge	.+42     	; 0x429a <st_prep_buffer+0xb8e>
              mm_remaining = mm_var;
              prep.current_speed -= speed_var;
    4270:	a5 01       	movw	r20, r10
    4272:	94 01       	movw	r18, r8
    4274:	69 85       	ldd	r22, Y+9	; 0x09
    4276:	7a 85       	ldd	r23, Y+10	; 0x0a
    4278:	8b 85       	ldd	r24, Y+11	; 0x0b
    427a:	9c 85       	ldd	r25, Y+12	; 0x0c
    427c:	0e 94 34 3c 	call	0x7868	; 0x7868 <__subsf3>
    4280:	60 93 1f 03 	sts	0x031F, r22	; 0x80031f <prep+0x17>
    4284:	70 93 20 03 	sts	0x0320, r23	; 0x800320 <prep+0x18>
    4288:	80 93 21 03 	sts	0x0321, r24	; 0x800321 <prep+0x19>
    428c:	90 93 22 03 	sts	0x0322, r25	; 0x800322 <prep+0x1a>
          speed_var = pl_block->acceleration*time_var; // Used as delta speed (mm/min)
          if (prep.current_speed > speed_var) { // Check if at or below zero speed.
            // Compute distance from end of segment to end of block.
            mm_var = mm_remaining - time_var*(prep.current_speed - 0.5*speed_var); // (mm)
            if (mm_var > prep.mm_complete) { // Typical case. In deceleration ramp.
              mm_remaining = mm_var;
    4290:	70 2e       	mov	r7, r16
    4292:	61 2e       	mov	r6, r17
    4294:	5f 8c       	ldd	r5, Y+31	; 0x1f
    4296:	49 88       	ldd	r4, Y+17	; 0x11
              prep.current_speed -= speed_var;
              break; // Segment complete. Exit switch-case statement. Continue do-while loop.
    4298:	41 c0       	rjmp	.+130    	; 0x431c <st_prep_buffer+0xc10>
            }
          }
          // Otherwise, at end of block or end of forced-deceleration.
          time_var = 2.0*(mm_remaining-prep.mm_complete)/(prep.current_speed+prep.exit_speed);
    429a:	20 90 1b 03 	lds	r2, 0x031B	; 0x80031b <prep+0x13>
    429e:	00 91 1c 03 	lds	r16, 0x031C	; 0x80031c <prep+0x14>
    42a2:	30 90 1d 03 	lds	r3, 0x031D	; 0x80031d <prep+0x15>
    42a6:	10 91 1e 03 	lds	r17, 0x031E	; 0x80031e <prep+0x16>
    42aa:	22 2d       	mov	r18, r2
    42ac:	30 2f       	mov	r19, r16
    42ae:	43 2d       	mov	r20, r3
    42b0:	51 2f       	mov	r21, r17
    42b2:	67 2d       	mov	r22, r7
    42b4:	76 2d       	mov	r23, r6
    42b6:	85 2d       	mov	r24, r5
    42b8:	94 2d       	mov	r25, r4
    42ba:	0e 94 34 3c 	call	0x7868	; 0x7868 <__subsf3>
    42be:	9b 01       	movw	r18, r22
    42c0:	ac 01       	movw	r20, r24
    42c2:	0e 94 35 3c 	call	0x786a	; 0x786a <__addsf3>
    42c6:	6b 01       	movw	r12, r22
    42c8:	7c 01       	movw	r14, r24
    42ca:	40 90 27 03 	lds	r4, 0x0327	; 0x800327 <prep+0x1f>
    42ce:	50 90 28 03 	lds	r5, 0x0328	; 0x800328 <prep+0x20>
    42d2:	60 90 29 03 	lds	r6, 0x0329	; 0x800329 <prep+0x21>
    42d6:	70 90 2a 03 	lds	r7, 0x032A	; 0x80032a <prep+0x22>
    42da:	a3 01       	movw	r20, r6
    42dc:	92 01       	movw	r18, r4
    42de:	69 85       	ldd	r22, Y+9	; 0x09
    42e0:	7a 85       	ldd	r23, Y+10	; 0x0a
    42e2:	8b 85       	ldd	r24, Y+11	; 0x0b
    42e4:	9c 85       	ldd	r25, Y+12	; 0x0c
    42e6:	0e 94 35 3c 	call	0x786a	; 0x786a <__addsf3>
    42ea:	9b 01       	movw	r18, r22
    42ec:	ac 01       	movw	r20, r24
    42ee:	c7 01       	movw	r24, r14
    42f0:	b6 01       	movw	r22, r12
    42f2:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <__divsf3>
    42f6:	6b 01       	movw	r12, r22
    42f8:	7c 01       	movw	r14, r24
          mm_remaining = prep.mm_complete;
          prep.current_speed = prep.exit_speed;
    42fa:	40 92 1f 03 	sts	0x031F, r4	; 0x80031f <prep+0x17>
    42fe:	50 92 20 03 	sts	0x0320, r5	; 0x800320 <prep+0x18>
    4302:	60 92 21 03 	sts	0x0321, r6	; 0x800321 <prep+0x19>
    4306:	70 92 22 03 	sts	0x0322, r7	; 0x800322 <prep+0x1a>
              break; // Segment complete. Exit switch-case statement. Continue do-while loop.
            }
          }
          // Otherwise, at end of block or end of forced-deceleration.
          time_var = 2.0*(mm_remaining-prep.mm_complete)/(prep.current_speed+prep.exit_speed);
          mm_remaining = prep.mm_complete;
    430a:	72 2c       	mov	r7, r2
    430c:	60 2e       	mov	r6, r16
    430e:	53 2c       	mov	r5, r3
    4310:	41 2e       	mov	r4, r17
    4312:	04 c0       	rjmp	.+8      	; 0x431c <st_prep_buffer+0xc10>
            // Cruise-deceleration junction or end of block.
            time_var = (mm_remaining - prep.decelerate_after)/prep.maximum_speed;
            mm_remaining = prep.decelerate_after; // NOTE: 0.0 at EOB
            prep.ramp_type = RAMP_DECEL;
          } else { // Cruising only.
            mm_remaining = mm_var;
    4314:	72 2c       	mov	r7, r2
    4316:	68 2c       	mov	r6, r8
    4318:	59 2c       	mov	r5, r9
    431a:	4a 2c       	mov	r4, r10
          // Otherwise, at end of block or end of forced-deceleration.
          time_var = 2.0*(mm_remaining-prep.mm_complete)/(prep.current_speed+prep.exit_speed);
          mm_remaining = prep.mm_complete;
          prep.current_speed = prep.exit_speed;
      }
      dt += time_var; // Add computed ramp time to total segment time.
    431c:	a7 01       	movw	r20, r14
    431e:	96 01       	movw	r18, r12
    4320:	69 81       	ldd	r22, Y+1	; 0x01
    4322:	7a 81       	ldd	r23, Y+2	; 0x02
    4324:	8b 81       	ldd	r24, Y+3	; 0x03
    4326:	9c 81       	ldd	r25, Y+4	; 0x04
    4328:	0e 94 35 3c 	call	0x786a	; 0x786a <__addsf3>
    432c:	69 83       	std	Y+1, r22	; 0x01
    432e:	7a 83       	std	Y+2, r23	; 0x02
    4330:	8b 83       	std	Y+3, r24	; 0x03
    4332:	9c 83       	std	Y+4, r25	; 0x04
      if (dt < dt_max) { time_var = dt_max - dt; } // **Incomplete** At ramp junction.
    4334:	9b 01       	movw	r18, r22
    4336:	ac 01       	movw	r20, r24
    4338:	6d 81       	ldd	r22, Y+5	; 0x05
    433a:	7e 81       	ldd	r23, Y+6	; 0x06
    433c:	8f 81       	ldd	r24, Y+7	; 0x07
    433e:	98 85       	ldd	r25, Y+8	; 0x08
    4340:	0e 94 11 3f 	call	0x7e22	; 0x7e22 <__gesf2>
    4344:	18 16       	cp	r1, r24
    4346:	6c f4       	brge	.+26     	; 0x4362 <st_prep_buffer+0xc56>
    4348:	29 81       	ldd	r18, Y+1	; 0x01
    434a:	3a 81       	ldd	r19, Y+2	; 0x02
    434c:	4b 81       	ldd	r20, Y+3	; 0x03
    434e:	5c 81       	ldd	r21, Y+4	; 0x04
    4350:	6d 81       	ldd	r22, Y+5	; 0x05
    4352:	7e 81       	ldd	r23, Y+6	; 0x06
    4354:	8f 81       	ldd	r24, Y+7	; 0x07
    4356:	98 85       	ldd	r25, Y+8	; 0x08
    4358:	0e 94 34 3c 	call	0x7868	; 0x7868 <__subsf3>
    435c:	6b 01       	movw	r12, r22
    435e:	7c 01       	movw	r14, r24
    4360:	22 c0       	rjmp	.+68     	; 0x43a6 <st_prep_buffer+0xc9a>
      else {
        if (mm_remaining > minimum_mm) { // Check for very slow segments with zero steps.
    4362:	2d 89       	ldd	r18, Y+21	; 0x15
    4364:	3e 89       	ldd	r19, Y+22	; 0x16
    4366:	4f 89       	ldd	r20, Y+23	; 0x17
    4368:	58 8d       	ldd	r21, Y+24	; 0x18
    436a:	67 2d       	mov	r22, r7
    436c:	76 2d       	mov	r23, r6
    436e:	85 2d       	mov	r24, r5
    4370:	94 2d       	mov	r25, r4
    4372:	0e 94 11 3f 	call	0x7e22	; 0x7e22 <__gesf2>
    4376:	18 16       	cp	r1, r24
    4378:	3c f5       	brge	.+78     	; 0x43c8 <st_prep_buffer+0xcbc>
          // Increase segment time to ensure at least one step in segment. Override and loop
          // through distance calculations until minimum_mm or mm_complete.
          dt_max += DT_SEGMENT;
    437a:	2e e3       	ldi	r18, 0x3E	; 62
    437c:	33 ec       	ldi	r19, 0xC3	; 195
    437e:	4e e2       	ldi	r20, 0x2E	; 46
    4380:	59 e3       	ldi	r21, 0x39	; 57
    4382:	6d 81       	ldd	r22, Y+5	; 0x05
    4384:	7e 81       	ldd	r23, Y+6	; 0x06
    4386:	8f 81       	ldd	r24, Y+7	; 0x07
    4388:	98 85       	ldd	r25, Y+8	; 0x08
    438a:	0e 94 35 3c 	call	0x786a	; 0x786a <__addsf3>
    438e:	6d 83       	std	Y+5, r22	; 0x05
    4390:	7e 83       	std	Y+6, r23	; 0x06
    4392:	8f 83       	std	Y+7, r24	; 0x07
    4394:	98 87       	std	Y+8, r25	; 0x08
          time_var = dt_max - dt;
    4396:	29 81       	ldd	r18, Y+1	; 0x01
    4398:	3a 81       	ldd	r19, Y+2	; 0x02
    439a:	4b 81       	ldd	r20, Y+3	; 0x03
    439c:	5c 81       	ldd	r21, Y+4	; 0x04
    439e:	0e 94 34 3c 	call	0x7868	; 0x7868 <__subsf3>
    43a2:	6b 01       	movw	r12, r22
    43a4:	7c 01       	movw	r14, r24
        } else {
          break; // **Complete** Exit loop. Segment execution time maxed.
        }
      }
    } while (mm_remaining > prep.mm_complete); // **Complete** Exit loop. Profile complete.
    43a6:	20 91 1b 03 	lds	r18, 0x031B	; 0x80031b <prep+0x13>
    43aa:	30 91 1c 03 	lds	r19, 0x031C	; 0x80031c <prep+0x14>
    43ae:	40 91 1d 03 	lds	r20, 0x031D	; 0x80031d <prep+0x15>
    43b2:	50 91 1e 03 	lds	r21, 0x031E	; 0x80031e <prep+0x16>
    43b6:	67 2d       	mov	r22, r7
    43b8:	76 2d       	mov	r23, r6
    43ba:	85 2d       	mov	r24, r5
    43bc:	94 2d       	mov	r25, r4
    43be:	0e 94 11 3f 	call	0x7e22	; 0x7e22 <__gesf2>
    43c2:	18 16       	cp	r1, r24
    43c4:	0c f4       	brge	.+2      	; 0x43c8 <st_prep_buffer+0xcbc>
    43c6:	6d cd       	rjmp	.-1318   	; 0x3ea2 <st_prep_buffer+0x796>
    43c8:	a7 2c       	mov	r10, r7
    43ca:	b6 2c       	mov	r11, r6
    43cc:	25 2c       	mov	r2, r5
    43ce:	34 2c       	mov	r3, r4

    /* -----------------------------------------------------------------------------------
      Compute spindle speed PWM output for step segment
    */
    
    if (st_prep_block->is_pwm_rate_adjusted || (sys.step_control & STEP_CONTROL_UPDATE_SPINDLE_PWM)) {
    43d0:	e0 91 39 03 	lds	r30, 0x0339	; 0x800339 <st_prep_block>
    43d4:	f0 91 3a 03 	lds	r31, 0x033A	; 0x80033a <st_prep_block+0x1>
    43d8:	91 89       	ldd	r25, Z+17	; 0x11
    43da:	91 11       	cpse	r25, r1
    43dc:	04 c0       	rjmp	.+8      	; 0x43e6 <st_prep_buffer+0xcda>
    43de:	80 91 15 0c 	lds	r24, 0x0C15	; 0x800c15 <sys+0x4>
    43e2:	83 ff       	sbrs	r24, 3
    43e4:	3d c0       	rjmp	.+122    	; 0x4460 <st_prep_buffer+0xd54>
      if (pl_block->condition & (PL_COND_FLAG_SPINDLE_CW | PL_COND_FLAG_SPINDLE_CCW)) {
    43e6:	ad 85       	ldd	r26, Y+13	; 0x0d
    43e8:	be 85       	ldd	r27, Y+14	; 0x0e
    43ea:	51 96       	adiw	r26, 0x11	; 17
    43ec:	8c 91       	ld	r24, X
    43ee:	51 97       	sbiw	r26, 0x11	; 17
    43f0:	80 73       	andi	r24, 0x30	; 48
    43f2:	29 f1       	breq	.+74     	; 0x443e <st_prep_buffer+0xd32>
        float rpm = pl_block->spindle_speed;
    43f4:	d2 96       	adiw	r26, 0x32	; 50
    43f6:	cd 90       	ld	r12, X+
    43f8:	dd 90       	ld	r13, X+
    43fa:	ed 90       	ld	r14, X+
    43fc:	fc 90       	ld	r15, X
    43fe:	d5 97       	sbiw	r26, 0x35	; 53
        // NOTE: Feed and rapid overrides are independent of PWM value and do not alter laser power/rate.        
        if (st_prep_block->is_pwm_rate_adjusted) { rpm *= (prep.current_speed * prep.inv_rate); }
    4400:	99 23       	and	r25, r25
    4402:	a1 f0       	breq	.+40     	; 0x442c <st_prep_buffer+0xd20>
    4404:	e8 e0       	ldi	r30, 0x08	; 8
    4406:	f3 e0       	ldi	r31, 0x03	; 3
    4408:	67 89       	ldd	r22, Z+23	; 0x17
    440a:	70 8d       	ldd	r23, Z+24	; 0x18
    440c:	81 8d       	ldd	r24, Z+25	; 0x19
    440e:	92 8d       	ldd	r25, Z+26	; 0x1a
    4410:	23 a5       	ldd	r18, Z+43	; 0x2b
    4412:	34 a5       	ldd	r19, Z+44	; 0x2c
    4414:	45 a5       	ldd	r20, Z+45	; 0x2d
    4416:	56 a5       	ldd	r21, Z+46	; 0x2e
    4418:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
    441c:	9b 01       	movw	r18, r22
    441e:	ac 01       	movw	r20, r24
    4420:	c7 01       	movw	r24, r14
    4422:	b6 01       	movw	r22, r12
    4424:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
    4428:	6b 01       	movw	r12, r22
    442a:	7c 01       	movw	r14, r24
        // If current_speed is zero, then may need to be rpm_min*(100/MAX_SPINDLE_SPEED_OVERRIDE)
        // but this would be instantaneous only and during a motion. May not matter at all.
        prep.current_spindle_pwm = spindle_compute_pwm_value(rpm);
    442c:	c7 01       	movw	r24, r14
    442e:	b6 01       	movw	r22, r12
    4430:	0e 94 9f 12 	call	0x253e	; 0x253e <spindle_compute_pwm_value>
    4434:	90 93 38 03 	sts	0x0338, r25	; 0x800338 <prep+0x30>
    4438:	80 93 37 03 	sts	0x0337, r24	; 0x800337 <prep+0x2f>
    443c:	0c c0       	rjmp	.+24     	; 0x4456 <st_prep_buffer+0xd4a>
      } else { 
        sys.spindle_speed = 0.0;
    443e:	10 92 1e 0c 	sts	0x0C1E, r1	; 0x800c1e <sys+0xd>
    4442:	10 92 1f 0c 	sts	0x0C1F, r1	; 0x800c1f <sys+0xe>
    4446:	10 92 20 0c 	sts	0x0C20, r1	; 0x800c20 <sys+0xf>
    444a:	10 92 21 0c 	sts	0x0C21, r1	; 0x800c21 <sys+0x10>
        prep.current_spindle_pwm = SPINDLE_PWM_OFF_VALUE;
    444e:	10 92 38 03 	sts	0x0338, r1	; 0x800338 <prep+0x30>
    4452:	10 92 37 03 	sts	0x0337, r1	; 0x800337 <prep+0x2f>
      }
      bit_false(sys.step_control,STEP_CONTROL_UPDATE_SPINDLE_PWM);
    4456:	e1 e1       	ldi	r30, 0x11	; 17
    4458:	fc e0       	ldi	r31, 0x0C	; 12
    445a:	84 81       	ldd	r24, Z+4	; 0x04
    445c:	87 7f       	andi	r24, 0xF7	; 247
    445e:	84 83       	std	Z+4, r24	; 0x04
    }
    prep_segment->spindle_pwm = prep.current_spindle_pwm; // Reload segment PWM value
    4460:	80 91 37 03 	lds	r24, 0x0337	; 0x800337 <prep+0x2f>
    4464:	90 91 38 03 	lds	r25, 0x0338	; 0x800338 <prep+0x30>
    4468:	0d 8d       	ldd	r16, Y+29	; 0x1d
    446a:	1e 8d       	ldd	r17, Y+30	; 0x1e
    446c:	00 0f       	add	r16, r16
    446e:	11 1f       	adc	r17, r17
    4470:	00 0f       	add	r16, r16
    4472:	11 1f       	adc	r17, r17
    4474:	00 0f       	add	r16, r16
    4476:	11 1f       	adc	r17, r17
    4478:	0a 59       	subi	r16, 0x9A	; 154
    447a:	1c 4f       	sbci	r17, 0xFC	; 252
    447c:	f8 01       	movw	r30, r16
    447e:	97 83       	std	Z+7, r25	; 0x07
    4480:	86 83       	std	Z+6, r24	; 0x06
       However, since floats have only 7.2 significant digits, long moves with extremely
       high step counts can exceed the precision of floats, which can lead to lost steps.
       Fortunately, this scenario is highly unlikely and unrealistic in CNC machines
       supported by Grbl (i.e. exceeding 10 meters axis travel at 200 step/mm).
    */
    float step_dist_remaining = prep.step_per_mm*mm_remaining; // Convert mm_remaining to steps
    4482:	20 91 12 03 	lds	r18, 0x0312	; 0x800312 <prep+0xa>
    4486:	30 91 13 03 	lds	r19, 0x0313	; 0x800313 <prep+0xb>
    448a:	40 91 14 03 	lds	r20, 0x0314	; 0x800314 <prep+0xc>
    448e:	50 91 15 03 	lds	r21, 0x0315	; 0x800315 <prep+0xd>
    4492:	6a 2d       	mov	r22, r10
    4494:	7b 2d       	mov	r23, r11
    4496:	82 2d       	mov	r24, r2
    4498:	93 2d       	mov	r25, r3
    449a:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
    449e:	6d 83       	std	Y+5, r22	; 0x05
    44a0:	7e 83       	std	Y+6, r23	; 0x06
    44a2:	8f 83       	std	Y+7, r24	; 0x07
    44a4:	98 87       	std	Y+8, r25	; 0x08
    float n_steps_remaining = ceil(step_dist_remaining); // Round-up current steps remaining
    44a6:	0e 94 fb 3c 	call	0x79f6	; 0x79f6 <ceil>
    44aa:	2b 01       	movw	r4, r22
    44ac:	3c 01       	movw	r6, r24
    float last_n_steps_remaining = ceil(prep.steps_remaining); // Round-up last steps remaining
    44ae:	60 91 0e 03 	lds	r22, 0x030E	; 0x80030e <prep+0x6>
    44b2:	70 91 0f 03 	lds	r23, 0x030F	; 0x80030f <prep+0x7>
    44b6:	80 91 10 03 	lds	r24, 0x0310	; 0x800310 <prep+0x8>
    44ba:	90 91 11 03 	lds	r25, 0x0311	; 0x800311 <prep+0x9>
    44be:	0e 94 fb 3c 	call	0x79f6	; 0x79f6 <ceil>
    44c2:	6d 87       	std	Y+13, r22	; 0x0d
    44c4:	7e 87       	std	Y+14, r23	; 0x0e
    44c6:	8f 87       	std	Y+15, r24	; 0x0f
    44c8:	98 8b       	std	Y+16, r25	; 0x10
    prep_segment->n_step = last_n_steps_remaining-n_steps_remaining; // Compute number of steps to execute.
    44ca:	a3 01       	movw	r20, r6
    44cc:	92 01       	movw	r18, r4
    44ce:	0e 94 34 3c 	call	0x7868	; 0x7868 <__subsf3>
    44d2:	0e 94 82 3d 	call	0x7b04	; 0x7b04 <__fixunssfsi>
    44d6:	6b 01       	movw	r12, r22
    44d8:	7c 01       	movw	r14, r24
    44da:	d8 01       	movw	r26, r16
    44dc:	6d 93       	st	X+, r22
    44de:	7c 93       	st	X, r23

    // Bail if we are at the end of a feed hold and don't have a step to execute.
    if (prep_segment->n_step == 0) {
    44e0:	67 2b       	or	r22, r23
    44e2:	41 f4       	brne	.+16     	; 0x44f4 <st_prep_buffer+0xde8>
      if (sys.step_control & STEP_CONTROL_EXECUTE_HOLD) {
    44e4:	80 91 15 0c 	lds	r24, 0x0C15	; 0x800c15 <sys+0x4>
    44e8:	81 ff       	sbrs	r24, 1
    44ea:	04 c0       	rjmp	.+8      	; 0x44f4 <st_prep_buffer+0xde8>
        // Less than one step to decelerate to zero speed, but already very close. AMASS
        // requires full steps to execute. So, just bail.
        bit_true(sys.step_control,STEP_CONTROL_END_MOTION);
    44ec:	81 60       	ori	r24, 0x01	; 1
    44ee:	80 93 15 0c 	sts	0x0C15, r24	; 0x800c15 <sys+0x4>
        #ifdef PARKING_ENABLE
          if (!(prep.recalculate_flag & PREP_FLAG_PARKING)) { prep.recalculate_flag |= PREP_FLAG_HOLD_PARTIAL_BLOCK; }
        #endif
        return; // Segment not generated, but current step data still retained.
    44f2:	1c c1       	rjmp	.+568    	; 0x472c <st_prep_buffer+0x1020>
    // compensate, we track the time to execute the previous segment's partial step and simply
    // apply it with the partial step distance to the current segment, so that it minutely
    // adjusts the whole segment rate to keep step output exact. These rate adjustments are
    // typically very small and do not adversely effect performance, but ensures that Grbl
    // outputs the exact acceleration and velocity profiles as computed by the planner.
    dt += prep.dt_remainder; // Apply previous segment partial step execute time
    44f4:	20 91 0a 03 	lds	r18, 0x030A	; 0x80030a <prep+0x2>
    44f8:	30 91 0b 03 	lds	r19, 0x030B	; 0x80030b <prep+0x3>
    44fc:	40 91 0c 03 	lds	r20, 0x030C	; 0x80030c <prep+0x4>
    4500:	50 91 0d 03 	lds	r21, 0x030D	; 0x80030d <prep+0x5>
    4504:	69 81       	ldd	r22, Y+1	; 0x01
    4506:	7a 81       	ldd	r23, Y+2	; 0x02
    4508:	8b 81       	ldd	r24, Y+3	; 0x03
    450a:	9c 81       	ldd	r25, Y+4	; 0x04
    450c:	0e 94 35 3c 	call	0x786a	; 0x786a <__addsf3>
    4510:	69 83       	std	Y+1, r22	; 0x01
    4512:	7a 83       	std	Y+2, r23	; 0x02
    4514:	8b 83       	std	Y+3, r24	; 0x03
    4516:	9c 83       	std	Y+4, r25	; 0x04
    float inv_rate = dt/(last_n_steps_remaining - step_dist_remaining); // Compute adjusted step rate inverse
    4518:	2d 81       	ldd	r18, Y+5	; 0x05
    451a:	3e 81       	ldd	r19, Y+6	; 0x06
    451c:	4f 81       	ldd	r20, Y+7	; 0x07
    451e:	58 85       	ldd	r21, Y+8	; 0x08
    4520:	6d 85       	ldd	r22, Y+13	; 0x0d
    4522:	7e 85       	ldd	r23, Y+14	; 0x0e
    4524:	8f 85       	ldd	r24, Y+15	; 0x0f
    4526:	98 89       	ldd	r25, Y+16	; 0x10
    4528:	0e 94 34 3c 	call	0x7868	; 0x7868 <__subsf3>
    452c:	9b 01       	movw	r18, r22
    452e:	ac 01       	movw	r20, r24
    4530:	69 81       	ldd	r22, Y+1	; 0x01
    4532:	7a 81       	ldd	r23, Y+2	; 0x02
    4534:	8b 81       	ldd	r24, Y+3	; 0x03
    4536:	9c 81       	ldd	r25, Y+4	; 0x04
    4538:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <__divsf3>
    453c:	69 83       	std	Y+1, r22	; 0x01
    453e:	7a 83       	std	Y+2, r23	; 0x02
    4540:	8b 83       	std	Y+3, r24	; 0x03
    4542:	9c 83       	std	Y+4, r25	; 0x04

    // Compute CPU cycles per step for the prepped segment.
    uint32_t cycles = ceil( (TICKS_PER_MICROSECOND*1000000*60)*inv_rate ); // (cycles/step)
    4544:	20 ec       	ldi	r18, 0xC0	; 192
    4546:	31 ee       	ldi	r19, 0xE1	; 225
    4548:	44 e6       	ldi	r20, 0x64	; 100
    454a:	5e e4       	ldi	r21, 0x4E	; 78
    454c:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
    4550:	0e 94 fb 3c 	call	0x79f6	; 0x79f6 <ceil>
    4554:	0e 94 82 3d 	call	0x7b04	; 0x7b04 <__fixunssfsi>

    #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
      // Compute step timing and multi-axis smoothing level.
      // NOTE: AMASS overdrives the timer with each level, so only one prescalar is required.
      if (cycles < AMASS_LEVEL1) { prep_segment->amass_level = 0; }
    4558:	60 3d       	cpi	r22, 0xD0	; 208
    455a:	b7 e0       	ldi	r27, 0x07	; 7
    455c:	7b 07       	cpc	r23, r27
    455e:	81 05       	cpc	r24, r1
    4560:	91 05       	cpc	r25, r1
    4562:	60 f4       	brcc	.+24     	; 0x457c <st_prep_buffer+0xe70>
    4564:	ed 8d       	ldd	r30, Y+29	; 0x1d
    4566:	fe 8d       	ldd	r31, Y+30	; 0x1e
    4568:	ee 0f       	add	r30, r30
    456a:	ff 1f       	adc	r31, r31
    456c:	ee 0f       	add	r30, r30
    456e:	ff 1f       	adc	r31, r31
    4570:	ee 0f       	add	r30, r30
    4572:	ff 1f       	adc	r31, r31
    4574:	ea 59       	subi	r30, 0x9A	; 154
    4576:	fc 4f       	sbci	r31, 0xFC	; 252
    4578:	15 82       	std	Z+5, r1	; 0x05
    457a:	4c c0       	rjmp	.+152    	; 0x4614 <st_prep_buffer+0xf08>
      else {
        if (cycles < AMASS_LEVEL2) { prep_segment->amass_level = 1; }
    457c:	60 3a       	cpi	r22, 0xA0	; 160
    457e:	ef e0       	ldi	r30, 0x0F	; 15
    4580:	7e 07       	cpc	r23, r30
    4582:	81 05       	cpc	r24, r1
    4584:	91 05       	cpc	r25, r1
    4586:	68 f4       	brcc	.+26     	; 0x45a2 <st_prep_buffer+0xe96>
    4588:	ed 8d       	ldd	r30, Y+29	; 0x1d
    458a:	fe 8d       	ldd	r31, Y+30	; 0x1e
    458c:	ee 0f       	add	r30, r30
    458e:	ff 1f       	adc	r31, r31
    4590:	ee 0f       	add	r30, r30
    4592:	ff 1f       	adc	r31, r31
    4594:	ee 0f       	add	r30, r30
    4596:	ff 1f       	adc	r31, r31
    4598:	ea 59       	subi	r30, 0x9A	; 154
    459a:	fc 4f       	sbci	r31, 0xFC	; 252
    459c:	21 e0       	ldi	r18, 0x01	; 1
    459e:	25 83       	std	Z+5, r18	; 0x05
    45a0:	1f c0       	rjmp	.+62     	; 0x45e0 <st_prep_buffer+0xed4>
        else if (cycles < AMASS_LEVEL3) { prep_segment->amass_level = 2; }
    45a2:	60 34       	cpi	r22, 0x40	; 64
    45a4:	ff e1       	ldi	r31, 0x1F	; 31
    45a6:	7f 07       	cpc	r23, r31
    45a8:	81 05       	cpc	r24, r1
    45aa:	91 05       	cpc	r25, r1
    45ac:	68 f4       	brcc	.+26     	; 0x45c8 <st_prep_buffer+0xebc>
    45ae:	ed 8d       	ldd	r30, Y+29	; 0x1d
    45b0:	fe 8d       	ldd	r31, Y+30	; 0x1e
    45b2:	ee 0f       	add	r30, r30
    45b4:	ff 1f       	adc	r31, r31
    45b6:	ee 0f       	add	r30, r30
    45b8:	ff 1f       	adc	r31, r31
    45ba:	ee 0f       	add	r30, r30
    45bc:	ff 1f       	adc	r31, r31
    45be:	ea 59       	subi	r30, 0x9A	; 154
    45c0:	fc 4f       	sbci	r31, 0xFC	; 252
    45c2:	22 e0       	ldi	r18, 0x02	; 2
    45c4:	25 83       	std	Z+5, r18	; 0x05
    45c6:	0c c0       	rjmp	.+24     	; 0x45e0 <st_prep_buffer+0xed4>
        else { prep_segment->amass_level = 3; }
    45c8:	ed 8d       	ldd	r30, Y+29	; 0x1d
    45ca:	fe 8d       	ldd	r31, Y+30	; 0x1e
    45cc:	ee 0f       	add	r30, r30
    45ce:	ff 1f       	adc	r31, r31
    45d0:	ee 0f       	add	r30, r30
    45d2:	ff 1f       	adc	r31, r31
    45d4:	ee 0f       	add	r30, r30
    45d6:	ff 1f       	adc	r31, r31
    45d8:	ea 59       	subi	r30, 0x9A	; 154
    45da:	fc 4f       	sbci	r31, 0xFC	; 252
    45dc:	23 e0       	ldi	r18, 0x03	; 3
    45de:	25 83       	std	Z+5, r18	; 0x05
        cycles >>= prep_segment->amass_level;
    45e0:	ed 8d       	ldd	r30, Y+29	; 0x1d
    45e2:	fe 8d       	ldd	r31, Y+30	; 0x1e
    45e4:	ee 0f       	add	r30, r30
    45e6:	ff 1f       	adc	r31, r31
    45e8:	ee 0f       	add	r30, r30
    45ea:	ff 1f       	adc	r31, r31
    45ec:	ee 0f       	add	r30, r30
    45ee:	ff 1f       	adc	r31, r31
    45f0:	ea 59       	subi	r30, 0x9A	; 154
    45f2:	fc 4f       	sbci	r31, 0xFC	; 252
    45f4:	25 81       	ldd	r18, Z+5	; 0x05
    45f6:	02 2e       	mov	r0, r18
    45f8:	04 c0       	rjmp	.+8      	; 0x4602 <st_prep_buffer+0xef6>
    45fa:	96 95       	lsr	r25
    45fc:	87 95       	ror	r24
    45fe:	77 95       	ror	r23
    4600:	67 95       	ror	r22
    4602:	0a 94       	dec	r0
    4604:	d2 f7       	brpl	.-12     	; 0x45fa <st_prep_buffer+0xeee>
        prep_segment->n_step <<= prep_segment->amass_level;
    4606:	02 c0       	rjmp	.+4      	; 0x460c <st_prep_buffer+0xf00>
    4608:	cc 0c       	add	r12, r12
    460a:	dd 1c       	adc	r13, r13
    460c:	2a 95       	dec	r18
    460e:	e2 f7       	brpl	.-8      	; 0x4608 <st_prep_buffer+0xefc>
    4610:	d1 82       	std	Z+1, r13	; 0x01
    4612:	c0 82       	st	Z, r12
      }
      if (cycles < (1UL << 16)) { prep_segment->cycles_per_tick = cycles; } // < 65536 (4.1ms @ 16MHz)
    4614:	61 15       	cp	r22, r1
    4616:	71 05       	cpc	r23, r1
    4618:	21 e0       	ldi	r18, 0x01	; 1
    461a:	82 07       	cpc	r24, r18
    461c:	91 05       	cpc	r25, r1
    461e:	68 f4       	brcc	.+26     	; 0x463a <st_prep_buffer+0xf2e>
    4620:	ed 8d       	ldd	r30, Y+29	; 0x1d
    4622:	fe 8d       	ldd	r31, Y+30	; 0x1e
    4624:	ee 0f       	add	r30, r30
    4626:	ff 1f       	adc	r31, r31
    4628:	ee 0f       	add	r30, r30
    462a:	ff 1f       	adc	r31, r31
    462c:	ee 0f       	add	r30, r30
    462e:	ff 1f       	adc	r31, r31
    4630:	ea 59       	subi	r30, 0x9A	; 154
    4632:	fc 4f       	sbci	r31, 0xFC	; 252
    4634:	73 83       	std	Z+3, r23	; 0x03
    4636:	62 83       	std	Z+2, r22	; 0x02
    4638:	0e c0       	rjmp	.+28     	; 0x4656 <st_prep_buffer+0xf4a>
      else { prep_segment->cycles_per_tick = 0xffff; } // Just set the slowest speed possible.
    463a:	ed 8d       	ldd	r30, Y+29	; 0x1d
    463c:	fe 8d       	ldd	r31, Y+30	; 0x1e
    463e:	ee 0f       	add	r30, r30
    4640:	ff 1f       	adc	r31, r31
    4642:	ee 0f       	add	r30, r30
    4644:	ff 1f       	adc	r31, r31
    4646:	ee 0f       	add	r30, r30
    4648:	ff 1f       	adc	r31, r31
    464a:	ea 59       	subi	r30, 0x9A	; 154
    464c:	fc 4f       	sbci	r31, 0xFC	; 252
    464e:	8f ef       	ldi	r24, 0xFF	; 255
    4650:	9f ef       	ldi	r25, 0xFF	; 255
    4652:	93 83       	std	Z+3, r25	; 0x03
    4654:	82 83       	std	Z+2, r24	; 0x02
        }
      }
    #endif

    // Segment complete! Increment segment buffer indices, so stepper ISR can immediately execute it.
    segment_buffer_head = segment_next_head;
    4656:	80 91 40 03 	lds	r24, 0x0340	; 0x800340 <segment_next_head>
    465a:	80 93 41 03 	sts	0x0341, r24	; 0x800341 <segment_buffer_head>
    if ( ++segment_next_head == SEGMENT_BUFFER_SIZE ) { segment_next_head = 0; }
    465e:	8f 5f       	subi	r24, 0xFF	; 255
    4660:	80 93 40 03 	sts	0x0340, r24	; 0x800340 <segment_next_head>
    4664:	8a 30       	cpi	r24, 0x0A	; 10
    4666:	11 f4       	brne	.+4      	; 0x466c <st_prep_buffer+0xf60>
    4668:	10 92 40 03 	sts	0x0340, r1	; 0x800340 <segment_next_head>

    // Update the appropriate planner and segment data.
    pl_block->millimeters = mm_remaining;
    466c:	e0 91 3b 03 	lds	r30, 0x033B	; 0x80033b <pl_block>
    4670:	f0 91 3c 03 	lds	r31, 0x033C	; 0x80033c <pl_block+0x1>
    4674:	8a 2d       	mov	r24, r10
    4676:	9b 2d       	mov	r25, r11
    4678:	a2 2d       	mov	r26, r2
    467a:	b3 2d       	mov	r27, r3
    467c:	82 a3       	std	Z+34, r24	; 0x22
    467e:	93 a3       	std	Z+35, r25	; 0x23
    4680:	a4 a3       	std	Z+36, r26	; 0x24
    4682:	b5 a3       	std	Z+37, r27	; 0x25
    prep.steps_remaining = n_steps_remaining;
    4684:	40 92 0e 03 	sts	0x030E, r4	; 0x80030e <prep+0x6>
    4688:	50 92 0f 03 	sts	0x030F, r5	; 0x80030f <prep+0x7>
    468c:	60 92 10 03 	sts	0x0310, r6	; 0x800310 <prep+0x8>
    4690:	70 92 11 03 	sts	0x0311, r7	; 0x800311 <prep+0x9>
    prep.dt_remainder = (n_steps_remaining - step_dist_remaining)*inv_rate;
    4694:	2d 81       	ldd	r18, Y+5	; 0x05
    4696:	3e 81       	ldd	r19, Y+6	; 0x06
    4698:	4f 81       	ldd	r20, Y+7	; 0x07
    469a:	58 85       	ldd	r21, Y+8	; 0x08
    469c:	c3 01       	movw	r24, r6
    469e:	b2 01       	movw	r22, r4
    46a0:	0e 94 34 3c 	call	0x7868	; 0x7868 <__subsf3>
    46a4:	9b 01       	movw	r18, r22
    46a6:	ac 01       	movw	r20, r24
    46a8:	69 81       	ldd	r22, Y+1	; 0x01
    46aa:	7a 81       	ldd	r23, Y+2	; 0x02
    46ac:	8b 81       	ldd	r24, Y+3	; 0x03
    46ae:	9c 81       	ldd	r25, Y+4	; 0x04
    46b0:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
    46b4:	60 93 0a 03 	sts	0x030A, r22	; 0x80030a <prep+0x2>
    46b8:	70 93 0b 03 	sts	0x030B, r23	; 0x80030b <prep+0x3>
    46bc:	80 93 0c 03 	sts	0x030C, r24	; 0x80030c <prep+0x4>
    46c0:	90 93 0d 03 	sts	0x030D, r25	; 0x80030d <prep+0x5>

    // Check for exit conditions and flag to load next planner block.
    if (mm_remaining == prep.mm_complete) {
    46c4:	20 91 1b 03 	lds	r18, 0x031B	; 0x80031b <prep+0x13>
    46c8:	30 91 1c 03 	lds	r19, 0x031C	; 0x80031c <prep+0x14>
    46cc:	40 91 1d 03 	lds	r20, 0x031D	; 0x80031d <prep+0x15>
    46d0:	50 91 1e 03 	lds	r21, 0x031E	; 0x80031e <prep+0x16>
    46d4:	6a 2d       	mov	r22, r10
    46d6:	7b 2d       	mov	r23, r11
    46d8:	82 2d       	mov	r24, r2
    46da:	93 2d       	mov	r25, r3
    46dc:	0e 94 0e 3d 	call	0x7a1c	; 0x7a1c <__cmpsf2>
    46e0:	81 11       	cpse	r24, r1
    46e2:	1e c0       	rjmp	.+60     	; 0x4720 <st_prep_buffer+0x1014>
      // End of planner block or forced-termination. No more distance to be executed.
      if (mm_remaining > 0.0) { // At end of forced-termination.
    46e4:	20 e0       	ldi	r18, 0x00	; 0
    46e6:	30 e0       	ldi	r19, 0x00	; 0
    46e8:	a9 01       	movw	r20, r18
    46ea:	6a 2d       	mov	r22, r10
    46ec:	7b 2d       	mov	r23, r11
    46ee:	82 2d       	mov	r24, r2
    46f0:	93 2d       	mov	r25, r3
    46f2:	0e 94 11 3f 	call	0x7e22	; 0x7e22 <__gesf2>
    46f6:	18 16       	cp	r1, r24
    46f8:	34 f4       	brge	.+12     	; 0x4706 <st_prep_buffer+0xffa>
        // Reset prep parameters for resuming and then bail. Allow the stepper ISR to complete
        // the segment queue, where realtime protocol will set new state upon receiving the
        // cycle stop flag from the ISR. Prep_segment is blocked until then.
        bit_true(sys.step_control,STEP_CONTROL_END_MOTION);
    46fa:	e1 e1       	ldi	r30, 0x11	; 17
    46fc:	fc e0       	ldi	r31, 0x0C	; 12
    46fe:	84 81       	ldd	r24, Z+4	; 0x04
    4700:	81 60       	ori	r24, 0x01	; 1
    4702:	84 83       	std	Z+4, r24	; 0x04
        #ifdef PARKING_ENABLE
          if (!(prep.recalculate_flag & PREP_FLAG_PARKING)) { prep.recalculate_flag |= PREP_FLAG_HOLD_PARTIAL_BLOCK; }
        #endif
        return; // Bail!
    4704:	13 c0       	rjmp	.+38     	; 0x472c <st_prep_buffer+0x1020>
      } else { // End of planner block
        // The planner block is complete. All steps are set to be executed in the segment buffer.
        if (sys.step_control & STEP_CONTROL_EXECUTE_SYS_MOTION) {
    4706:	80 91 15 0c 	lds	r24, 0x0C15	; 0x800c15 <sys+0x4>
    470a:	82 ff       	sbrs	r24, 2
    470c:	04 c0       	rjmp	.+8      	; 0x4716 <st_prep_buffer+0x100a>
          bit_true(sys.step_control,STEP_CONTROL_END_MOTION);
    470e:	81 60       	ori	r24, 0x01	; 1
    4710:	80 93 15 0c 	sts	0x0C15, r24	; 0x800c15 <sys+0x4>
          return;
    4714:	0b c0       	rjmp	.+22     	; 0x472c <st_prep_buffer+0x1020>
        }
        pl_block = NULL; // Set pointer to indicate check and load next planner block.
    4716:	10 92 3c 03 	sts	0x033C, r1	; 0x80033c <pl_block+0x1>
    471a:	10 92 3b 03 	sts	0x033B, r1	; 0x80033b <pl_block>
        plan_discard_current_block();
    471e:	17 d5       	rcall	.+2606   	; 0x514e <plan_discard_current_block>
void st_prep_buffer()
{
  // Block step prep buffer, while in a suspend state and there is no suspend motion to execute.
  if (bit_istrue(sys.step_control,STEP_CONTROL_END_MOTION)) { return; }

  while (segment_buffer_tail != segment_next_head) { // Check if we need to fill the buffer.
    4720:	90 91 42 03 	lds	r25, 0x0342	; 0x800342 <segment_buffer_tail>
    4724:	80 91 40 03 	lds	r24, 0x0340	; 0x800340 <segment_next_head>
    4728:	98 13       	cpse	r25, r24
    472a:	0f c8       	rjmp	.-4066   	; 0x374a <st_prep_buffer+0x3e>
        plan_discard_current_block();
      }
    }

  }
}
    472c:	6f 96       	adiw	r28, 0x1f	; 31
    472e:	0f b6       	in	r0, 0x3f	; 63
    4730:	f8 94       	cli
    4732:	de bf       	out	0x3e, r29	; 62
    4734:	0f be       	out	0x3f, r0	; 63
    4736:	cd bf       	out	0x3d, r28	; 61
    4738:	df 91       	pop	r29
    473a:	cf 91       	pop	r28
    473c:	1f 91       	pop	r17
    473e:	0f 91       	pop	r16
    4740:	ff 90       	pop	r15
    4742:	ef 90       	pop	r14
    4744:	df 90       	pop	r13
    4746:	cf 90       	pop	r12
    4748:	bf 90       	pop	r11
    474a:	af 90       	pop	r10
    474c:	9f 90       	pop	r9
    474e:	8f 90       	pop	r8
    4750:	7f 90       	pop	r7
    4752:	6f 90       	pop	r6
    4754:	5f 90       	pop	r5
    4756:	4f 90       	pop	r4
    4758:	3f 90       	pop	r3
    475a:	2f 90       	pop	r2
    475c:	08 95       	ret

0000475e <st_get_realtime_rate>:
// however is not exactly the current speed, but the speed computed in the last step segment
// in the segment buffer. It will always be behind by up to the number of segment blocks (-1)
// divided by the ACCELERATION TICKS PER SECOND in seconds.
float st_get_realtime_rate()
{
  if (sys.state & (STATE_CYCLE | STATE_HOMING | STATE_HOLD | STATE_JOG | STATE_SAFETY_DOOR)){
    475e:	80 91 11 0c 	lds	r24, 0x0C11	; 0x800c11 <sys>
    4762:	8c 77       	andi	r24, 0x7C	; 124
    4764:	49 f0       	breq	.+18     	; 0x4778 <st_get_realtime_rate+0x1a>
    return prep.current_speed;
    4766:	60 91 1f 03 	lds	r22, 0x031F	; 0x80031f <prep+0x17>
    476a:	70 91 20 03 	lds	r23, 0x0320	; 0x800320 <prep+0x18>
    476e:	80 91 21 03 	lds	r24, 0x0321	; 0x800321 <prep+0x19>
    4772:	90 91 22 03 	lds	r25, 0x0322	; 0x800322 <prep+0x1a>
    4776:	08 95       	ret
  }
  return 0.0f;
    4778:	60 e0       	ldi	r22, 0x00	; 0
    477a:	70 e0       	ldi	r23, 0x00	; 0
    477c:	cb 01       	movw	r24, r22
}
    477e:	08 95       	ret

00004780 <eeprom_get_char>:
 *  \param  addr  EEPROM address to read from.
 *  \return  The byte read from the EEPROM address.
 */
unsigned char eeprom_get_char( unsigned int addr )
{
	do {} while( EECR & (1<<EEPE) ); // Wait for completion of previous write.
    4780:	f9 99       	sbic	0x1f, 1	; 31
    4782:	fe cf       	rjmp	.-4      	; 0x4780 <eeprom_get_char>
	EEAR = addr; // Set EEPROM address register.
    4784:	92 bd       	out	0x22, r25	; 34
    4786:	81 bd       	out	0x21, r24	; 33
	EECR = (1<<EERE); // Start EEPROM read operation.
    4788:	81 e0       	ldi	r24, 0x01	; 1
    478a:	8f bb       	out	0x1f, r24	; 31
	return EEDR; // Return the byte read from EEPROM.
    478c:	80 b5       	in	r24, 0x20	; 32
}
    478e:	08 95       	ret

00004790 <eeprom_put_char>:
void eeprom_put_char( unsigned int addr, unsigned char new_value )
{
	char old_value; // Old EEPROM value.
	char diff_mask; // Difference mask, i.e. old value XOR new value.

	cli(); // Ensure atomic operation for the write operation.
    4790:	f8 94       	cli
	
	do {} while( EECR & (1<<EEPE) ); // Wait for completion of previous write.
    4792:	f9 99       	sbic	0x1f, 1	; 31
    4794:	fe cf       	rjmp	.-4      	; 0x4792 <eeprom_put_char+0x2>
	#ifndef EEPROM_IGNORE_SELFPROG
	do {} while( SPMCSR & (1<<SELFPRGEN) ); // Wait for completion of SPM.
	#endif
	
	EEAR = addr; // Set EEPROM address register.
    4796:	92 bd       	out	0x22, r25	; 34
    4798:	81 bd       	out	0x21, r24	; 33
	EECR = (1<<EERE); // Start EEPROM read operation.
    479a:	81 e0       	ldi	r24, 0x01	; 1
    479c:	8f bb       	out	0x1f, r24	; 31
	old_value = EEDR; // Get old EEPROM value.
    479e:	80 b5       	in	r24, 0x20	; 32
	diff_mask = old_value ^ new_value; // Get bit differences.
    47a0:	86 27       	eor	r24, r22
	
	// Check if any bits are changed to '1' in the new value.
	if( diff_mask & new_value ) {
    47a2:	96 2f       	mov	r25, r22
    47a4:	98 23       	and	r25, r24
    47a6:	79 f0       	breq	.+30     	; 0x47c6 <eeprom_put_char+0x36>
		// Now we know that _some_ bits need to be erased to '1'.
		
		// Check if any bits in the new value are '0'.
		if( new_value != 0xff ) {
    47a8:	6f 3f       	cpi	r22, 0xFF	; 255
    47aa:	39 f0       	breq	.+14     	; 0x47ba <eeprom_put_char+0x2a>
			// Now we know that some bits need to be programmed to '0' also.
			
			EEDR = new_value; // Set EEPROM data register.
    47ac:	60 bd       	out	0x20, r22	; 32
			EECR = (1<<EEMPE) | // Set Master Write Enable bit...
    47ae:	84 e0       	ldi	r24, 0x04	; 4
    47b0:	8f bb       	out	0x1f, r24	; 31
			       (0<<EEPM1) | (0<<EEPM0); // ...and Erase+Write mode.
			EECR |= (1<<EEPE);  // Start Erase+Write operation.
    47b2:	8f b3       	in	r24, 0x1f	; 31
    47b4:	82 60       	ori	r24, 0x02	; 2
    47b6:	8f bb       	out	0x1f, r24	; 31
    47b8:	0e c0       	rjmp	.+28     	; 0x47d6 <eeprom_put_char+0x46>
		} else {
			// Now we know that all bits should be erased.

			EECR = (1<<EEMPE) | // Set Master Write Enable bit...
    47ba:	84 e1       	ldi	r24, 0x14	; 20
    47bc:	8f bb       	out	0x1f, r24	; 31
			       (1<<EEPM0);  // ...and Erase-only mode.
			EECR |= (1<<EEPE);  // Start Erase-only operation.
    47be:	8f b3       	in	r24, 0x1f	; 31
    47c0:	82 60       	ori	r24, 0x02	; 2
    47c2:	8f bb       	out	0x1f, r24	; 31
    47c4:	08 c0       	rjmp	.+16     	; 0x47d6 <eeprom_put_char+0x46>
		}
	} else {
		// Now we know that _no_ bits need to be erased to '1'.
		
		// Check if any bits are changed from '1' in the old value.
		if( diff_mask ) {
    47c6:	88 23       	and	r24, r24
    47c8:	31 f0       	breq	.+12     	; 0x47d6 <eeprom_put_char+0x46>
			// Now we know that _some_ bits need to the programmed to '0'.
			
			EEDR = new_value;   // Set EEPROM data register.
    47ca:	60 bd       	out	0x20, r22	; 32
			EECR = (1<<EEMPE) | // Set Master Write Enable bit...
    47cc:	84 e2       	ldi	r24, 0x24	; 36
    47ce:	8f bb       	out	0x1f, r24	; 31
			       (1<<EEPM1);  // ...and Write-only mode.
			EECR |= (1<<EEPE);  // Start Write-only operation.
    47d0:	8f b3       	in	r24, 0x1f	; 31
    47d2:	82 60       	ori	r24, 0x02	; 2
    47d4:	8f bb       	out	0x1f, r24	; 31
		}
	}
	
	sei(); // Restore interrupt flag state.
    47d6:	78 94       	sei
    47d8:	08 95       	ret

000047da <memcpy_to_eeprom_with_checksum>:
}

// Extensions added as part of Grbl 


void memcpy_to_eeprom_with_checksum(unsigned int destination, char *source, unsigned int size) {
    47da:	cf 92       	push	r12
    47dc:	df 92       	push	r13
    47de:	ff 92       	push	r15
    47e0:	0f 93       	push	r16
    47e2:	1f 93       	push	r17
    47e4:	cf 93       	push	r28
    47e6:	df 93       	push	r29
    47e8:	8b 01       	movw	r16, r22
    47ea:	ea 01       	movw	r28, r20
  unsigned char checksum = 0;
    47ec:	f1 2c       	mov	r15, r1
  for(; size > 0; size--) { 
    47ee:	1a c0       	rjmp	.+52     	; 0x4824 <memcpy_to_eeprom_with_checksum+0x4a>
    checksum = (checksum << 1) || (checksum >> 7);
    47f0:	2f 2d       	mov	r18, r15
    47f2:	30 e0       	ldi	r19, 0x00	; 0
    47f4:	22 0f       	add	r18, r18
    47f6:	33 1f       	adc	r19, r19
    47f8:	21 15       	cp	r18, r1
    47fa:	31 05       	cpc	r19, r1
    47fc:	29 f4       	brne	.+10     	; 0x4808 <memcpy_to_eeprom_with_checksum+0x2e>
    47fe:	ff 20       	and	r15, r15
    4800:	2c f4       	brge	.+10     	; 0x480c <memcpy_to_eeprom_with_checksum+0x32>
    4802:	21 e0       	ldi	r18, 0x01	; 1
    4804:	30 e0       	ldi	r19, 0x00	; 0
    4806:	02 c0       	rjmp	.+4      	; 0x480c <memcpy_to_eeprom_with_checksum+0x32>
    4808:	21 e0       	ldi	r18, 0x01	; 1
    480a:	30 e0       	ldi	r19, 0x00	; 0
    checksum += *source;
    480c:	f8 01       	movw	r30, r16
    480e:	61 91       	ld	r22, Z+
    4810:	8f 01       	movw	r16, r30
    4812:	f6 2e       	mov	r15, r22
    4814:	f2 0e       	add	r15, r18
    eeprom_put_char(destination++, *(source++)); 
    4816:	6c 01       	movw	r12, r24
    4818:	ff ef       	ldi	r31, 0xFF	; 255
    481a:	cf 1a       	sub	r12, r31
    481c:	df 0a       	sbc	r13, r31
    481e:	b8 df       	rcall	.-144    	; 0x4790 <eeprom_put_char>
// Extensions added as part of Grbl 


void memcpy_to_eeprom_with_checksum(unsigned int destination, char *source, unsigned int size) {
  unsigned char checksum = 0;
  for(; size > 0; size--) { 
    4820:	21 97       	sbiw	r28, 0x01	; 1
    checksum = (checksum << 1) || (checksum >> 7);
    checksum += *source;
    eeprom_put_char(destination++, *(source++)); 
    4822:	c6 01       	movw	r24, r12
// Extensions added as part of Grbl 


void memcpy_to_eeprom_with_checksum(unsigned int destination, char *source, unsigned int size) {
  unsigned char checksum = 0;
  for(; size > 0; size--) { 
    4824:	20 97       	sbiw	r28, 0x00	; 0
    4826:	21 f7       	brne	.-56     	; 0x47f0 <memcpy_to_eeprom_with_checksum+0x16>
    checksum = (checksum << 1) || (checksum >> 7);
    checksum += *source;
    eeprom_put_char(destination++, *(source++)); 
  }
  eeprom_put_char(destination, checksum);
    4828:	6f 2d       	mov	r22, r15
    482a:	b2 df       	rcall	.-156    	; 0x4790 <eeprom_put_char>
}
    482c:	df 91       	pop	r29
    482e:	cf 91       	pop	r28
    4830:	1f 91       	pop	r17
    4832:	0f 91       	pop	r16
    4834:	ff 90       	pop	r15
    4836:	df 90       	pop	r13
    4838:	cf 90       	pop	r12
    483a:	08 95       	ret

0000483c <memcpy_from_eeprom_with_checksum>:

int memcpy_from_eeprom_with_checksum(char *destination, unsigned int source, unsigned int size) {
    483c:	df 92       	push	r13
    483e:	ef 92       	push	r14
    4840:	ff 92       	push	r15
    4842:	0f 93       	push	r16
    4844:	1f 93       	push	r17
    4846:	cf 93       	push	r28
    4848:	df 93       	push	r29
    484a:	7c 01       	movw	r14, r24
    484c:	cb 01       	movw	r24, r22
    484e:	ea 01       	movw	r28, r20
  unsigned char data, checksum = 0;
    4850:	d1 2c       	mov	r13, r1
  for(; size > 0; size--) { 
    4852:	1c c0       	rjmp	.+56     	; 0x488c <memcpy_from_eeprom_with_checksum+0x50>
    data = eeprom_get_char(source++);
    4854:	8c 01       	movw	r16, r24
    4856:	0f 5f       	subi	r16, 0xFF	; 255
    4858:	1f 4f       	sbci	r17, 0xFF	; 255
    485a:	92 df       	rcall	.-220    	; 0x4780 <eeprom_get_char>
    checksum = (checksum << 1) || (checksum >> 7);
    485c:	2d 2d       	mov	r18, r13
    485e:	30 e0       	ldi	r19, 0x00	; 0
    4860:	22 0f       	add	r18, r18
    4862:	33 1f       	adc	r19, r19
    4864:	21 15       	cp	r18, r1
    4866:	31 05       	cpc	r19, r1
    4868:	29 f4       	brne	.+10     	; 0x4874 <memcpy_from_eeprom_with_checksum+0x38>
    486a:	dd 20       	and	r13, r13
    486c:	2c f4       	brge	.+10     	; 0x4878 <memcpy_from_eeprom_with_checksum+0x3c>
    486e:	21 e0       	ldi	r18, 0x01	; 1
    4870:	30 e0       	ldi	r19, 0x00	; 0
    4872:	02 c0       	rjmp	.+4      	; 0x4878 <memcpy_from_eeprom_with_checksum+0x3c>
    4874:	21 e0       	ldi	r18, 0x01	; 1
    4876:	30 e0       	ldi	r19, 0x00	; 0
    checksum += data;    
    4878:	d8 2e       	mov	r13, r24
    487a:	d2 0e       	add	r13, r18
    *(destination++) = data; 
    487c:	f7 01       	movw	r30, r14
    487e:	80 83       	st	Z, r24
  eeprom_put_char(destination, checksum);
}

int memcpy_from_eeprom_with_checksum(char *destination, unsigned int source, unsigned int size) {
  unsigned char data, checksum = 0;
  for(; size > 0; size--) { 
    4880:	21 97       	sbiw	r28, 0x01	; 1
    data = eeprom_get_char(source++);
    4882:	c8 01       	movw	r24, r16
    checksum = (checksum << 1) || (checksum >> 7);
    checksum += data;    
    *(destination++) = data; 
    4884:	97 01       	movw	r18, r14
    4886:	2f 5f       	subi	r18, 0xFF	; 255
    4888:	3f 4f       	sbci	r19, 0xFF	; 255
    488a:	79 01       	movw	r14, r18
  eeprom_put_char(destination, checksum);
}

int memcpy_from_eeprom_with_checksum(char *destination, unsigned int source, unsigned int size) {
  unsigned char data, checksum = 0;
  for(; size > 0; size--) { 
    488c:	20 97       	sbiw	r28, 0x00	; 0
    data = eeprom_get_char(source++);
    checksum = (checksum << 1) || (checksum >> 7);
    checksum += data;    
    *(destination++) = data; 
  }
  return(checksum == eeprom_get_char(source));
    488e:	11 f7       	brne	.-60     	; 0x4854 <memcpy_from_eeprom_with_checksum+0x18>
    4890:	77 df       	rcall	.-274    	; 0x4780 <eeprom_get_char>
    4892:	91 e0       	ldi	r25, 0x01	; 1
    4894:	d8 12       	cpse	r13, r24
    4896:	90 e0       	ldi	r25, 0x00	; 0
}
    4898:	89 2f       	mov	r24, r25
    489a:	90 e0       	ldi	r25, 0x00	; 0
    489c:	df 91       	pop	r29
    489e:	cf 91       	pop	r28
    48a0:	1f 91       	pop	r17
    48a2:	0f 91       	pop	r16
    48a4:	ff 90       	pop	r15
    48a6:	ef 90       	pop	r14
    48a8:	df 90       	pop	r13
    48aa:	08 95       	ret

000048ac <settings_store_startup_line>:
    .max_travel[Z_AXIS] = (-DEFAULT_Z_MAX_TRAVEL)};


// Method to store startup lines into EEPROM
void settings_store_startup_line(uint8_t n, char *line)
{
    48ac:	1f 93       	push	r17
    48ae:	cf 93       	push	r28
    48b0:	df 93       	push	r29
    48b2:	18 2f       	mov	r17, r24
    48b4:	eb 01       	movw	r28, r22
  #ifdef FORCE_BUFFER_SYNC_DURING_EEPROM_WRITE
    protocol_buffer_synchronize(); // A startup line may contain a motion and be executing. 
    48b6:	0e 94 5a 18 	call	0x30b4	; 0x30b4 <protocol_buffer_synchronize>
  #endif
  uint32_t addr = n*(LINE_BUFFER_SIZE+1)+EEPROM_ADDR_STARTUP_BLOCK;
    48ba:	21 e0       	ldi	r18, 0x01	; 1
    48bc:	31 e0       	ldi	r19, 0x01	; 1
    48be:	12 9f       	mul	r17, r18
    48c0:	c0 01       	movw	r24, r0
    48c2:	13 9f       	mul	r17, r19
    48c4:	90 0d       	add	r25, r0
    48c6:	11 24       	eor	r1, r1
  memcpy_to_eeprom_with_checksum(addr,(char*)line, LINE_BUFFER_SIZE);
    48c8:	40 e0       	ldi	r20, 0x00	; 0
    48ca:	51 e0       	ldi	r21, 0x01	; 1
    48cc:	be 01       	movw	r22, r28
    48ce:	9d 5f       	subi	r25, 0xFD	; 253
    48d0:	84 df       	rcall	.-248    	; 0x47da <memcpy_to_eeprom_with_checksum>
}
    48d2:	df 91       	pop	r29
    48d4:	cf 91       	pop	r28
    48d6:	1f 91       	pop	r17
    48d8:	08 95       	ret

000048da <settings_store_build_info>:
// Method to store build info into EEPROM
// NOTE: This function can only be called in IDLE state.
void settings_store_build_info(char *line)
{
  // Build info can only be stored when state is IDLE.
  memcpy_to_eeprom_with_checksum(EEPROM_ADDR_BUILD_INFO,(char*)line, LINE_BUFFER_SIZE);
    48da:	40 e0       	ldi	r20, 0x00	; 0
    48dc:	51 e0       	ldi	r21, 0x01	; 1
    48de:	bc 01       	movw	r22, r24
    48e0:	8e ea       	ldi	r24, 0xAE	; 174
    48e2:	93 e0       	ldi	r25, 0x03	; 3
    48e4:	7a cf       	rjmp	.-268    	; 0x47da <memcpy_to_eeprom_with_checksum>
    48e6:	08 95       	ret

000048e8 <settings_write_coord_data>:
}


// Method to store coord data parameters into EEPROM
void settings_write_coord_data(uint8_t coord_select, float *coord_data)
{
    48e8:	0f 93       	push	r16
    48ea:	1f 93       	push	r17
    48ec:	cf 93       	push	r28
    48ee:	c8 2f       	mov	r28, r24
    48f0:	8b 01       	movw	r16, r22
  #ifdef FORCE_BUFFER_SYNC_DURING_EEPROM_WRITE
    protocol_buffer_synchronize();
    48f2:	0e 94 5a 18 	call	0x30b4	; 0x30b4 <protocol_buffer_synchronize>
  #endif
  uint32_t addr = coord_select*(sizeof(float)*N_AXIS+1) + EEPROM_ADDR_PARAMETERS;
    48f6:	2d e0       	ldi	r18, 0x0D	; 13
    48f8:	c2 9f       	mul	r28, r18
    48fa:	c0 01       	movw	r24, r0
    48fc:	11 24       	eor	r1, r1
  memcpy_to_eeprom_with_checksum(addr,(char*)coord_data, sizeof(float)*N_AXIS);
    48fe:	4c e0       	ldi	r20, 0x0C	; 12
    4900:	50 e0       	ldi	r21, 0x00	; 0
    4902:	b8 01       	movw	r22, r16
    4904:	9e 5f       	subi	r25, 0xFE	; 254
    4906:	69 df       	rcall	.-302    	; 0x47da <memcpy_to_eeprom_with_checksum>
}
    4908:	cf 91       	pop	r28
    490a:	1f 91       	pop	r17
    490c:	0f 91       	pop	r16
    490e:	08 95       	ret

00004910 <write_global_settings>:

// Method to store Grbl global settings struct and version number into EEPROM
// NOTE: This function can only be called in IDLE state.
void write_global_settings()
{
  eeprom_put_char(0, SETTINGS_VERSION);
    4910:	6a e0       	ldi	r22, 0x0A	; 10
    4912:	80 e0       	ldi	r24, 0x00	; 0
    4914:	90 e0       	ldi	r25, 0x00	; 0
    4916:	3c df       	rcall	.-392    	; 0x4790 <eeprom_put_char>
  memcpy_to_eeprom_with_checksum(EEPROM_ADDR_GLOBAL, (char*)&settings, sizeof(settings_t));
    4918:	45 e5       	ldi	r20, 0x55	; 85
    491a:	50 e0       	ldi	r21, 0x00	; 0
    491c:	69 eb       	ldi	r22, 0xB9	; 185
    491e:	7e e0       	ldi	r23, 0x0E	; 14
    4920:	81 e0       	ldi	r24, 0x01	; 1
    4922:	90 e0       	ldi	r25, 0x00	; 0
    4924:	5a cf       	rjmp	.-332    	; 0x47da <memcpy_to_eeprom_with_checksum>
    4926:	08 95       	ret

00004928 <settings_restore>:
}


// Method to restore EEPROM-saved Grbl global settings back to defaults.
void settings_restore(uint8_t restore_flag) {
    4928:	0f 93       	push	r16
    492a:	1f 93       	push	r17
    492c:	cf 93       	push	r28
    492e:	df 93       	push	r29
    4930:	cd b7       	in	r28, 0x3d	; 61
    4932:	de b7       	in	r29, 0x3e	; 62
    4934:	2c 97       	sbiw	r28, 0x0c	; 12
    4936:	0f b6       	in	r0, 0x3f	; 63
    4938:	f8 94       	cli
    493a:	de bf       	out	0x3e, r29	; 62
    493c:	0f be       	out	0x3f, r0	; 63
    493e:	cd bf       	out	0x3d, r28	; 61
    4940:	08 2f       	mov	r16, r24
  if (restore_flag & SETTINGS_RESTORE_DEFAULTS) {
    4942:	80 ff       	sbrs	r24, 0
    4944:	0a c0       	rjmp	.+20     	; 0x495a <settings_restore+0x32>
    settings = defaults;
    4946:	85 e5       	ldi	r24, 0x55	; 85
    4948:	ea ee       	ldi	r30, 0xEA	; 234
    494a:	f2 e0       	ldi	r31, 0x02	; 2
    494c:	a9 eb       	ldi	r26, 0xB9	; 185
    494e:	be e0       	ldi	r27, 0x0E	; 14
    4950:	05 90       	lpm	r0, Z+
    4952:	0d 92       	st	X+, r0
    4954:	8a 95       	dec	r24
    4956:	e1 f7       	brne	.-8      	; 0x4950 <settings_restore+0x28>
    write_global_settings();
    4958:	db df       	rcall	.-74     	; 0x4910 <write_global_settings>
  }

  if (restore_flag & SETTINGS_RESTORE_PARAMETERS) {
    495a:	01 ff       	sbrs	r16, 1
    495c:	11 c0       	rjmp	.+34     	; 0x4980 <settings_restore+0x58>
    uint8_t idx;
    float coord_data[N_AXIS];
    memset(&coord_data, 0, sizeof(coord_data));
    495e:	fe 01       	movw	r30, r28
    4960:	31 96       	adiw	r30, 0x01	; 1
    4962:	8c e0       	ldi	r24, 0x0C	; 12
    4964:	df 01       	movw	r26, r30
    4966:	1d 92       	st	X+, r1
    4968:	8a 95       	dec	r24
    496a:	e9 f7       	brne	.-6      	; 0x4966 <settings_restore+0x3e>
    for (idx=0; idx <= SETTING_INDEX_NCOORD; idx++) { settings_write_coord_data(idx, coord_data); }
    496c:	10 e0       	ldi	r17, 0x00	; 0
    496e:	06 c0       	rjmp	.+12     	; 0x497c <settings_restore+0x54>
    4970:	be 01       	movw	r22, r28
    4972:	6f 5f       	subi	r22, 0xFF	; 255
    4974:	7f 4f       	sbci	r23, 0xFF	; 255
    4976:	81 2f       	mov	r24, r17
    4978:	b7 df       	rcall	.-146    	; 0x48e8 <settings_write_coord_data>
    497a:	1f 5f       	subi	r17, 0xFF	; 255
    497c:	18 30       	cpi	r17, 0x08	; 8
    497e:	c0 f3       	brcs	.-16     	; 0x4970 <settings_restore+0x48>
  }

  if (restore_flag & SETTINGS_RESTORE_STARTUP_LINES) {
    4980:	02 ff       	sbrs	r16, 2
    4982:	10 c0       	rjmp	.+32     	; 0x49a4 <settings_restore+0x7c>
    #if N_STARTUP_LINE > 0
      eeprom_put_char(EEPROM_ADDR_STARTUP_BLOCK, 0);
    4984:	60 e0       	ldi	r22, 0x00	; 0
    4986:	80 e0       	ldi	r24, 0x00	; 0
    4988:	93 e0       	ldi	r25, 0x03	; 3
    498a:	02 df       	rcall	.-508    	; 0x4790 <eeprom_put_char>
      eeprom_put_char(EEPROM_ADDR_STARTUP_BLOCK+1, 0); // Checksum
    498c:	60 e0       	ldi	r22, 0x00	; 0
    498e:	81 e0       	ldi	r24, 0x01	; 1
    4990:	93 e0       	ldi	r25, 0x03	; 3
    4992:	fe de       	rcall	.-516    	; 0x4790 <eeprom_put_char>
    #endif
    #if N_STARTUP_LINE > 1
      eeprom_put_char(EEPROM_ADDR_STARTUP_BLOCK+(LINE_BUFFER_SIZE+1), 0);
    4994:	60 e0       	ldi	r22, 0x00	; 0
    4996:	81 e0       	ldi	r24, 0x01	; 1
    4998:	94 e0       	ldi	r25, 0x04	; 4
    499a:	fa de       	rcall	.-524    	; 0x4790 <eeprom_put_char>
      eeprom_put_char(EEPROM_ADDR_STARTUP_BLOCK+(LINE_BUFFER_SIZE+2), 0); // Checksum
    499c:	60 e0       	ldi	r22, 0x00	; 0
    499e:	82 e0       	ldi	r24, 0x02	; 2
    49a0:	94 e0       	ldi	r25, 0x04	; 4
    49a2:	f6 de       	rcall	.-532    	; 0x4790 <eeprom_put_char>
    #endif
  }

  if (restore_flag & SETTINGS_RESTORE_BUILD_INFO) {
    49a4:	03 ff       	sbrs	r16, 3
    49a6:	08 c0       	rjmp	.+16     	; 0x49b8 <settings_restore+0x90>
    eeprom_put_char(EEPROM_ADDR_BUILD_INFO , 0);
    49a8:	60 e0       	ldi	r22, 0x00	; 0
    49aa:	8e ea       	ldi	r24, 0xAE	; 174
    49ac:	93 e0       	ldi	r25, 0x03	; 3
    49ae:	f0 de       	rcall	.-544    	; 0x4790 <eeprom_put_char>
    eeprom_put_char(EEPROM_ADDR_BUILD_INFO+1 , 0); // Checksum
    49b0:	60 e0       	ldi	r22, 0x00	; 0
    49b2:	8f ea       	ldi	r24, 0xAF	; 175
    49b4:	93 e0       	ldi	r25, 0x03	; 3
    49b6:	ec de       	rcall	.-552    	; 0x4790 <eeprom_put_char>
    49b8:	2c 96       	adiw	r28, 0x0c	; 12
  }
}
    49ba:	0f b6       	in	r0, 0x3f	; 63
    49bc:	f8 94       	cli
    49be:	de bf       	out	0x3e, r29	; 62
    49c0:	0f be       	out	0x3f, r0	; 63
    49c2:	cd bf       	out	0x3d, r28	; 61
    49c4:	df 91       	pop	r29
    49c6:	cf 91       	pop	r28
    49c8:	1f 91       	pop	r17
    49ca:	0f 91       	pop	r16
    49cc:	08 95       	ret

000049ce <settings_read_startup_line>:
    49ce:	1f 93       	push	r17


// Reads startup line from EEPROM. Updated pointed line string data.
uint8_t settings_read_startup_line(uint8_t n, char *line)
{
    49d0:	cf 93       	push	r28
    49d2:	df 93       	push	r29
    49d4:	18 2f       	mov	r17, r24
    49d6:	eb 01       	movw	r28, r22
  uint32_t addr = n*(LINE_BUFFER_SIZE+1)+EEPROM_ADDR_STARTUP_BLOCK;
    49d8:	81 e0       	ldi	r24, 0x01	; 1
    49da:	91 e0       	ldi	r25, 0x01	; 1
    49dc:	18 9f       	mul	r17, r24
    49de:	b0 01       	movw	r22, r0
    49e0:	19 9f       	mul	r17, r25
    49e2:	70 0d       	add	r23, r0
    49e4:	11 24       	eor	r1, r1
    49e6:	7d 5f       	subi	r23, 0xFD	; 253
  if (!(memcpy_from_eeprom_with_checksum((char*)line, addr, LINE_BUFFER_SIZE))) {
    49e8:	40 e0       	ldi	r20, 0x00	; 0
    49ea:	51 e0       	ldi	r21, 0x01	; 1
    49ec:	ce 01       	movw	r24, r28
    49ee:	26 df       	rcall	.-436    	; 0x483c <memcpy_from_eeprom_with_checksum>
    49f0:	89 2b       	or	r24, r25
    49f2:	31 f4       	brne	.+12     	; 0x4a00 <settings_read_startup_line+0x32>
    // Reset line with default value
    line[0] = 0; // Empty line
    49f4:	18 82       	st	Y, r1
    settings_store_startup_line(n, line);
    49f6:	be 01       	movw	r22, r28
    49f8:	81 2f       	mov	r24, r17
    49fa:	58 df       	rcall	.-336    	; 0x48ac <settings_store_startup_line>
    return(false);
    49fc:	80 e0       	ldi	r24, 0x00	; 0
    49fe:	01 c0       	rjmp	.+2      	; 0x4a02 <settings_read_startup_line+0x34>
  }
  return(true);
    4a00:	81 e0       	ldi	r24, 0x01	; 1
}
    4a02:	df 91       	pop	r29
    4a04:	cf 91       	pop	r28
    4a06:	1f 91       	pop	r17
    4a08:	08 95       	ret

00004a0a <settings_read_build_info>:


// Reads startup line from EEPROM. Updated pointed line string data.
uint8_t settings_read_build_info(char *line)
{
    4a0a:	cf 93       	push	r28
    4a0c:	df 93       	push	r29
    4a0e:	ec 01       	movw	r28, r24
  if (!(memcpy_from_eeprom_with_checksum((char*)line, EEPROM_ADDR_BUILD_INFO, LINE_BUFFER_SIZE))) {
    4a10:	40 e0       	ldi	r20, 0x00	; 0
    4a12:	51 e0       	ldi	r21, 0x01	; 1
    4a14:	6e ea       	ldi	r22, 0xAE	; 174
    4a16:	73 e0       	ldi	r23, 0x03	; 3
    4a18:	11 df       	rcall	.-478    	; 0x483c <memcpy_from_eeprom_with_checksum>
    4a1a:	89 2b       	or	r24, r25
    4a1c:	29 f4       	brne	.+10     	; 0x4a28 <settings_read_build_info+0x1e>
    // Reset line with default value
    line[0] = 0; // Empty line
    4a1e:	18 82       	st	Y, r1
    settings_store_build_info(line);
    4a20:	ce 01       	movw	r24, r28
    4a22:	5b df       	rcall	.-330    	; 0x48da <settings_store_build_info>
    return(false);
    4a24:	80 e0       	ldi	r24, 0x00	; 0
    4a26:	01 c0       	rjmp	.+2      	; 0x4a2a <settings_read_build_info+0x20>
  }
  return(true);
    4a28:	81 e0       	ldi	r24, 0x01	; 1
}
    4a2a:	df 91       	pop	r29
    4a2c:	cf 91       	pop	r28
    4a2e:	08 95       	ret

00004a30 <settings_read_coord_data>:


// Read selected coordinate data from EEPROM. Updates pointed coord_data value.
uint8_t settings_read_coord_data(uint8_t coord_select, float *coord_data)
{
    4a30:	1f 93       	push	r17
    4a32:	cf 93       	push	r28
    4a34:	df 93       	push	r29
    4a36:	18 2f       	mov	r17, r24
    4a38:	eb 01       	movw	r28, r22
  uint32_t addr = coord_select*(sizeof(float)*N_AXIS+1) + EEPROM_ADDR_PARAMETERS;
    4a3a:	8d e0       	ldi	r24, 0x0D	; 13
    4a3c:	18 9f       	mul	r17, r24
    4a3e:	b0 01       	movw	r22, r0
    4a40:	11 24       	eor	r1, r1
    4a42:	7e 5f       	subi	r23, 0xFE	; 254
  if (!(memcpy_from_eeprom_with_checksum((char*)coord_data, addr, sizeof(float)*N_AXIS))) {
    4a44:	4c e0       	ldi	r20, 0x0C	; 12
    4a46:	50 e0       	ldi	r21, 0x00	; 0
    4a48:	ce 01       	movw	r24, r28
    4a4a:	f8 de       	rcall	.-528    	; 0x483c <memcpy_from_eeprom_with_checksum>
    4a4c:	89 2b       	or	r24, r25
    4a4e:	51 f4       	brne	.+20     	; 0x4a64 <settings_read_coord_data+0x34>
    // Reset with default zero vector
    clear_vector_float(coord_data);
    4a50:	8c e0       	ldi	r24, 0x0C	; 12
    4a52:	fe 01       	movw	r30, r28
    4a54:	11 92       	st	Z+, r1
    4a56:	8a 95       	dec	r24
    4a58:	e9 f7       	brne	.-6      	; 0x4a54 <settings_read_coord_data+0x24>
    settings_write_coord_data(coord_select,coord_data);
    4a5a:	be 01       	movw	r22, r28
    4a5c:	81 2f       	mov	r24, r17
    4a5e:	44 df       	rcall	.-376    	; 0x48e8 <settings_write_coord_data>
    return(false);
    4a60:	80 e0       	ldi	r24, 0x00	; 0
    4a62:	01 c0       	rjmp	.+2      	; 0x4a66 <settings_read_coord_data+0x36>
  }
  return(true);
    4a64:	81 e0       	ldi	r24, 0x01	; 1
}
    4a66:	df 91       	pop	r29
    4a68:	cf 91       	pop	r28
    4a6a:	1f 91       	pop	r17
    4a6c:	08 95       	ret

00004a6e <read_global_settings>:


// Reads Grbl global settings struct from EEPROM.
uint8_t read_global_settings() {
  // Check version-byte of eeprom
  uint8_t version = eeprom_get_char(0);
    4a6e:	80 e0       	ldi	r24, 0x00	; 0
    4a70:	90 e0       	ldi	r25, 0x00	; 0
    4a72:	86 de       	rcall	.-756    	; 0x4780 <eeprom_get_char>
  if (version == SETTINGS_VERSION) {
    4a74:	8a 30       	cpi	r24, 0x0A	; 10
    4a76:	59 f4       	brne	.+22     	; 0x4a8e <read_global_settings+0x20>
    // Read settings-record and check checksum
    if (!(memcpy_from_eeprom_with_checksum((char*)&settings, EEPROM_ADDR_GLOBAL, sizeof(settings_t)))) {
    4a78:	45 e5       	ldi	r20, 0x55	; 85
    4a7a:	50 e0       	ldi	r21, 0x00	; 0
    4a7c:	61 e0       	ldi	r22, 0x01	; 1
    4a7e:	70 e0       	ldi	r23, 0x00	; 0
    4a80:	89 eb       	ldi	r24, 0xB9	; 185
    4a82:	9e e0       	ldi	r25, 0x0E	; 14
    4a84:	db de       	rcall	.-586    	; 0x483c <memcpy_from_eeprom_with_checksum>
    4a86:	89 2b       	or	r24, r25
    4a88:	21 f4       	brne	.+8      	; 0x4a92 <read_global_settings+0x24>
      return(false);
    4a8a:	80 e0       	ldi	r24, 0x00	; 0
    4a8c:	08 95       	ret
    }
  } else {
    return(false);
    4a8e:	80 e0       	ldi	r24, 0x00	; 0
    4a90:	08 95       	ret
  }
  return(true);
    4a92:	81 e0       	ldi	r24, 0x01	; 1
}
    4a94:	08 95       	ret

00004a96 <settings_store_global_setting>:


// A helper method to set settings from command line
uint8_t settings_store_global_setting(uint8_t parameter, float value) {
    4a96:	cf 92       	push	r12
    4a98:	df 92       	push	r13
    4a9a:	ef 92       	push	r14
    4a9c:	ff 92       	push	r15
    4a9e:	cf 93       	push	r28
    4aa0:	df 93       	push	r29
    4aa2:	c8 2f       	mov	r28, r24
    4aa4:	6a 01       	movw	r12, r20
    4aa6:	7b 01       	movw	r14, r22
  if (value < 0.0) { return(STATUS_NEGATIVE_VALUE); }
    4aa8:	20 e0       	ldi	r18, 0x00	; 0
    4aaa:	30 e0       	ldi	r19, 0x00	; 0
    4aac:	a9 01       	movw	r20, r18
    4aae:	c7 01       	movw	r24, r14
    4ab0:	b6 01       	movw	r22, r12
    4ab2:	0e 94 0e 3d 	call	0x7a1c	; 0x7a1c <__cmpsf2>
    4ab6:	88 23       	and	r24, r24
    4ab8:	0c f4       	brge	.+2      	; 0x4abc <settings_store_global_setting+0x26>
    4aba:	57 c1       	rjmp	.+686    	; 0x4d6a <settings_store_global_setting+0x2d4>
  if (parameter >= AXIS_SETTINGS_START_VAL) {
    4abc:	c4 36       	cpi	r28, 0x64	; 100
    4abe:	08 f4       	brcc	.+2      	; 0x4ac2 <settings_store_global_setting+0x2c>
    4ac0:	63 c0       	rjmp	.+198    	; 0x4b88 <settings_store_global_setting+0xf2>
    // Store axis configuration. Axis numbering sequence set by AXIS_SETTING defines.
    // NOTE: Ensure the setting index corresponds to the report.c settings printout.
    parameter -= AXIS_SETTINGS_START_VAL;
    4ac2:	c4 56       	subi	r28, 0x64	; 100
    uint8_t set_idx = 0;
    4ac4:	80 e0       	ldi	r24, 0x00	; 0
    while (set_idx < AXIS_N_SETTINGS) {
    4ac6:	5c c0       	rjmp	.+184    	; 0x4b80 <settings_store_global_setting+0xea>
      if (parameter < N_AXIS) {
    4ac8:	c3 30       	cpi	r28, 0x03	; 3
    4aca:	08 f0       	brcs	.+2      	; 0x4ace <settings_store_global_setting+0x38>
    4acc:	51 c0       	rjmp	.+162    	; 0x4b70 <settings_store_global_setting+0xda>
        // Valid axis setting found.
        switch (set_idx) {
    4ace:	81 30       	cpi	r24, 0x01	; 1
    4ad0:	99 f0       	breq	.+38     	; 0x4af8 <settings_store_global_setting+0x62>
    4ad2:	28 f0       	brcs	.+10     	; 0x4ade <settings_store_global_setting+0x48>
    4ad4:	82 30       	cpi	r24, 0x02	; 2
    4ad6:	f1 f0       	breq	.+60     	; 0x4b14 <settings_store_global_setting+0x7e>
    4ad8:	83 30       	cpi	r24, 0x03	; 3
    4ada:	c1 f1       	breq	.+112    	; 0x4b4c <settings_store_global_setting+0xb6>
    4adc:	43 c1       	rjmp	.+646    	; 0x4d64 <settings_store_global_setting+0x2ce>
          case 0:
            #ifdef MAX_STEP_RATE_HZ
              if (value*settings.max_rate[parameter] > (MAX_STEP_RATE_HZ*60.0)) { return(STATUS_MAX_STEP_RATE_EXCEEDED); }
            #endif
            settings.steps_per_mm[parameter] = value;
    4ade:	ec 2f       	mov	r30, r28
    4ae0:	f0 e0       	ldi	r31, 0x00	; 0
    4ae2:	ee 0f       	add	r30, r30
    4ae4:	ff 1f       	adc	r31, r31
    4ae6:	ee 0f       	add	r30, r30
    4ae8:	ff 1f       	adc	r31, r31
    4aea:	e7 54       	subi	r30, 0x47	; 71
    4aec:	f1 4f       	sbci	r31, 0xF1	; 241
    4aee:	c0 82       	st	Z, r12
    4af0:	d1 82       	std	Z+1, r13	; 0x01
    4af2:	e2 82       	std	Z+2, r14	; 0x02
    4af4:	f3 82       	std	Z+3, r15	; 0x03
            break;
    4af6:	36 c1       	rjmp	.+620    	; 0x4d64 <settings_store_global_setting+0x2ce>
          case 1:
            #ifdef MAX_STEP_RATE_HZ
              if (value*settings.steps_per_mm[parameter] > (MAX_STEP_RATE_HZ*60.0)) {  return(STATUS_MAX_STEP_RATE_EXCEEDED); }
            #endif
            settings.max_rate[parameter] = value;
    4af8:	ec 2f       	mov	r30, r28
    4afa:	f0 e0       	ldi	r31, 0x00	; 0
    4afc:	33 96       	adiw	r30, 0x03	; 3
    4afe:	ee 0f       	add	r30, r30
    4b00:	ff 1f       	adc	r31, r31
    4b02:	ee 0f       	add	r30, r30
    4b04:	ff 1f       	adc	r31, r31
    4b06:	e7 54       	subi	r30, 0x47	; 71
    4b08:	f1 4f       	sbci	r31, 0xF1	; 241
    4b0a:	c0 82       	st	Z, r12
    4b0c:	d1 82       	std	Z+1, r13	; 0x01
    4b0e:	e2 82       	std	Z+2, r14	; 0x02
    4b10:	f3 82       	std	Z+3, r15	; 0x03
            break;
    4b12:	28 c1       	rjmp	.+592    	; 0x4d64 <settings_store_global_setting+0x2ce>
          case 2: settings.acceleration[parameter] = value*60*60; break; // Convert to mm/min^2 for grbl internal use.
    4b14:	d0 e0       	ldi	r29, 0x00	; 0
    4b16:	20 e0       	ldi	r18, 0x00	; 0
    4b18:	30 e0       	ldi	r19, 0x00	; 0
    4b1a:	40 e7       	ldi	r20, 0x70	; 112
    4b1c:	52 e4       	ldi	r21, 0x42	; 66
    4b1e:	c7 01       	movw	r24, r14
    4b20:	b6 01       	movw	r22, r12
    4b22:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
    4b26:	20 e0       	ldi	r18, 0x00	; 0
    4b28:	30 e0       	ldi	r19, 0x00	; 0
    4b2a:	40 e7       	ldi	r20, 0x70	; 112
    4b2c:	52 e4       	ldi	r21, 0x42	; 66
    4b2e:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
    4b32:	fe 01       	movw	r30, r28
    4b34:	36 96       	adiw	r30, 0x06	; 6
    4b36:	ee 0f       	add	r30, r30
    4b38:	ff 1f       	adc	r31, r31
    4b3a:	ee 0f       	add	r30, r30
    4b3c:	ff 1f       	adc	r31, r31
    4b3e:	e7 54       	subi	r30, 0x47	; 71
    4b40:	f1 4f       	sbci	r31, 0xF1	; 241
    4b42:	60 83       	st	Z, r22
    4b44:	71 83       	std	Z+1, r23	; 0x01
    4b46:	82 83       	std	Z+2, r24	; 0x02
    4b48:	93 83       	std	Z+3, r25	; 0x03
    4b4a:	0c c1       	rjmp	.+536    	; 0x4d64 <settings_store_global_setting+0x2ce>
          case 3: settings.max_travel[parameter] = -value; break;  // Store as negative for grbl internal use.
    4b4c:	ec 2f       	mov	r30, r28
    4b4e:	f0 e0       	ldi	r31, 0x00	; 0
    4b50:	f7 fa       	bst	r15, 7
    4b52:	f0 94       	com	r15
    4b54:	f7 f8       	bld	r15, 7
    4b56:	f0 94       	com	r15
    4b58:	39 96       	adiw	r30, 0x09	; 9
    4b5a:	ee 0f       	add	r30, r30
    4b5c:	ff 1f       	adc	r31, r31
    4b5e:	ee 0f       	add	r30, r30
    4b60:	ff 1f       	adc	r31, r31
    4b62:	e7 54       	subi	r30, 0x47	; 71
    4b64:	f1 4f       	sbci	r31, 0xF1	; 241
    4b66:	c0 82       	st	Z, r12
    4b68:	d1 82       	std	Z+1, r13	; 0x01
    4b6a:	e2 82       	std	Z+2, r14	; 0x02
    4b6c:	f3 82       	std	Z+3, r15	; 0x03
    4b6e:	fa c0       	rjmp	.+500    	; 0x4d64 <settings_store_global_setting+0x2ce>
        }
        break; // Exit while-loop after setting has been configured and proceed to the EEPROM write call.
      } else {
        set_idx++;
    4b70:	8f 5f       	subi	r24, 0xFF	; 255
        // If axis index greater than N_AXIS or setting index greater than number of axis settings, error out.
        if ((parameter < AXIS_SETTINGS_INCREMENT) || (set_idx == AXIS_N_SETTINGS)) { return(STATUS_INVALID_STATEMENT); }
    4b72:	ca 30       	cpi	r28, 0x0A	; 10
    4b74:	08 f4       	brcc	.+2      	; 0x4b78 <settings_store_global_setting+0xe2>
    4b76:	fb c0       	rjmp	.+502    	; 0x4d6e <settings_store_global_setting+0x2d8>
    4b78:	84 30       	cpi	r24, 0x04	; 4
    4b7a:	09 f4       	brne	.+2      	; 0x4b7e <settings_store_global_setting+0xe8>
    4b7c:	fa c0       	rjmp	.+500    	; 0x4d72 <settings_store_global_setting+0x2dc>
        parameter -= AXIS_SETTINGS_INCREMENT;
    4b7e:	ca 50       	subi	r28, 0x0A	; 10
  if (parameter >= AXIS_SETTINGS_START_VAL) {
    // Store axis configuration. Axis numbering sequence set by AXIS_SETTING defines.
    // NOTE: Ensure the setting index corresponds to the report.c settings printout.
    parameter -= AXIS_SETTINGS_START_VAL;
    uint8_t set_idx = 0;
    while (set_idx < AXIS_N_SETTINGS) {
    4b80:	84 30       	cpi	r24, 0x04	; 4
    4b82:	08 f4       	brcc	.+2      	; 0x4b86 <settings_store_global_setting+0xf0>
    4b84:	a1 cf       	rjmp	.-190    	; 0x4ac8 <settings_store_global_setting+0x32>
    4b86:	ee c0       	rjmp	.+476    	; 0x4d64 <settings_store_global_setting+0x2ce>
        parameter -= AXIS_SETTINGS_INCREMENT;
      }
    }
  } else {
    // Store non-axis Grbl settings
    uint8_t int_value = trunc(value);
    4b88:	c7 01       	movw	r24, r14
    4b8a:	b6 01       	movw	r22, r12
    4b8c:	0e 94 1a 40 	call	0x8034	; 0x8034 <trunc>
    4b90:	0e 94 82 3d 	call	0x7b04	; 0x7b04 <__fixunssfsi>
    switch(parameter) {
    4b94:	8c 2f       	mov	r24, r28
    4b96:	90 e0       	ldi	r25, 0x00	; 0
    4b98:	81 32       	cpi	r24, 0x21	; 33
    4b9a:	91 05       	cpc	r25, r1
    4b9c:	08 f0       	brcs	.+2      	; 0x4ba0 <settings_store_global_setting+0x10a>
    4b9e:	eb c0       	rjmp	.+470    	; 0x4d76 <settings_store_global_setting+0x2e0>
    4ba0:	fc 01       	movw	r30, r24
    4ba2:	88 27       	eor	r24, r24
    4ba4:	ed 5d       	subi	r30, 0xDD	; 221
    4ba6:	fe 4f       	sbci	r31, 0xFE	; 254
    4ba8:	8f 4f       	sbci	r24, 0xFF	; 255
    4baa:	0c 94 5b 40 	jmp	0x80b6	; 0x80b6 <__tablejump2__>
      case 0:
        if (int_value < 3) { return(STATUS_SETTING_STEP_PULSE_MIN); }
    4bae:	63 30       	cpi	r22, 0x03	; 3
    4bb0:	08 f4       	brcc	.+2      	; 0x4bb4 <settings_store_global_setting+0x11e>
    4bb2:	e3 c0       	rjmp	.+454    	; 0x4d7a <settings_store_global_setting+0x2e4>
        settings.pulse_microseconds = int_value; break;
    4bb4:	60 93 e9 0e 	sts	0x0EE9, r22	; 0x800ee9 <settings+0x30>
    4bb8:	d5 c0       	rjmp	.+426    	; 0x4d64 <settings_store_global_setting+0x2ce>
      case 1: settings.stepper_idle_lock_time = int_value; break;
    4bba:	60 93 ec 0e 	sts	0x0EEC, r22	; 0x800eec <settings+0x33>
    4bbe:	d2 c0       	rjmp	.+420    	; 0x4d64 <settings_store_global_setting+0x2ce>
      case 2:
        settings.step_invert_mask = int_value;
    4bc0:	60 93 ea 0e 	sts	0x0EEA, r22	; 0x800eea <settings+0x31>
        st_generate_step_dir_invert_masks(); // Regenerate step and direction port invert masks.
    4bc4:	0e 94 db 1a 	call	0x35b6	; 0x35b6 <st_generate_step_dir_invert_masks>
        break;
    4bc8:	cd c0       	rjmp	.+410    	; 0x4d64 <settings_store_global_setting+0x2ce>
      case 3:
        settings.dir_invert_mask = int_value;
    4bca:	60 93 eb 0e 	sts	0x0EEB, r22	; 0x800eeb <settings+0x32>
        st_generate_step_dir_invert_masks(); // Regenerate step and direction port invert masks.
    4bce:	0e 94 db 1a 	call	0x35b6	; 0x35b6 <st_generate_step_dir_invert_masks>
        break;
    4bd2:	c8 c0       	rjmp	.+400    	; 0x4d64 <settings_store_global_setting+0x2ce>
      case 4: // Reset to ensure change. Immediate re-init may cause problems.
        if (int_value) { settings.flags |= BITFLAG_INVERT_ST_ENABLE; }
    4bd4:	66 23       	and	r22, r22
    4bd6:	31 f0       	breq	.+12     	; 0x4be4 <settings_store_global_setting+0x14e>
    4bd8:	ee ef       	ldi	r30, 0xFE	; 254
    4bda:	fe e0       	ldi	r31, 0x0E	; 14
    4bdc:	80 81       	ld	r24, Z
    4bde:	84 60       	ori	r24, 0x04	; 4
    4be0:	80 83       	st	Z, r24
    4be2:	c0 c0       	rjmp	.+384    	; 0x4d64 <settings_store_global_setting+0x2ce>
        else { settings.flags &= ~BITFLAG_INVERT_ST_ENABLE; }
    4be4:	ee ef       	ldi	r30, 0xFE	; 254
    4be6:	fe e0       	ldi	r31, 0x0E	; 14
    4be8:	80 81       	ld	r24, Z
    4bea:	8b 7f       	andi	r24, 0xFB	; 251
    4bec:	80 83       	st	Z, r24
    4bee:	ba c0       	rjmp	.+372    	; 0x4d64 <settings_store_global_setting+0x2ce>
        break;
      case 5: // Reset to ensure change. Immediate re-init may cause problems.
        if (int_value) { settings.flags |= BITFLAG_INVERT_LIMIT_PINS; }
    4bf0:	66 23       	and	r22, r22
    4bf2:	31 f0       	breq	.+12     	; 0x4c00 <settings_store_global_setting+0x16a>
    4bf4:	ee ef       	ldi	r30, 0xFE	; 254
    4bf6:	fe e0       	ldi	r31, 0x0E	; 14
    4bf8:	80 81       	ld	r24, Z
    4bfa:	80 64       	ori	r24, 0x40	; 64
    4bfc:	80 83       	st	Z, r24
    4bfe:	b2 c0       	rjmp	.+356    	; 0x4d64 <settings_store_global_setting+0x2ce>
        else { settings.flags &= ~BITFLAG_INVERT_LIMIT_PINS; }
    4c00:	ee ef       	ldi	r30, 0xFE	; 254
    4c02:	fe e0       	ldi	r31, 0x0E	; 14
    4c04:	80 81       	ld	r24, Z
    4c06:	8f 7b       	andi	r24, 0xBF	; 191
    4c08:	80 83       	st	Z, r24
    4c0a:	ac c0       	rjmp	.+344    	; 0x4d64 <settings_store_global_setting+0x2ce>
        break;
      case 6: // Reset to ensure change. Immediate re-init may cause problems.
        if (int_value) { settings.flags |= BITFLAG_INVERT_PROBE_PIN; }
    4c0c:	66 23       	and	r22, r22
    4c0e:	31 f0       	breq	.+12     	; 0x4c1c <settings_store_global_setting+0x186>
    4c10:	ee ef       	ldi	r30, 0xFE	; 254
    4c12:	fe e0       	ldi	r31, 0x0E	; 14
    4c14:	80 81       	ld	r24, Z
    4c16:	80 68       	ori	r24, 0x80	; 128
    4c18:	80 83       	st	Z, r24
    4c1a:	05 c0       	rjmp	.+10     	; 0x4c26 <settings_store_global_setting+0x190>
        else { settings.flags &= ~BITFLAG_INVERT_PROBE_PIN; }
    4c1c:	ee ef       	ldi	r30, 0xFE	; 254
    4c1e:	fe e0       	ldi	r31, 0x0E	; 14
    4c20:	80 81       	ld	r24, Z
    4c22:	8f 77       	andi	r24, 0x7F	; 127
    4c24:	80 83       	st	Z, r24
        probe_configure_invert_mask(false);
    4c26:	80 e0       	ldi	r24, 0x00	; 0
    4c28:	0e 94 e7 32 	call	0x65ce	; 0x65ce <probe_configure_invert_mask>
        break;
    4c2c:	9b c0       	rjmp	.+310    	; 0x4d64 <settings_store_global_setting+0x2ce>
      case 10: settings.status_report_mask = int_value; break;
    4c2e:	60 93 ed 0e 	sts	0x0EED, r22	; 0x800eed <settings+0x34>
    4c32:	98 c0       	rjmp	.+304    	; 0x4d64 <settings_store_global_setting+0x2ce>
      case 11: settings.junction_deviation = value; break;
    4c34:	c0 92 ee 0e 	sts	0x0EEE, r12	; 0x800eee <settings+0x35>
    4c38:	d0 92 ef 0e 	sts	0x0EEF, r13	; 0x800eef <settings+0x36>
    4c3c:	e0 92 f0 0e 	sts	0x0EF0, r14	; 0x800ef0 <settings+0x37>
    4c40:	f0 92 f1 0e 	sts	0x0EF1, r15	; 0x800ef1 <settings+0x38>
    4c44:	8f c0       	rjmp	.+286    	; 0x4d64 <settings_store_global_setting+0x2ce>
      case 12: settings.arc_tolerance = value; break;
    4c46:	c0 92 f2 0e 	sts	0x0EF2, r12	; 0x800ef2 <settings+0x39>
    4c4a:	d0 92 f3 0e 	sts	0x0EF3, r13	; 0x800ef3 <settings+0x3a>
    4c4e:	e0 92 f4 0e 	sts	0x0EF4, r14	; 0x800ef4 <settings+0x3b>
    4c52:	f0 92 f5 0e 	sts	0x0EF5, r15	; 0x800ef5 <settings+0x3c>
    4c56:	86 c0       	rjmp	.+268    	; 0x4d64 <settings_store_global_setting+0x2ce>
      case 13:
        if (int_value) { settings.flags |= BITFLAG_REPORT_INCHES; }
    4c58:	66 23       	and	r22, r22
    4c5a:	31 f0       	breq	.+12     	; 0x4c68 <settings_store_global_setting+0x1d2>
    4c5c:	ee ef       	ldi	r30, 0xFE	; 254
    4c5e:	fe e0       	ldi	r31, 0x0E	; 14
    4c60:	80 81       	ld	r24, Z
    4c62:	81 60       	ori	r24, 0x01	; 1
    4c64:	80 83       	st	Z, r24
    4c66:	05 c0       	rjmp	.+10     	; 0x4c72 <settings_store_global_setting+0x1dc>
        else { settings.flags &= ~BITFLAG_REPORT_INCHES; }
    4c68:	ee ef       	ldi	r30, 0xFE	; 254
    4c6a:	fe e0       	ldi	r31, 0x0E	; 14
    4c6c:	80 81       	ld	r24, Z
    4c6e:	8e 7f       	andi	r24, 0xFE	; 254
    4c70:	80 83       	st	Z, r24
        system_flag_wco_change(); // Make sure WCO is immediately updated.
    4c72:	0e 94 c7 38 	call	0x718e	; 0x718e <system_flag_wco_change>
        break;
    4c76:	76 c0       	rjmp	.+236    	; 0x4d64 <settings_store_global_setting+0x2ce>
      case 20:
        if (int_value) {
    4c78:	66 23       	and	r22, r22
    4c7a:	41 f0       	breq	.+16     	; 0x4c8c <settings_store_global_setting+0x1f6>
          if (bit_isfalse(settings.flags, BITFLAG_HOMING_ENABLE)) { return(STATUS_SOFT_LIMIT_ERROR); }
    4c7c:	80 91 fe 0e 	lds	r24, 0x0EFE	; 0x800efe <settings+0x45>
    4c80:	84 ff       	sbrs	r24, 4
    4c82:	7d c0       	rjmp	.+250    	; 0x4d7e <settings_store_global_setting+0x2e8>
          settings.flags |= BITFLAG_SOFT_LIMIT_ENABLE;
    4c84:	80 62       	ori	r24, 0x20	; 32
    4c86:	80 93 fe 0e 	sts	0x0EFE, r24	; 0x800efe <settings+0x45>
    4c8a:	6c c0       	rjmp	.+216    	; 0x4d64 <settings_store_global_setting+0x2ce>
        } else { settings.flags &= ~BITFLAG_SOFT_LIMIT_ENABLE; }
    4c8c:	ee ef       	ldi	r30, 0xFE	; 254
    4c8e:	fe e0       	ldi	r31, 0x0E	; 14
    4c90:	80 81       	ld	r24, Z
    4c92:	8f 7d       	andi	r24, 0xDF	; 223
    4c94:	80 83       	st	Z, r24
    4c96:	66 c0       	rjmp	.+204    	; 0x4d64 <settings_store_global_setting+0x2ce>
        break;
      case 21:
        if (int_value) { settings.flags |= BITFLAG_HARD_LIMIT_ENABLE; }
    4c98:	66 23       	and	r22, r22
    4c9a:	31 f0       	breq	.+12     	; 0x4ca8 <settings_store_global_setting+0x212>
    4c9c:	ee ef       	ldi	r30, 0xFE	; 254
    4c9e:	fe e0       	ldi	r31, 0x0E	; 14
    4ca0:	80 81       	ld	r24, Z
    4ca2:	88 60       	ori	r24, 0x08	; 8
    4ca4:	80 83       	st	Z, r24
    4ca6:	05 c0       	rjmp	.+10     	; 0x4cb2 <settings_store_global_setting+0x21c>
        else { settings.flags &= ~BITFLAG_HARD_LIMIT_ENABLE; }
    4ca8:	ee ef       	ldi	r30, 0xFE	; 254
    4caa:	fe e0       	ldi	r31, 0x0E	; 14
    4cac:	80 81       	ld	r24, Z
    4cae:	87 7f       	andi	r24, 0xF7	; 247
    4cb0:	80 83       	st	Z, r24
        limits_init(); // Re-init to immediately change. NOTE: Nice to have but could be problematic later.
    4cb2:	0e 94 b3 2e 	call	0x5d66	; 0x5d66 <limits_init>
        break;
    4cb6:	56 c0       	rjmp	.+172    	; 0x4d64 <settings_store_global_setting+0x2ce>
      case 22:
        if (int_value) { settings.flags |= BITFLAG_HOMING_ENABLE; }
    4cb8:	66 23       	and	r22, r22
    4cba:	31 f0       	breq	.+12     	; 0x4cc8 <settings_store_global_setting+0x232>
    4cbc:	ee ef       	ldi	r30, 0xFE	; 254
    4cbe:	fe e0       	ldi	r31, 0x0E	; 14
    4cc0:	80 81       	ld	r24, Z
    4cc2:	80 61       	ori	r24, 0x10	; 16
    4cc4:	80 83       	st	Z, r24
    4cc6:	4e c0       	rjmp	.+156    	; 0x4d64 <settings_store_global_setting+0x2ce>
        else {
          settings.flags &= ~BITFLAG_HOMING_ENABLE;
    4cc8:	ee ef       	ldi	r30, 0xFE	; 254
    4cca:	fe e0       	ldi	r31, 0x0E	; 14
    4ccc:	80 81       	ld	r24, Z
          settings.flags &= ~BITFLAG_SOFT_LIMIT_ENABLE; // Force disable soft-limits.
    4cce:	8f 7c       	andi	r24, 0xCF	; 207
    4cd0:	80 83       	st	Z, r24
    4cd2:	48 c0       	rjmp	.+144    	; 0x4d64 <settings_store_global_setting+0x2ce>
        }
        break;
      case 23: settings.homing_dir_mask = int_value; break;
    4cd4:	60 93 ff 0e 	sts	0x0EFF, r22	; 0x800eff <settings+0x46>
    4cd8:	45 c0       	rjmp	.+138    	; 0x4d64 <settings_store_global_setting+0x2ce>
      case 24: settings.homing_feed_rate = value; break;
    4cda:	c0 92 00 0f 	sts	0x0F00, r12	; 0x800f00 <settings+0x47>
    4cde:	d0 92 01 0f 	sts	0x0F01, r13	; 0x800f01 <settings+0x48>
    4ce2:	e0 92 02 0f 	sts	0x0F02, r14	; 0x800f02 <settings+0x49>
    4ce6:	f0 92 03 0f 	sts	0x0F03, r15	; 0x800f03 <settings+0x4a>
    4cea:	3c c0       	rjmp	.+120    	; 0x4d64 <settings_store_global_setting+0x2ce>
      case 25: settings.homing_seek_rate = value; break;
    4cec:	c0 92 04 0f 	sts	0x0F04, r12	; 0x800f04 <settings+0x4b>
    4cf0:	d0 92 05 0f 	sts	0x0F05, r13	; 0x800f05 <settings+0x4c>
    4cf4:	e0 92 06 0f 	sts	0x0F06, r14	; 0x800f06 <settings+0x4d>
    4cf8:	f0 92 07 0f 	sts	0x0F07, r15	; 0x800f07 <settings+0x4e>
    4cfc:	33 c0       	rjmp	.+102    	; 0x4d64 <settings_store_global_setting+0x2ce>
      case 26: settings.homing_debounce_delay = int_value; break;
    4cfe:	86 2f       	mov	r24, r22
    4d00:	90 e0       	ldi	r25, 0x00	; 0
    4d02:	90 93 09 0f 	sts	0x0F09, r25	; 0x800f09 <settings+0x50>
    4d06:	80 93 08 0f 	sts	0x0F08, r24	; 0x800f08 <settings+0x4f>
    4d0a:	2c c0       	rjmp	.+88     	; 0x4d64 <settings_store_global_setting+0x2ce>
      case 27: settings.homing_pulloff = value; break;
    4d0c:	c0 92 0a 0f 	sts	0x0F0A, r12	; 0x800f0a <settings+0x51>
    4d10:	d0 92 0b 0f 	sts	0x0F0B, r13	; 0x800f0b <settings+0x52>
    4d14:	e0 92 0c 0f 	sts	0x0F0C, r14	; 0x800f0c <settings+0x53>
    4d18:	f0 92 0d 0f 	sts	0x0F0D, r15	; 0x800f0d <settings+0x54>
    4d1c:	23 c0       	rjmp	.+70     	; 0x4d64 <settings_store_global_setting+0x2ce>
      case 30: settings.rpm_max = value; spindle_init(); break; // Re-initialize spindle rpm calibration
    4d1e:	c0 92 f6 0e 	sts	0x0EF6, r12	; 0x800ef6 <settings+0x3d>
    4d22:	d0 92 f7 0e 	sts	0x0EF7, r13	; 0x800ef7 <settings+0x3e>
    4d26:	e0 92 f8 0e 	sts	0x0EF8, r14	; 0x800ef8 <settings+0x3f>
    4d2a:	f0 92 f9 0e 	sts	0x0EF9, r15	; 0x800ef9 <settings+0x40>
    4d2e:	0e 94 52 12 	call	0x24a4	; 0x24a4 <spindle_init>
    4d32:	18 c0       	rjmp	.+48     	; 0x4d64 <settings_store_global_setting+0x2ce>
      case 31: settings.rpm_min = value; spindle_init(); break; // Re-initialize spindle rpm calibration
    4d34:	c0 92 fa 0e 	sts	0x0EFA, r12	; 0x800efa <settings+0x41>
    4d38:	d0 92 fb 0e 	sts	0x0EFB, r13	; 0x800efb <settings+0x42>
    4d3c:	e0 92 fc 0e 	sts	0x0EFC, r14	; 0x800efc <settings+0x43>
    4d40:	f0 92 fd 0e 	sts	0x0EFD, r15	; 0x800efd <settings+0x44>
    4d44:	0e 94 52 12 	call	0x24a4	; 0x24a4 <spindle_init>
    4d48:	0d c0       	rjmp	.+26     	; 0x4d64 <settings_store_global_setting+0x2ce>
      case 32:
        if (int_value) { settings.flags |= BITFLAG_LASER_MODE; }
    4d4a:	66 23       	and	r22, r22
    4d4c:	31 f0       	breq	.+12     	; 0x4d5a <settings_store_global_setting+0x2c4>
    4d4e:	ee ef       	ldi	r30, 0xFE	; 254
    4d50:	fe e0       	ldi	r31, 0x0E	; 14
    4d52:	80 81       	ld	r24, Z
    4d54:	82 60       	ori	r24, 0x02	; 2
    4d56:	80 83       	st	Z, r24
    4d58:	05 c0       	rjmp	.+10     	; 0x4d64 <settings_store_global_setting+0x2ce>
        else { settings.flags &= ~BITFLAG_LASER_MODE; }
    4d5a:	ee ef       	ldi	r30, 0xFE	; 254
    4d5c:	fe e0       	ldi	r31, 0x0E	; 14
    4d5e:	80 81       	ld	r24, Z
    4d60:	8d 7f       	andi	r24, 0xFD	; 253
    4d62:	80 83       	st	Z, r24
        break;
      default:
        return(STATUS_INVALID_STATEMENT);
    }
  }
  write_global_settings();
    4d64:	d5 dd       	rcall	.-1110   	; 0x4910 <write_global_settings>
  return(STATUS_OK);
    4d66:	80 e0       	ldi	r24, 0x00	; 0
    4d68:	0b c0       	rjmp	.+22     	; 0x4d80 <settings_store_global_setting+0x2ea>
}


// A helper method to set settings from command line
uint8_t settings_store_global_setting(uint8_t parameter, float value) {
  if (value < 0.0) { return(STATUS_NEGATIVE_VALUE); }
    4d6a:	84 e0       	ldi	r24, 0x04	; 4
    4d6c:	09 c0       	rjmp	.+18     	; 0x4d80 <settings_store_global_setting+0x2ea>
        }
        break; // Exit while-loop after setting has been configured and proceed to the EEPROM write call.
      } else {
        set_idx++;
        // If axis index greater than N_AXIS or setting index greater than number of axis settings, error out.
        if ((parameter < AXIS_SETTINGS_INCREMENT) || (set_idx == AXIS_N_SETTINGS)) { return(STATUS_INVALID_STATEMENT); }
    4d6e:	83 e0       	ldi	r24, 0x03	; 3
    4d70:	07 c0       	rjmp	.+14     	; 0x4d80 <settings_store_global_setting+0x2ea>
    4d72:	83 e0       	ldi	r24, 0x03	; 3
    4d74:	05 c0       	rjmp	.+10     	; 0x4d80 <settings_store_global_setting+0x2ea>
      case 32:
        if (int_value) { settings.flags |= BITFLAG_LASER_MODE; }
        else { settings.flags &= ~BITFLAG_LASER_MODE; }
        break;
      default:
        return(STATUS_INVALID_STATEMENT);
    4d76:	83 e0       	ldi	r24, 0x03	; 3
    4d78:	03 c0       	rjmp	.+6      	; 0x4d80 <settings_store_global_setting+0x2ea>
  } else {
    // Store non-axis Grbl settings
    uint8_t int_value = trunc(value);
    switch(parameter) {
      case 0:
        if (int_value < 3) { return(STATUS_SETTING_STEP_PULSE_MIN); }
    4d7a:	86 e0       	ldi	r24, 0x06	; 6
    4d7c:	01 c0       	rjmp	.+2      	; 0x4d80 <settings_store_global_setting+0x2ea>
        else { settings.flags &= ~BITFLAG_REPORT_INCHES; }
        system_flag_wco_change(); // Make sure WCO is immediately updated.
        break;
      case 20:
        if (int_value) {
          if (bit_isfalse(settings.flags, BITFLAG_HOMING_ENABLE)) { return(STATUS_SOFT_LIMIT_ERROR); }
    4d7e:	8a e0       	ldi	r24, 0x0A	; 10
        return(STATUS_INVALID_STATEMENT);
    }
  }
  write_global_settings();
  return(STATUS_OK);
}
    4d80:	df 91       	pop	r29
    4d82:	cf 91       	pop	r28
    4d84:	ff 90       	pop	r15
    4d86:	ef 90       	pop	r14
    4d88:	df 90       	pop	r13
    4d8a:	cf 90       	pop	r12
    4d8c:	08 95       	ret

00004d8e <settings_init>:


// Initialize the config subsystem
void settings_init() {
  if(!read_global_settings()) {
    4d8e:	6f de       	rcall	.-802    	; 0x4a6e <read_global_settings>
    4d90:	81 11       	cpse	r24, r1
    4d92:	07 c0       	rjmp	.+14     	; 0x4da2 <settings_init+0x14>
    report_status_message(STATUS_SETTING_READ_FAIL);
    4d94:	87 e0       	ldi	r24, 0x07	; 7
    4d96:	0e 94 78 33 	call	0x66f0	; 0x66f0 <report_status_message>
    settings_restore(SETTINGS_RESTORE_ALL); // Force restore all EEPROM data.
    4d9a:	8f ef       	ldi	r24, 0xFF	; 255
    4d9c:	c5 dd       	rcall	.-1142   	; 0x4928 <settings_restore>
    report_grbl_settings();
    4d9e:	0c 94 dd 33 	jmp	0x67ba	; 0x67ba <report_grbl_settings>
    4da2:	08 95       	ret

00004da4 <get_step_pin_mask>:
  #ifdef DEFAULTS_RAMPS_BOARD
    if ( axis_idx == X_AXIS ) { return((1<<STEP_BIT(X_AXIS))); }
    if ( axis_idx == Y_AXIS ) { return((1<<STEP_BIT(Y_AXIS))); }
    return((1<<STEP_BIT(Z_AXIS)));
  #else
    if ( axis_idx == X_AXIS ) { return((1<<X_STEP_BIT)); }
    4da4:	88 23       	and	r24, r24
    4da6:	21 f0       	breq	.+8      	; 0x4db0 <get_step_pin_mask+0xc>
    if ( axis_idx == Y_AXIS ) { return((1<<Y_STEP_BIT)); }
    4da8:	81 30       	cpi	r24, 0x01	; 1
    4daa:	21 f4       	brne	.+8      	; 0x4db4 <get_step_pin_mask+0x10>
    4dac:	88 e0       	ldi	r24, 0x08	; 8
    4dae:	08 95       	ret
  #ifdef DEFAULTS_RAMPS_BOARD
    if ( axis_idx == X_AXIS ) { return((1<<STEP_BIT(X_AXIS))); }
    if ( axis_idx == Y_AXIS ) { return((1<<STEP_BIT(Y_AXIS))); }
    return((1<<STEP_BIT(Z_AXIS)));
  #else
    if ( axis_idx == X_AXIS ) { return((1<<X_STEP_BIT)); }
    4db0:	84 e0       	ldi	r24, 0x04	; 4
    4db2:	08 95       	ret
    if ( axis_idx == Y_AXIS ) { return((1<<Y_STEP_BIT)); }
    return((1<<Z_STEP_BIT));
    4db4:	80 e1       	ldi	r24, 0x10	; 16
  #endif // DEFAULTS_RAMPS_BOARD
}
    4db6:	08 95       	ret

00004db8 <get_direction_pin_mask>:
  #ifdef DEFAULTS_RAMPS_BOARD
    if ( axis_idx == X_AXIS ) { return((1<<DIRECTION_BIT(X_AXIS))); }
    if ( axis_idx == Y_AXIS ) { return((1<<DIRECTION_BIT(Y_AXIS))); }
    return((1<<DIRECTION_BIT(Z_AXIS)));
  #else
    if ( axis_idx == X_AXIS ) { return((1<<X_DIRECTION_BIT)); }
    4db8:	88 23       	and	r24, r24
    4dba:	21 f0       	breq	.+8      	; 0x4dc4 <get_direction_pin_mask+0xc>
    if ( axis_idx == Y_AXIS ) { return((1<<Y_DIRECTION_BIT)); }
    4dbc:	81 30       	cpi	r24, 0x01	; 1
    4dbe:	21 f4       	brne	.+8      	; 0x4dc8 <get_direction_pin_mask+0x10>
    4dc0:	80 e4       	ldi	r24, 0x40	; 64
    4dc2:	08 95       	ret
  #ifdef DEFAULTS_RAMPS_BOARD
    if ( axis_idx == X_AXIS ) { return((1<<DIRECTION_BIT(X_AXIS))); }
    if ( axis_idx == Y_AXIS ) { return((1<<DIRECTION_BIT(Y_AXIS))); }
    return((1<<DIRECTION_BIT(Z_AXIS)));
  #else
    if ( axis_idx == X_AXIS ) { return((1<<X_DIRECTION_BIT)); }
    4dc4:	80 e8       	ldi	r24, 0x80	; 128
    4dc6:	08 95       	ret
    if ( axis_idx == Y_AXIS ) { return((1<<Y_DIRECTION_BIT)); }
    return((1<<Z_DIRECTION_BIT));
    4dc8:	80 e2       	ldi	r24, 0x20	; 32
  #endif // DEFAULTS_RAMPS_BOARD
}
    4dca:	08 95       	ret

00004dcc <get_limit_pin_mask>:
     return((1<<MAX_LIMIT_BIT(Z_AXIS)));
  }
#else
  uint8_t get_limit_pin_mask(uint8_t axis_idx)
  {
    if ( axis_idx == X_AXIS ) { return((1<<X_LIMIT_BIT)); }
    4dcc:	88 23       	and	r24, r24
    4dce:	21 f0       	breq	.+8      	; 0x4dd8 <get_limit_pin_mask+0xc>
    if ( axis_idx == Y_AXIS ) { return((1<<Y_LIMIT_BIT)); }
    4dd0:	81 30       	cpi	r24, 0x01	; 1
    4dd2:	21 f4       	brne	.+8      	; 0x4ddc <get_limit_pin_mask+0x10>
    4dd4:	80 e2       	ldi	r24, 0x20	; 32
    4dd6:	08 95       	ret
     return((1<<MAX_LIMIT_BIT(Z_AXIS)));
  }
#else
  uint8_t get_limit_pin_mask(uint8_t axis_idx)
  {
    if ( axis_idx == X_AXIS ) { return((1<<X_LIMIT_BIT)); }
    4dd8:	80 e1       	ldi	r24, 0x10	; 16
    4dda:	08 95       	ret
    if ( axis_idx == Y_AXIS ) { return((1<<Y_LIMIT_BIT)); }
    return((1<<Z_LIMIT_BIT));
    4ddc:	80 e4       	ldi	r24, 0x40	; 64
  }
    4dde:	08 95       	ret

00004de0 <plan_prev_block_index>:
// NOTE: Deprecated. Not used unless classic status reports are enabled in config.h
uint8_t plan_get_block_buffer_count()
{
  if (block_buffer_head >= block_buffer_tail) { return(block_buffer_head-block_buffer_tail); }
  return(BLOCK_BUFFER_SIZE - (block_buffer_tail-block_buffer_head));
}
    4de0:	81 11       	cpse	r24, r1
    4de2:	01 c0       	rjmp	.+2      	; 0x4de6 <plan_prev_block_index+0x6>
    4de4:	84 e2       	ldi	r24, 0x24	; 36
    4de6:	81 50       	subi	r24, 0x01	; 1
    4de8:	08 95       	ret

00004dea <plan_compute_profile_parameters>:
    4dea:	8f 92       	push	r8
    4dec:	9f 92       	push	r9
    4dee:	af 92       	push	r10
    4df0:	bf 92       	push	r11
    4df2:	cf 92       	push	r12
    4df4:	df 92       	push	r13
    4df6:	ef 92       	push	r14
    4df8:	ff 92       	push	r15
    4dfa:	0f 93       	push	r16
    4dfc:	1f 93       	push	r17
    4dfe:	cf 93       	push	r28
    4e00:	df 93       	push	r29
    4e02:	ec 01       	movw	r28, r24
    4e04:	6a 01       	movw	r12, r20
    4e06:	7b 01       	movw	r14, r22
    4e08:	48 01       	movw	r8, r16
    4e0a:	59 01       	movw	r10, r18
    4e0c:	a9 01       	movw	r20, r18
    4e0e:	98 01       	movw	r18, r16
    4e10:	c7 01       	movw	r24, r14
    4e12:	b6 01       	movw	r22, r12
    4e14:	0e 94 11 3f 	call	0x7e22	; 0x7e22 <__gesf2>
    4e18:	18 16       	cp	r1, r24
    4e1a:	5c f4       	brge	.+22     	; 0x4e32 <plan_compute_profile_parameters+0x48>
    4e1c:	a5 01       	movw	r20, r10
    4e1e:	94 01       	movw	r18, r8
    4e20:	c5 01       	movw	r24, r10
    4e22:	b4 01       	movw	r22, r8
    4e24:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
    4e28:	6a 8f       	std	Y+26, r22	; 0x1a
    4e2a:	7b 8f       	std	Y+27, r23	; 0x1b
    4e2c:	8c 8f       	std	Y+28, r24	; 0x1c
    4e2e:	9d 8f       	std	Y+29, r25	; 0x1d
    4e30:	0a c0       	rjmp	.+20     	; 0x4e46 <plan_compute_profile_parameters+0x5c>
    4e32:	a7 01       	movw	r20, r14
    4e34:	96 01       	movw	r18, r12
    4e36:	c7 01       	movw	r24, r14
    4e38:	b6 01       	movw	r22, r12
    4e3a:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
    4e3e:	6a 8f       	std	Y+26, r22	; 0x1a
    4e40:	7b 8f       	std	Y+27, r23	; 0x1b
    4e42:	8c 8f       	std	Y+28, r24	; 0x1c
    4e44:	9d 8f       	std	Y+29, r25	; 0x1d
    4e46:	6a 8d       	ldd	r22, Y+26	; 0x1a
    4e48:	7b 8d       	ldd	r23, Y+27	; 0x1b
    4e4a:	8c 8d       	ldd	r24, Y+28	; 0x1c
    4e4c:	9d 8d       	ldd	r25, Y+29	; 0x1d
    4e4e:	ce a0       	ldd	r12, Y+38	; 0x26
    4e50:	df a0       	ldd	r13, Y+39	; 0x27
    4e52:	e8 a4       	ldd	r14, Y+40	; 0x28
    4e54:	f9 a4       	ldd	r15, Y+41	; 0x29
    4e56:	a7 01       	movw	r20, r14
    4e58:	96 01       	movw	r18, r12
    4e5a:	0e 94 11 3f 	call	0x7e22	; 0x7e22 <__gesf2>
    4e5e:	18 16       	cp	r1, r24
    4e60:	24 f4       	brge	.+8      	; 0x4e6a <plan_compute_profile_parameters+0x80>
    4e62:	ca 8e       	std	Y+26, r12	; 0x1a
    4e64:	db 8e       	std	Y+27, r13	; 0x1b
    4e66:	ec 8e       	std	Y+28, r14	; 0x1c
    4e68:	fd 8e       	std	Y+29, r15	; 0x1d
    4e6a:	df 91       	pop	r29
    4e6c:	cf 91       	pop	r28
    4e6e:	1f 91       	pop	r17
    4e70:	0f 91       	pop	r16
    4e72:	ff 90       	pop	r15
    4e74:	ef 90       	pop	r14
    4e76:	df 90       	pop	r13
    4e78:	cf 90       	pop	r12
    4e7a:	bf 90       	pop	r11
    4e7c:	af 90       	pop	r10
    4e7e:	9f 90       	pop	r9
    4e80:	8f 90       	pop	r8
    4e82:	08 95       	ret

00004e84 <plan_next_block_index>:
    4e84:	8f 5f       	subi	r24, 0xFF	; 255
    4e86:	84 32       	cpi	r24, 0x24	; 36
    4e88:	09 f4       	brne	.+2      	; 0x4e8c <plan_next_block_index+0x8>
    4e8a:	80 e0       	ldi	r24, 0x00	; 0
    4e8c:	08 95       	ret

00004e8e <planner_recalculate>:
    4e8e:	4f 92       	push	r4
    4e90:	5f 92       	push	r5
    4e92:	6f 92       	push	r6
    4e94:	7f 92       	push	r7
    4e96:	8f 92       	push	r8
    4e98:	9f 92       	push	r9
    4e9a:	af 92       	push	r10
    4e9c:	bf 92       	push	r11
    4e9e:	cf 92       	push	r12
    4ea0:	df 92       	push	r13
    4ea2:	ef 92       	push	r14
    4ea4:	ff 92       	push	r15
    4ea6:	0f 93       	push	r16
    4ea8:	1f 93       	push	r17
    4eaa:	cf 93       	push	r28
    4eac:	df 93       	push	r29
    4eae:	80 91 76 04 	lds	r24, 0x0476	; 0x800476 <block_buffer_head>
    4eb2:	96 df       	rcall	.-212    	; 0x4de0 <plan_prev_block_index>
    4eb4:	f8 2e       	mov	r15, r24
    4eb6:	a0 90 74 04 	lds	r10, 0x0474	; 0x800474 <block_buffer_planned>
    4eba:	8a 15       	cp	r24, r10
    4ebc:	09 f4       	brne	.+2      	; 0x4ec0 <planner_recalculate+0x32>
    4ebe:	23 c1       	rjmp	.+582    	; 0x5106 <planner_recalculate+0x278>
    4ec0:	08 2f       	mov	r16, r24
    4ec2:	10 e0       	ldi	r17, 0x00	; 0
    4ec4:	86 e3       	ldi	r24, 0x36	; 54
    4ec6:	80 9f       	mul	r24, r16
    4ec8:	e0 01       	movw	r28, r0
    4eca:	81 9f       	mul	r24, r17
    4ecc:	d0 0d       	add	r29, r0
    4ece:	11 24       	eor	r1, r1
    4ed0:	c8 58       	subi	r28, 0x88	; 136
    4ed2:	db 4f       	sbci	r29, 0xFB	; 251
    4ed4:	9a 8c       	ldd	r9, Y+26	; 0x1a
    4ed6:	8b 8c       	ldd	r8, Y+27	; 0x1b
    4ed8:	7c 8c       	ldd	r7, Y+28	; 0x1c
    4eda:	6d 8c       	ldd	r6, Y+29	; 0x1d
    4edc:	6e 8d       	ldd	r22, Y+30	; 0x1e
    4ede:	7f 8d       	ldd	r23, Y+31	; 0x1f
    4ee0:	88 a1       	ldd	r24, Y+32	; 0x20
    4ee2:	99 a1       	ldd	r25, Y+33	; 0x21
    4ee4:	9b 01       	movw	r18, r22
    4ee6:	ac 01       	movw	r20, r24
    4ee8:	0e 94 35 3c 	call	0x786a	; 0x786a <__addsf3>
    4eec:	2a a1       	ldd	r18, Y+34	; 0x22
    4eee:	3b a1       	ldd	r19, Y+35	; 0x23
    4ef0:	4c a1       	ldd	r20, Y+36	; 0x24
    4ef2:	5d a1       	ldd	r21, Y+37	; 0x25
    4ef4:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
    4ef8:	b6 2e       	mov	r11, r22
    4efa:	c7 2e       	mov	r12, r23
    4efc:	d8 2e       	mov	r13, r24
    4efe:	e9 2e       	mov	r14, r25
    4f00:	26 2f       	mov	r18, r22
    4f02:	37 2f       	mov	r19, r23
    4f04:	48 2f       	mov	r20, r24
    4f06:	59 2f       	mov	r21, r25
    4f08:	69 2d       	mov	r22, r9
    4f0a:	78 2d       	mov	r23, r8
    4f0c:	87 2d       	mov	r24, r7
    4f0e:	96 2d       	mov	r25, r6
    4f10:	0e 94 0e 3d 	call	0x7a1c	; 0x7a1c <__cmpsf2>
    4f14:	88 23       	and	r24, r24
    4f16:	24 f4       	brge	.+8      	; 0x4f20 <planner_recalculate+0x92>
    4f18:	b9 2c       	mov	r11, r9
    4f1a:	c8 2c       	mov	r12, r8
    4f1c:	d7 2c       	mov	r13, r7
    4f1e:	e6 2c       	mov	r14, r6
    4f20:	86 e3       	ldi	r24, 0x36	; 54
    4f22:	80 9f       	mul	r24, r16
    4f24:	f0 01       	movw	r30, r0
    4f26:	81 9f       	mul	r24, r17
    4f28:	f0 0d       	add	r31, r0
    4f2a:	11 24       	eor	r1, r1
    4f2c:	e8 58       	subi	r30, 0x88	; 136
    4f2e:	fb 4f       	sbci	r31, 0xFB	; 251
    4f30:	8b 2d       	mov	r24, r11
    4f32:	9c 2d       	mov	r25, r12
    4f34:	ad 2d       	mov	r26, r13
    4f36:	be 2d       	mov	r27, r14
    4f38:	86 8b       	std	Z+22, r24	; 0x16
    4f3a:	97 8b       	std	Z+23, r25	; 0x17
    4f3c:	a0 8f       	std	Z+24, r26	; 0x18
    4f3e:	b1 8f       	std	Z+25, r27	; 0x19
    4f40:	8f 2d       	mov	r24, r15
    4f42:	4e df       	rcall	.-356    	; 0x4de0 <plan_prev_block_index>
    4f44:	18 2f       	mov	r17, r24
    4f46:	a8 12       	cpse	r10, r24
    4f48:	6e c0       	rjmp	.+220    	; 0x5026 <planner_recalculate+0x198>
    4f4a:	80 91 77 04 	lds	r24, 0x0477	; 0x800477 <block_buffer_tail>
    4f4e:	18 13       	cpse	r17, r24
    4f50:	6e c0       	rjmp	.+220    	; 0x502e <planner_recalculate+0x1a0>
    4f52:	0e 94 66 1b 	call	0x36cc	; 0x36cc <st_update_plan_block_parameters>
    4f56:	6b c0       	rjmp	.+214    	; 0x502e <planner_recalculate+0x1a0>
    4f58:	c1 2e       	mov	r12, r17
    4f5a:	d1 2c       	mov	r13, r1
    4f5c:	26 e3       	ldi	r18, 0x36	; 54
    4f5e:	2c 9d       	mul	r18, r12
    4f60:	c0 01       	movw	r24, r0
    4f62:	2d 9d       	mul	r18, r13
    4f64:	90 0d       	add	r25, r0
    4f66:	11 24       	eor	r1, r1
    4f68:	9c 01       	movw	r18, r24
    4f6a:	28 58       	subi	r18, 0x88	; 136
    4f6c:	3b 4f       	sbci	r19, 0xFB	; 251
    4f6e:	79 01       	movw	r14, r18
    4f70:	81 2f       	mov	r24, r17
    4f72:	36 df       	rcall	.-404    	; 0x4de0 <plan_prev_block_index>
    4f74:	18 2f       	mov	r17, r24
    4f76:	80 91 77 04 	lds	r24, 0x0477	; 0x800477 <block_buffer_tail>
    4f7a:	18 13       	cpse	r17, r24
    4f7c:	02 c0       	rjmp	.+4      	; 0x4f82 <planner_recalculate+0xf4>
    4f7e:	0e 94 66 1b 	call	0x36cc	; 0x36cc <st_update_plan_block_parameters>
    4f82:	86 e3       	ldi	r24, 0x36	; 54
    4f84:	8c 9d       	mul	r24, r12
    4f86:	f0 01       	movw	r30, r0
    4f88:	8d 9d       	mul	r24, r13
    4f8a:	f0 0d       	add	r31, r0
    4f8c:	11 24       	eor	r1, r1
    4f8e:	e8 58       	subi	r30, 0x88	; 136
    4f90:	fb 4f       	sbci	r31, 0xFB	; 251
    4f92:	66 89       	ldd	r22, Z+22	; 0x16
    4f94:	77 89       	ldd	r23, Z+23	; 0x17
    4f96:	80 8d       	ldd	r24, Z+24	; 0x18
    4f98:	91 8d       	ldd	r25, Z+25	; 0x19
    4f9a:	82 8c       	ldd	r8, Z+26	; 0x1a
    4f9c:	93 8c       	ldd	r9, Z+27	; 0x1b
    4f9e:	a4 8c       	ldd	r10, Z+28	; 0x1c
    4fa0:	b5 8c       	ldd	r11, Z+29	; 0x1d
    4fa2:	a5 01       	movw	r20, r10
    4fa4:	94 01       	movw	r18, r8
    4fa6:	0e 94 0e 3d 	call	0x7a1c	; 0x7a1c <__cmpsf2>
    4faa:	88 23       	and	r24, r24
    4fac:	d9 f1       	breq	.+118    	; 0x5024 <planner_recalculate+0x196>
    4fae:	4e 88       	ldd	r4, Y+22	; 0x16
    4fb0:	5f 88       	ldd	r5, Y+23	; 0x17
    4fb2:	68 8c       	ldd	r6, Y+24	; 0x18
    4fb4:	79 8c       	ldd	r7, Y+25	; 0x19
    4fb6:	86 e3       	ldi	r24, 0x36	; 54
    4fb8:	8c 9d       	mul	r24, r12
    4fba:	e0 01       	movw	r28, r0
    4fbc:	8d 9d       	mul	r24, r13
    4fbe:	d0 0d       	add	r29, r0
    4fc0:	11 24       	eor	r1, r1
    4fc2:	c8 58       	subi	r28, 0x88	; 136
    4fc4:	db 4f       	sbci	r29, 0xFB	; 251
    4fc6:	6e 8d       	ldd	r22, Y+30	; 0x1e
    4fc8:	7f 8d       	ldd	r23, Y+31	; 0x1f
    4fca:	88 a1       	ldd	r24, Y+32	; 0x20
    4fcc:	99 a1       	ldd	r25, Y+33	; 0x21
    4fce:	9b 01       	movw	r18, r22
    4fd0:	ac 01       	movw	r20, r24
    4fd2:	0e 94 35 3c 	call	0x786a	; 0x786a <__addsf3>
    4fd6:	2a a1       	ldd	r18, Y+34	; 0x22
    4fd8:	3b a1       	ldd	r19, Y+35	; 0x23
    4fda:	4c a1       	ldd	r20, Y+36	; 0x24
    4fdc:	5d a1       	ldd	r21, Y+37	; 0x25
    4fde:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
    4fe2:	9b 01       	movw	r18, r22
    4fe4:	ac 01       	movw	r20, r24
    4fe6:	c3 01       	movw	r24, r6
    4fe8:	b2 01       	movw	r22, r4
    4fea:	0e 94 35 3c 	call	0x786a	; 0x786a <__addsf3>
    4fee:	2b 01       	movw	r4, r22
    4ff0:	3c 01       	movw	r6, r24
    4ff2:	9b 01       	movw	r18, r22
    4ff4:	ac 01       	movw	r20, r24
    4ff6:	c5 01       	movw	r24, r10
    4ff8:	b4 01       	movw	r22, r8
    4ffa:	0e 94 11 3f 	call	0x7e22	; 0x7e22 <__gesf2>
    4ffe:	18 16       	cp	r1, r24
    5000:	2c f4       	brge	.+10     	; 0x500c <planner_recalculate+0x17e>
    5002:	4e 8a       	std	Y+22, r4	; 0x16
    5004:	5f 8a       	std	Y+23, r5	; 0x17
    5006:	68 8e       	std	Y+24, r6	; 0x18
    5008:	79 8e       	std	Y+25, r7	; 0x19
    500a:	0c c0       	rjmp	.+24     	; 0x5024 <planner_recalculate+0x196>
    500c:	86 e3       	ldi	r24, 0x36	; 54
    500e:	8c 9d       	mul	r24, r12
    5010:	f0 01       	movw	r30, r0
    5012:	8d 9d       	mul	r24, r13
    5014:	f0 0d       	add	r31, r0
    5016:	11 24       	eor	r1, r1
    5018:	e8 58       	subi	r30, 0x88	; 136
    501a:	fb 4f       	sbci	r31, 0xFB	; 251
    501c:	86 8a       	std	Z+22, r8	; 0x16
    501e:	97 8a       	std	Z+23, r9	; 0x17
    5020:	a0 8e       	std	Z+24, r10	; 0x18
    5022:	b1 8e       	std	Z+25, r11	; 0x19
    5024:	e7 01       	movw	r28, r14
    5026:	80 91 74 04 	lds	r24, 0x0474	; 0x800474 <block_buffer_planned>
    502a:	18 13       	cpse	r17, r24
    502c:	95 cf       	rjmp	.-214    	; 0x4f58 <planner_recalculate+0xca>
    502e:	80 91 74 04 	lds	r24, 0x0474	; 0x800474 <block_buffer_planned>
    5032:	46 e3       	ldi	r20, 0x36	; 54
    5034:	84 9f       	mul	r24, r20
    5036:	90 01       	movw	r18, r0
    5038:	11 24       	eor	r1, r1
    503a:	f9 01       	movw	r30, r18
    503c:	e8 58       	subi	r30, 0x88	; 136
    503e:	fb 4f       	sbci	r31, 0xFB	; 251
    5040:	7f 01       	movw	r14, r30
    5042:	20 df       	rcall	.-448    	; 0x4e84 <plan_next_block_index>
    5044:	18 2f       	mov	r17, r24
    5046:	5b c0       	rjmp	.+182    	; 0x50fe <planner_recalculate+0x270>
    5048:	c1 2e       	mov	r12, r17
    504a:	d1 2c       	mov	r13, r1
    504c:	86 e3       	ldi	r24, 0x36	; 54
    504e:	8c 9d       	mul	r24, r12
    5050:	e0 01       	movw	r28, r0
    5052:	8d 9d       	mul	r24, r13
    5054:	d0 0d       	add	r29, r0
    5056:	11 24       	eor	r1, r1
    5058:	c8 58       	subi	r28, 0x88	; 136
    505a:	db 4f       	sbci	r29, 0xFB	; 251
    505c:	f7 01       	movw	r30, r14
    505e:	46 88       	ldd	r4, Z+22	; 0x16
    5060:	57 88       	ldd	r5, Z+23	; 0x17
    5062:	60 8c       	ldd	r6, Z+24	; 0x18
    5064:	71 8c       	ldd	r7, Z+25	; 0x19
    5066:	8e 88       	ldd	r8, Y+22	; 0x16
    5068:	9f 88       	ldd	r9, Y+23	; 0x17
    506a:	a8 8c       	ldd	r10, Y+24	; 0x18
    506c:	b9 8c       	ldd	r11, Y+25	; 0x19
    506e:	a5 01       	movw	r20, r10
    5070:	94 01       	movw	r18, r8
    5072:	c3 01       	movw	r24, r6
    5074:	b2 01       	movw	r22, r4
    5076:	0e 94 0e 3d 	call	0x7a1c	; 0x7a1c <__cmpsf2>
    507a:	88 23       	and	r24, r24
    507c:	34 f5       	brge	.+76     	; 0x50ca <planner_recalculate+0x23c>
    507e:	f7 01       	movw	r30, r14
    5080:	66 8d       	ldd	r22, Z+30	; 0x1e
    5082:	77 8d       	ldd	r23, Z+31	; 0x1f
    5084:	80 a1       	ldd	r24, Z+32	; 0x20
    5086:	91 a1       	ldd	r25, Z+33	; 0x21
    5088:	9b 01       	movw	r18, r22
    508a:	ac 01       	movw	r20, r24
    508c:	0e 94 35 3c 	call	0x786a	; 0x786a <__addsf3>
    5090:	f7 01       	movw	r30, r14
    5092:	22 a1       	ldd	r18, Z+34	; 0x22
    5094:	33 a1       	ldd	r19, Z+35	; 0x23
    5096:	44 a1       	ldd	r20, Z+36	; 0x24
    5098:	55 a1       	ldd	r21, Z+37	; 0x25
    509a:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
    509e:	9b 01       	movw	r18, r22
    50a0:	ac 01       	movw	r20, r24
    50a2:	c3 01       	movw	r24, r6
    50a4:	b2 01       	movw	r22, r4
    50a6:	0e 94 35 3c 	call	0x786a	; 0x786a <__addsf3>
    50aa:	2b 01       	movw	r4, r22
    50ac:	3c 01       	movw	r6, r24
    50ae:	9b 01       	movw	r18, r22
    50b0:	ac 01       	movw	r20, r24
    50b2:	c5 01       	movw	r24, r10
    50b4:	b4 01       	movw	r22, r8
    50b6:	0e 94 11 3f 	call	0x7e22	; 0x7e22 <__gesf2>
    50ba:	18 16       	cp	r1, r24
    50bc:	34 f4       	brge	.+12     	; 0x50ca <planner_recalculate+0x23c>
    50be:	4e 8a       	std	Y+22, r4	; 0x16
    50c0:	5f 8a       	std	Y+23, r5	; 0x17
    50c2:	68 8e       	std	Y+24, r6	; 0x18
    50c4:	79 8e       	std	Y+25, r7	; 0x19
    50c6:	10 93 74 04 	sts	0x0474, r17	; 0x800474 <block_buffer_planned>
    50ca:	86 e3       	ldi	r24, 0x36	; 54
    50cc:	8c 9d       	mul	r24, r12
    50ce:	f0 01       	movw	r30, r0
    50d0:	8d 9d       	mul	r24, r13
    50d2:	f0 0d       	add	r31, r0
    50d4:	11 24       	eor	r1, r1
    50d6:	e8 58       	subi	r30, 0x88	; 136
    50d8:	fb 4f       	sbci	r31, 0xFB	; 251
    50da:	66 89       	ldd	r22, Z+22	; 0x16
    50dc:	77 89       	ldd	r23, Z+23	; 0x17
    50de:	80 8d       	ldd	r24, Z+24	; 0x18
    50e0:	91 8d       	ldd	r25, Z+25	; 0x19
    50e2:	22 8d       	ldd	r18, Z+26	; 0x1a
    50e4:	33 8d       	ldd	r19, Z+27	; 0x1b
    50e6:	44 8d       	ldd	r20, Z+28	; 0x1c
    50e8:	55 8d       	ldd	r21, Z+29	; 0x1d
    50ea:	0e 94 0e 3d 	call	0x7a1c	; 0x7a1c <__cmpsf2>
    50ee:	81 11       	cpse	r24, r1
    50f0:	02 c0       	rjmp	.+4      	; 0x50f6 <planner_recalculate+0x268>
    50f2:	10 93 74 04 	sts	0x0474, r17	; 0x800474 <block_buffer_planned>
    50f6:	81 2f       	mov	r24, r17
    50f8:	c5 de       	rcall	.-630    	; 0x4e84 <plan_next_block_index>
    50fa:	18 2f       	mov	r17, r24
    50fc:	7e 01       	movw	r14, r28
    50fe:	80 91 76 04 	lds	r24, 0x0476	; 0x800476 <block_buffer_head>
    5102:	18 13       	cpse	r17, r24
    5104:	a1 cf       	rjmp	.-190    	; 0x5048 <planner_recalculate+0x1ba>
    5106:	df 91       	pop	r29
    5108:	cf 91       	pop	r28
    510a:	1f 91       	pop	r17
    510c:	0f 91       	pop	r16
    510e:	ff 90       	pop	r15
    5110:	ef 90       	pop	r14
    5112:	df 90       	pop	r13
    5114:	cf 90       	pop	r12
    5116:	bf 90       	pop	r11
    5118:	af 90       	pop	r10
    511a:	9f 90       	pop	r9
    511c:	8f 90       	pop	r8
    511e:	7f 90       	pop	r7
    5120:	6f 90       	pop	r6
    5122:	5f 90       	pop	r5
    5124:	4f 90       	pop	r4
    5126:	08 95       	ret

00005128 <plan_reset_buffer>:
    5128:	10 92 77 04 	sts	0x0477, r1	; 0x800477 <block_buffer_tail>
    512c:	10 92 76 04 	sts	0x0476, r1	; 0x800476 <block_buffer_head>
    5130:	81 e0       	ldi	r24, 0x01	; 1
    5132:	80 93 75 04 	sts	0x0475, r24	; 0x800475 <next_buffer_head>
    5136:	10 92 74 04 	sts	0x0474, r1	; 0x800474 <block_buffer_planned>
    513a:	08 95       	ret

0000513c <plan_reset>:
    513c:	8c e1       	ldi	r24, 0x1C	; 28
    513e:	e8 e5       	ldi	r30, 0x58	; 88
    5140:	f4 e0       	ldi	r31, 0x04	; 4
    5142:	df 01       	movw	r26, r30
    5144:	1d 92       	st	X+, r1
    5146:	8a 95       	dec	r24
    5148:	e9 f7       	brne	.-6      	; 0x5144 <plan_reset+0x8>
    514a:	ee cf       	rjmp	.-36     	; 0x5128 <plan_reset_buffer>
    514c:	08 95       	ret

0000514e <plan_discard_current_block>:
    514e:	cf 93       	push	r28
    5150:	80 91 76 04 	lds	r24, 0x0476	; 0x800476 <block_buffer_head>
    5154:	c0 91 77 04 	lds	r28, 0x0477	; 0x800477 <block_buffer_tail>
    5158:	8c 17       	cp	r24, r28
    515a:	51 f0       	breq	.+20     	; 0x5170 <plan_discard_current_block+0x22>
    515c:	8c 2f       	mov	r24, r28
    515e:	92 de       	rcall	.-732    	; 0x4e84 <plan_next_block_index>
    5160:	90 91 74 04 	lds	r25, 0x0474	; 0x800474 <block_buffer_planned>
    5164:	c9 13       	cpse	r28, r25
    5166:	02 c0       	rjmp	.+4      	; 0x516c <plan_discard_current_block+0x1e>
    5168:	80 93 74 04 	sts	0x0474, r24	; 0x800474 <block_buffer_planned>
    516c:	80 93 77 04 	sts	0x0477, r24	; 0x800477 <block_buffer_tail>
    5170:	cf 91       	pop	r28
    5172:	08 95       	ret

00005174 <plan_get_system_motion_block>:
    5174:	80 91 76 04 	lds	r24, 0x0476	; 0x800476 <block_buffer_head>
    5178:	26 e3       	ldi	r18, 0x36	; 54
    517a:	82 9f       	mul	r24, r18
    517c:	c0 01       	movw	r24, r0
    517e:	11 24       	eor	r1, r1
    5180:	88 58       	subi	r24, 0x88	; 136
    5182:	9b 4f       	sbci	r25, 0xFB	; 251
    5184:	08 95       	ret

00005186 <plan_get_current_block>:
    5186:	90 91 76 04 	lds	r25, 0x0476	; 0x800476 <block_buffer_head>
    518a:	80 91 77 04 	lds	r24, 0x0477	; 0x800477 <block_buffer_tail>
    518e:	98 17       	cp	r25, r24
    5190:	39 f0       	breq	.+14     	; 0x51a0 <plan_get_current_block+0x1a>
    5192:	26 e3       	ldi	r18, 0x36	; 54
    5194:	82 9f       	mul	r24, r18
    5196:	c0 01       	movw	r24, r0
    5198:	11 24       	eor	r1, r1
    519a:	88 58       	subi	r24, 0x88	; 136
    519c:	9b 4f       	sbci	r25, 0xFB	; 251
    519e:	08 95       	ret
    51a0:	80 e0       	ldi	r24, 0x00	; 0
    51a2:	90 e0       	ldi	r25, 0x00	; 0
    51a4:	08 95       	ret

000051a6 <plan_get_exec_block_exit_speed_sqr>:
    51a6:	80 91 77 04 	lds	r24, 0x0477	; 0x800477 <block_buffer_tail>
    51aa:	6c de       	rcall	.-808    	; 0x4e84 <plan_next_block_index>
    51ac:	90 91 76 04 	lds	r25, 0x0476	; 0x800476 <block_buffer_head>
    51b0:	89 17       	cp	r24, r25
    51b2:	59 f0       	breq	.+22     	; 0x51ca <plan_get_exec_block_exit_speed_sqr+0x24>
    51b4:	96 e3       	ldi	r25, 0x36	; 54
    51b6:	89 9f       	mul	r24, r25
    51b8:	f0 01       	movw	r30, r0
    51ba:	11 24       	eor	r1, r1
    51bc:	e8 58       	subi	r30, 0x88	; 136
    51be:	fb 4f       	sbci	r31, 0xFB	; 251
    51c0:	66 89       	ldd	r22, Z+22	; 0x16
    51c2:	77 89       	ldd	r23, Z+23	; 0x17
    51c4:	80 8d       	ldd	r24, Z+24	; 0x18
    51c6:	91 8d       	ldd	r25, Z+25	; 0x19
    51c8:	08 95       	ret
    51ca:	60 e0       	ldi	r22, 0x00	; 0
    51cc:	70 e0       	ldi	r23, 0x00	; 0
    51ce:	cb 01       	movw	r24, r22
    51d0:	08 95       	ret

000051d2 <plan_check_full_buffer>:
    51d2:	90 91 77 04 	lds	r25, 0x0477	; 0x800477 <block_buffer_tail>
    51d6:	80 91 75 04 	lds	r24, 0x0475	; 0x800475 <next_buffer_head>
    51da:	98 13       	cpse	r25, r24
    51dc:	02 c0       	rjmp	.+4      	; 0x51e2 <plan_check_full_buffer+0x10>
    51de:	81 e0       	ldi	r24, 0x01	; 1
    51e0:	08 95       	ret
    51e2:	80 e0       	ldi	r24, 0x00	; 0
    51e4:	08 95       	ret

000051e6 <plan_compute_profile_nominal_speed>:
    51e6:	bf 92       	push	r11
    51e8:	cf 92       	push	r12
    51ea:	df 92       	push	r13
    51ec:	ef 92       	push	r14
    51ee:	ff 92       	push	r15
    51f0:	0f 93       	push	r16
    51f2:	1f 93       	push	r17
    51f4:	cf 93       	push	r28
    51f6:	df 93       	push	r29
    51f8:	ec 01       	movw	r28, r24
    51fa:	ee a4       	ldd	r14, Y+46	; 0x2e
    51fc:	df a4       	ldd	r13, Y+47	; 0x2f
    51fe:	c8 a8       	ldd	r12, Y+48	; 0x30
    5200:	b9 a8       	ldd	r11, Y+49	; 0x31
    5202:	89 89       	ldd	r24, Y+17	; 0x11
    5204:	80 ff       	sbrs	r24, 0
    5206:	1a c0       	rjmp	.+52     	; 0x523c <plan_compute_profile_nominal_speed+0x56>
    5208:	60 91 19 0c 	lds	r22, 0x0C19	; 0x800c19 <sys+0x8>
    520c:	70 e0       	ldi	r23, 0x00	; 0
    520e:	80 e0       	ldi	r24, 0x00	; 0
    5210:	90 e0       	ldi	r25, 0x00	; 0
    5212:	0e 94 b0 3d 	call	0x7b60	; 0x7b60 <__floatsisf>
    5216:	2a e0       	ldi	r18, 0x0A	; 10
    5218:	37 ed       	ldi	r19, 0xD7	; 215
    521a:	43 e2       	ldi	r20, 0x23	; 35
    521c:	5c e3       	ldi	r21, 0x3C	; 60
    521e:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
    5222:	9b 01       	movw	r18, r22
    5224:	ac 01       	movw	r20, r24
    5226:	6e 2d       	mov	r22, r14
    5228:	7d 2d       	mov	r23, r13
    522a:	8c 2d       	mov	r24, r12
    522c:	9b 2d       	mov	r25, r11
    522e:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
    5232:	f6 2e       	mov	r15, r22
    5234:	07 2f       	mov	r16, r23
    5236:	18 2f       	mov	r17, r24
    5238:	c9 2f       	mov	r28, r25
    523a:	2f c0       	rjmp	.+94     	; 0x529a <plan_compute_profile_nominal_speed+0xb4>
    523c:	82 fd       	sbrc	r24, 2
    523e:	19 c0       	rjmp	.+50     	; 0x5272 <plan_compute_profile_nominal_speed+0x8c>
    5240:	60 91 18 0c 	lds	r22, 0x0C18	; 0x800c18 <sys+0x7>
    5244:	70 e0       	ldi	r23, 0x00	; 0
    5246:	80 e0       	ldi	r24, 0x00	; 0
    5248:	90 e0       	ldi	r25, 0x00	; 0
    524a:	0e 94 b0 3d 	call	0x7b60	; 0x7b60 <__floatsisf>
    524e:	2a e0       	ldi	r18, 0x0A	; 10
    5250:	37 ed       	ldi	r19, 0xD7	; 215
    5252:	43 e2       	ldi	r20, 0x23	; 35
    5254:	5c e3       	ldi	r21, 0x3C	; 60
    5256:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
    525a:	9b 01       	movw	r18, r22
    525c:	ac 01       	movw	r20, r24
    525e:	6e 2d       	mov	r22, r14
    5260:	7d 2d       	mov	r23, r13
    5262:	8c 2d       	mov	r24, r12
    5264:	9b 2d       	mov	r25, r11
    5266:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
    526a:	e6 2e       	mov	r14, r22
    526c:	d7 2e       	mov	r13, r23
    526e:	c8 2e       	mov	r12, r24
    5270:	b9 2e       	mov	r11, r25
    5272:	fa a4       	ldd	r15, Y+42	; 0x2a
    5274:	0b a5       	ldd	r16, Y+43	; 0x2b
    5276:	1c a5       	ldd	r17, Y+44	; 0x2c
    5278:	cd a5       	ldd	r28, Y+45	; 0x2d
    527a:	2f 2d       	mov	r18, r15
    527c:	30 2f       	mov	r19, r16
    527e:	41 2f       	mov	r20, r17
    5280:	5c 2f       	mov	r21, r28
    5282:	6e 2d       	mov	r22, r14
    5284:	7d 2d       	mov	r23, r13
    5286:	8c 2d       	mov	r24, r12
    5288:	9b 2d       	mov	r25, r11
    528a:	0e 94 11 3f 	call	0x7e22	; 0x7e22 <__gesf2>
    528e:	18 16       	cp	r1, r24
    5290:	24 f0       	brlt	.+8      	; 0x529a <plan_compute_profile_nominal_speed+0xb4>
    5292:	fe 2c       	mov	r15, r14
    5294:	0d 2d       	mov	r16, r13
    5296:	1c 2d       	mov	r17, r12
    5298:	cb 2d       	mov	r28, r11
    529a:	20 e0       	ldi	r18, 0x00	; 0
    529c:	30 e0       	ldi	r19, 0x00	; 0
    529e:	40 e8       	ldi	r20, 0x80	; 128
    52a0:	5f e3       	ldi	r21, 0x3F	; 63
    52a2:	6f 2d       	mov	r22, r15
    52a4:	70 2f       	mov	r23, r16
    52a6:	81 2f       	mov	r24, r17
    52a8:	9c 2f       	mov	r25, r28
    52aa:	0e 94 11 3f 	call	0x7e22	; 0x7e22 <__gesf2>
    52ae:	18 16       	cp	r1, r24
    52b0:	24 f0       	brlt	.+8      	; 0x52ba <plan_compute_profile_nominal_speed+0xd4>
    52b2:	f1 2c       	mov	r15, r1
    52b4:	00 e0       	ldi	r16, 0x00	; 0
    52b6:	10 e8       	ldi	r17, 0x80	; 128
    52b8:	cf e3       	ldi	r28, 0x3F	; 63
    52ba:	6f 2d       	mov	r22, r15
    52bc:	70 2f       	mov	r23, r16
    52be:	81 2f       	mov	r24, r17
    52c0:	9c 2f       	mov	r25, r28
    52c2:	df 91       	pop	r29
    52c4:	cf 91       	pop	r28
    52c6:	1f 91       	pop	r17
    52c8:	0f 91       	pop	r16
    52ca:	ff 90       	pop	r15
    52cc:	ef 90       	pop	r14
    52ce:	df 90       	pop	r13
    52d0:	cf 90       	pop	r12
    52d2:	bf 90       	pop	r11
    52d4:	08 95       	ret

000052d6 <plan_update_velocity_profile_parameters>:
    52d6:	7f 92       	push	r7
    52d8:	8f 92       	push	r8
    52da:	9f 92       	push	r9
    52dc:	af 92       	push	r10
    52de:	bf 92       	push	r11
    52e0:	cf 92       	push	r12
    52e2:	df 92       	push	r13
    52e4:	ef 92       	push	r14
    52e6:	ff 92       	push	r15
    52e8:	0f 93       	push	r16
    52ea:	1f 93       	push	r17
    52ec:	cf 93       	push	r28
    52ee:	df 93       	push	r29
    52f0:	f0 90 77 04 	lds	r15, 0x0477	; 0x800477 <block_buffer_tail>
    52f4:	0f 2e       	mov	r0, r31
    52f6:	f9 e9       	ldi	r31, 0x99	; 153
    52f8:	7f 2e       	mov	r7, r31
    52fa:	f0 2d       	mov	r31, r0
    52fc:	0f 2e       	mov	r0, r31
    52fe:	f6 e7       	ldi	r31, 0x76	; 118
    5300:	8f 2e       	mov	r8, r31
    5302:	f0 2d       	mov	r31, r0
    5304:	0f 2e       	mov	r0, r31
    5306:	f6 e9       	ldi	r31, 0x96	; 150
    5308:	9f 2e       	mov	r9, r31
    530a:	f0 2d       	mov	r31, r0
    530c:	0f 2e       	mov	r0, r31
    530e:	fe e7       	ldi	r31, 0x7E	; 126
    5310:	af 2e       	mov	r10, r31
    5312:	f0 2d       	mov	r31, r0
    5314:	1d c0       	rjmp	.+58     	; 0x5350 <plan_update_velocity_profile_parameters+0x7a>
    5316:	86 e3       	ldi	r24, 0x36	; 54
    5318:	f8 9e       	mul	r15, r24
    531a:	e0 01       	movw	r28, r0
    531c:	11 24       	eor	r1, r1
    531e:	c8 58       	subi	r28, 0x88	; 136
    5320:	db 4f       	sbci	r29, 0xFB	; 251
    5322:	ce 01       	movw	r24, r28
    5324:	60 df       	rcall	.-320    	; 0x51e6 <plan_compute_profile_nominal_speed>
    5326:	b6 2e       	mov	r11, r22
    5328:	c7 2e       	mov	r12, r23
    532a:	d8 2e       	mov	r13, r24
    532c:	e9 2e       	mov	r14, r25
    532e:	07 2d       	mov	r16, r7
    5330:	18 2d       	mov	r17, r8
    5332:	29 2d       	mov	r18, r9
    5334:	3a 2d       	mov	r19, r10
    5336:	46 2f       	mov	r20, r22
    5338:	57 2f       	mov	r21, r23
    533a:	68 2f       	mov	r22, r24
    533c:	79 2f       	mov	r23, r25
    533e:	ce 01       	movw	r24, r28
    5340:	54 dd       	rcall	.-1368   	; 0x4dea <plan_compute_profile_parameters>
    5342:	8f 2d       	mov	r24, r15
    5344:	9f dd       	rcall	.-1218   	; 0x4e84 <plan_next_block_index>
    5346:	f8 2e       	mov	r15, r24
    5348:	7b 2c       	mov	r7, r11
    534a:	8c 2c       	mov	r8, r12
    534c:	9d 2c       	mov	r9, r13
    534e:	ae 2c       	mov	r10, r14
    5350:	80 91 76 04 	lds	r24, 0x0476	; 0x800476 <block_buffer_head>
    5354:	f8 12       	cpse	r15, r24
    5356:	df cf       	rjmp	.-66     	; 0x5316 <plan_update_velocity_profile_parameters+0x40>
    5358:	87 2d       	mov	r24, r7
    535a:	98 2d       	mov	r25, r8
    535c:	a9 2d       	mov	r26, r9
    535e:	ba 2d       	mov	r27, r10
    5360:	80 93 70 04 	sts	0x0470, r24	; 0x800470 <pl+0x18>
    5364:	90 93 71 04 	sts	0x0471, r25	; 0x800471 <pl+0x19>
    5368:	a0 93 72 04 	sts	0x0472, r26	; 0x800472 <pl+0x1a>
    536c:	b0 93 73 04 	sts	0x0473, r27	; 0x800473 <pl+0x1b>
    5370:	df 91       	pop	r29
    5372:	cf 91       	pop	r28
    5374:	1f 91       	pop	r17
    5376:	0f 91       	pop	r16
    5378:	ff 90       	pop	r15
    537a:	ef 90       	pop	r14
    537c:	df 90       	pop	r13
    537e:	cf 90       	pop	r12
    5380:	bf 90       	pop	r11
    5382:	af 90       	pop	r10
    5384:	9f 90       	pop	r9
    5386:	8f 90       	pop	r8
    5388:	7f 90       	pop	r7
    538a:	08 95       	ret

0000538c <plan_buffer_line>:
    538c:	2f 92       	push	r2
    538e:	3f 92       	push	r3
    5390:	4f 92       	push	r4
    5392:	5f 92       	push	r5
    5394:	6f 92       	push	r6
    5396:	7f 92       	push	r7
    5398:	8f 92       	push	r8
    539a:	9f 92       	push	r9
    539c:	af 92       	push	r10
    539e:	bf 92       	push	r11
    53a0:	cf 92       	push	r12
    53a2:	df 92       	push	r13
    53a4:	ef 92       	push	r14
    53a6:	ff 92       	push	r15
    53a8:	0f 93       	push	r16
    53aa:	1f 93       	push	r17
    53ac:	cf 93       	push	r28
    53ae:	df 93       	push	r29
    53b0:	cd b7       	in	r28, 0x3d	; 61
    53b2:	de b7       	in	r29, 0x3e	; 62
    53b4:	e6 97       	sbiw	r28, 0x36	; 54
    53b6:	0f b6       	in	r0, 0x3f	; 63
    53b8:	f8 94       	cli
    53ba:	de bf       	out	0x3e, r29	; 62
    53bc:	0f be       	out	0x3f, r0	; 63
    53be:	cd bf       	out	0x3d, r28	; 61
    53c0:	5c 01       	movw	r10, r24
    53c2:	7e ab       	std	Y+54, r23	; 0x36
    53c4:	6d ab       	std	Y+53, r22	; 0x35
    53c6:	c0 90 76 04 	lds	r12, 0x0476	; 0x800476 <block_buffer_head>
    53ca:	d1 2c       	mov	r13, r1
    53cc:	86 e3       	ldi	r24, 0x36	; 54
    53ce:	8c 9d       	mul	r24, r12
    53d0:	90 01       	movw	r18, r0
    53d2:	8d 9d       	mul	r24, r13
    53d4:	30 0d       	add	r19, r0
    53d6:	11 24       	eor	r1, r1
    53d8:	a9 01       	movw	r20, r18
    53da:	48 58       	subi	r20, 0x88	; 136
    53dc:	5b 4f       	sbci	r21, 0xFB	; 251
    53de:	1a 01       	movw	r2, r20
    53e0:	fa 01       	movw	r30, r20
    53e2:	11 92       	st	Z+, r1
    53e4:	8a 95       	dec	r24
    53e6:	e9 f7       	brne	.-6      	; 0x53e2 <plan_buffer_line+0x56>
    53e8:	ed a9       	ldd	r30, Y+53	; 0x35
    53ea:	fe a9       	ldd	r31, Y+54	; 0x36
    53ec:	84 85       	ldd	r24, Z+12	; 0x0c
    53ee:	fa 01       	movw	r30, r20
    53f0:	81 8b       	std	Z+17, r24	; 0x11
    53f2:	ed a9       	ldd	r30, Y+53	; 0x35
    53f4:	fe a9       	ldd	r31, Y+54	; 0x36
    53f6:	44 81       	ldd	r20, Z+4	; 0x04
    53f8:	55 81       	ldd	r21, Z+5	; 0x05
    53fa:	66 81       	ldd	r22, Z+6	; 0x06
    53fc:	77 81       	ldd	r23, Z+7	; 0x07
    53fe:	f1 01       	movw	r30, r2
    5400:	42 ab       	std	Z+50, r20	; 0x32
    5402:	53 ab       	std	Z+51, r21	; 0x33
    5404:	64 ab       	std	Z+52, r22	; 0x34
    5406:	75 ab       	std	Z+53, r23	; 0x35
    5408:	ed a9       	ldd	r30, Y+53	; 0x35
    540a:	fe a9       	ldd	r31, Y+54	; 0x36
    540c:	40 85       	ldd	r20, Z+8	; 0x08
    540e:	51 85       	ldd	r21, Z+9	; 0x09
    5410:	62 85       	ldd	r22, Z+10	; 0x0a
    5412:	73 85       	ldd	r23, Z+11	; 0x0b
    5414:	f1 01       	movw	r30, r2
    5416:	42 8b       	std	Z+18, r20	; 0x12
    5418:	53 8b       	std	Z+19, r21	; 0x13
    541a:	64 8b       	std	Z+20, r22	; 0x14
    541c:	75 8b       	std	Z+21, r23	; 0x15
    541e:	81 ff       	sbrs	r24, 1
    5420:	0b c0       	rjmp	.+22     	; 0x5438 <plan_buffer_line+0xac>
    5422:	8c e0       	ldi	r24, 0x0C	; 12
    5424:	e1 e3       	ldi	r30, 0x31	; 49
    5426:	fc e0       	ldi	r31, 0x0C	; 12
    5428:	de 01       	movw	r26, r28
    542a:	1d 96       	adiw	r26, 0x0d	; 13
    542c:	01 90       	ld	r0, Z+
    542e:	0d 92       	st	X+, r0
    5430:	8a 95       	dec	r24
    5432:	e1 f7       	brne	.-8      	; 0x542c <plan_buffer_line+0xa0>
    5434:	91 2c       	mov	r9, r1
    5436:	9b c0       	rjmp	.+310    	; 0x556e <plan_buffer_line+0x1e2>
    5438:	8c e0       	ldi	r24, 0x0C	; 12
    543a:	e8 e5       	ldi	r30, 0x58	; 88
    543c:	f4 e0       	ldi	r31, 0x04	; 4
    543e:	de 01       	movw	r26, r28
    5440:	1d 96       	adiw	r26, 0x0d	; 13
    5442:	01 90       	ld	r0, Z+
    5444:	0d 92       	st	X+, r0
    5446:	8a 95       	dec	r24
    5448:	e1 f7       	brne	.-8      	; 0x5442 <plan_buffer_line+0xb6>
    544a:	f4 cf       	rjmp	.-24     	; 0x5434 <plan_buffer_line+0xa8>
    544c:	09 2d       	mov	r16, r9
    544e:	10 e0       	ldi	r17, 0x00	; 0
    5450:	78 01       	movw	r14, r16
    5452:	ee 0c       	add	r14, r14
    5454:	ff 1c       	adc	r15, r15
    5456:	ee 0c       	add	r14, r14
    5458:	ff 1c       	adc	r15, r15
    545a:	f5 01       	movw	r30, r10
    545c:	ee 0d       	add	r30, r14
    545e:	ff 1d       	adc	r31, r15
    5460:	60 81       	ld	r22, Z
    5462:	71 81       	ldd	r23, Z+1	; 0x01
    5464:	82 81       	ldd	r24, Z+2	; 0x02
    5466:	93 81       	ldd	r25, Z+3	; 0x03
    5468:	f7 01       	movw	r30, r14
    546a:	e7 54       	subi	r30, 0x47	; 71
    546c:	f1 4f       	sbci	r31, 0xF1	; 241
    546e:	20 81       	ld	r18, Z
    5470:	31 81       	ldd	r19, Z+1	; 0x01
    5472:	42 81       	ldd	r20, Z+2	; 0x02
    5474:	53 81       	ldd	r21, Z+3	; 0x03
    5476:	29 ab       	std	Y+49, r18	; 0x31
    5478:	3a ab       	std	Y+50, r19	; 0x32
    547a:	4b ab       	std	Y+51, r20	; 0x33
    547c:	5c ab       	std	Y+52, r21	; 0x34
    547e:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
    5482:	0e 94 1c 3f 	call	0x7e38	; 0x7e38 <lround>
    5486:	e1 e0       	ldi	r30, 0x01	; 1
    5488:	f0 e0       	ldi	r31, 0x00	; 0
    548a:	ec 0f       	add	r30, r28
    548c:	fd 1f       	adc	r31, r29
    548e:	ee 0d       	add	r30, r14
    5490:	ff 1d       	adc	r31, r15
    5492:	60 83       	st	Z, r22
    5494:	71 83       	std	Z+1, r23	; 0x01
    5496:	82 83       	std	Z+2, r24	; 0x02
    5498:	93 83       	std	Z+3, r25	; 0x03
    549a:	44 84       	ldd	r4, Z+12	; 0x0c
    549c:	55 84       	ldd	r5, Z+13	; 0x0d
    549e:	66 84       	ldd	r6, Z+14	; 0x0e
    54a0:	77 84       	ldd	r7, Z+15	; 0x0f
    54a2:	64 19       	sub	r22, r4
    54a4:	75 09       	sbc	r23, r5
    54a6:	86 09       	sbc	r24, r6
    54a8:	97 09       	sbc	r25, r7
    54aa:	9b 01       	movw	r18, r22
    54ac:	ac 01       	movw	r20, r24
    54ae:	3a f4       	brpl	.+14     	; 0x54be <plan_buffer_line+0x132>
    54b0:	22 27       	eor	r18, r18
    54b2:	33 27       	eor	r19, r19
    54b4:	a9 01       	movw	r20, r18
    54b6:	26 1b       	sub	r18, r22
    54b8:	37 0b       	sbc	r19, r23
    54ba:	48 0b       	sbc	r20, r24
    54bc:	59 0b       	sbc	r21, r25
    54be:	e6 e3       	ldi	r30, 0x36	; 54
    54c0:	ec 9d       	mul	r30, r12
    54c2:	d0 01       	movw	r26, r0
    54c4:	ed 9d       	mul	r30, r13
    54c6:	b0 0d       	add	r27, r0
    54c8:	11 24       	eor	r1, r1
    54ca:	f8 01       	movw	r30, r16
    54cc:	ee 0f       	add	r30, r30
    54ce:	ff 1f       	adc	r31, r31
    54d0:	ee 0f       	add	r30, r30
    54d2:	ff 1f       	adc	r31, r31
    54d4:	ea 0f       	add	r30, r26
    54d6:	fb 1f       	adc	r31, r27
    54d8:	e8 58       	subi	r30, 0x88	; 136
    54da:	fb 4f       	sbci	r31, 0xFB	; 251
    54dc:	20 83       	st	Z, r18
    54de:	31 83       	std	Z+1, r19	; 0x01
    54e0:	42 83       	std	Z+2, r20	; 0x02
    54e2:	53 83       	std	Z+3, r21	; 0x03
    54e4:	fd 01       	movw	r30, r26
    54e6:	e8 58       	subi	r30, 0x88	; 136
    54e8:	fb 4f       	sbci	r31, 0xFB	; 251
    54ea:	44 84       	ldd	r4, Z+12	; 0x0c
    54ec:	55 84       	ldd	r5, Z+13	; 0x0d
    54ee:	66 84       	ldd	r6, Z+14	; 0x0e
    54f0:	77 84       	ldd	r7, Z+15	; 0x0f
    54f2:	24 15       	cp	r18, r4
    54f4:	35 05       	cpc	r19, r5
    54f6:	46 05       	cpc	r20, r6
    54f8:	57 05       	cpc	r21, r7
    54fa:	10 f4       	brcc	.+4      	; 0x5500 <plan_buffer_line+0x174>
    54fc:	a3 01       	movw	r20, r6
    54fe:	92 01       	movw	r18, r4
    5500:	a6 e3       	ldi	r26, 0x36	; 54
    5502:	ac 9d       	mul	r26, r12
    5504:	f0 01       	movw	r30, r0
    5506:	ad 9d       	mul	r26, r13
    5508:	f0 0d       	add	r31, r0
    550a:	11 24       	eor	r1, r1
    550c:	e8 58       	subi	r30, 0x88	; 136
    550e:	fb 4f       	sbci	r31, 0xFB	; 251
    5510:	24 87       	std	Z+12, r18	; 0x0c
    5512:	35 87       	std	Z+13, r19	; 0x0d
    5514:	46 87       	std	Z+14, r20	; 0x0e
    5516:	57 87       	std	Z+15, r21	; 0x0f
    5518:	0e 94 b0 3d 	call	0x7b60	; 0x7b60 <__floatsisf>
    551c:	29 a9       	ldd	r18, Y+49	; 0x31
    551e:	3a a9       	ldd	r19, Y+50	; 0x32
    5520:	4b a9       	ldd	r20, Y+51	; 0x33
    5522:	5c a9       	ldd	r21, Y+52	; 0x34
    5524:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <__divsf3>
    5528:	00 0f       	add	r16, r16
    552a:	11 1f       	adc	r17, r17
    552c:	00 0f       	add	r16, r16
    552e:	11 1f       	adc	r17, r17
    5530:	e1 e0       	ldi	r30, 0x01	; 1
    5532:	f0 e0       	ldi	r31, 0x00	; 0
    5534:	ec 0f       	add	r30, r28
    5536:	fd 1f       	adc	r31, r29
    5538:	e0 0f       	add	r30, r16
    553a:	f1 1f       	adc	r31, r17
    553c:	60 8f       	std	Z+24, r22	; 0x18
    553e:	71 8f       	std	Z+25, r23	; 0x19
    5540:	82 8f       	std	Z+26, r24	; 0x1a
    5542:	93 8f       	std	Z+27, r25	; 0x1b
    5544:	20 e0       	ldi	r18, 0x00	; 0
    5546:	30 e0       	ldi	r19, 0x00	; 0
    5548:	a9 01       	movw	r20, r18
    554a:	0e 94 0e 3d 	call	0x7a1c	; 0x7a1c <__cmpsf2>
    554e:	88 23       	and	r24, r24
    5550:	6c f4       	brge	.+26     	; 0x556c <plan_buffer_line+0x1e0>
    5552:	89 2d       	mov	r24, r9
    5554:	31 dc       	rcall	.-1950   	; 0x4db8 <get_direction_pin_mask>
    5556:	96 e3       	ldi	r25, 0x36	; 54
    5558:	9c 9d       	mul	r25, r12
    555a:	f0 01       	movw	r30, r0
    555c:	9d 9d       	mul	r25, r13
    555e:	f0 0d       	add	r31, r0
    5560:	11 24       	eor	r1, r1
    5562:	e8 58       	subi	r30, 0x88	; 136
    5564:	fb 4f       	sbci	r31, 0xFB	; 251
    5566:	90 89       	ldd	r25, Z+16	; 0x10
    5568:	89 2b       	or	r24, r25
    556a:	80 8b       	std	Z+16, r24	; 0x10
    556c:	93 94       	inc	r9
    556e:	32 e0       	ldi	r19, 0x02	; 2
    5570:	39 15       	cp	r19, r9
    5572:	08 f0       	brcs	.+2      	; 0x5576 <plan_buffer_line+0x1ea>
    5574:	6b cf       	rjmp	.-298    	; 0x544c <plan_buffer_line+0xc0>
    5576:	86 e3       	ldi	r24, 0x36	; 54
    5578:	8c 9d       	mul	r24, r12
    557a:	f0 01       	movw	r30, r0
    557c:	8d 9d       	mul	r24, r13
    557e:	f0 0d       	add	r31, r0
    5580:	11 24       	eor	r1, r1
    5582:	e8 58       	subi	r30, 0x88	; 136
    5584:	fb 4f       	sbci	r31, 0xFB	; 251
    5586:	84 85       	ldd	r24, Z+12	; 0x0c
    5588:	95 85       	ldd	r25, Z+13	; 0x0d
    558a:	a6 85       	ldd	r26, Z+14	; 0x0e
    558c:	b7 85       	ldd	r27, Z+15	; 0x0f
    558e:	89 2b       	or	r24, r25
    5590:	8a 2b       	or	r24, r26
    5592:	8b 2b       	or	r24, r27
    5594:	09 f4       	brne	.+2      	; 0x5598 <plan_buffer_line+0x20c>
    5596:	87 c1       	rjmp	.+782    	; 0x58a6 <plan_buffer_line+0x51a>
    5598:	ce 01       	movw	r24, r28
    559a:	49 96       	adiw	r24, 0x19	; 25
    559c:	fa d2       	rcall	.+1524   	; 0x5b92 <convert_delta_vector_to_unit_vector>
    559e:	26 e3       	ldi	r18, 0x36	; 54
    55a0:	2c 9d       	mul	r18, r12
    55a2:	80 01       	movw	r16, r0
    55a4:	2d 9d       	mul	r18, r13
    55a6:	10 0d       	add	r17, r0
    55a8:	11 24       	eor	r1, r1
    55aa:	08 58       	subi	r16, 0x88	; 136
    55ac:	1b 4f       	sbci	r17, 0xFB	; 251
    55ae:	f8 01       	movw	r30, r16
    55b0:	62 a3       	std	Z+34, r22	; 0x22
    55b2:	73 a3       	std	Z+35, r23	; 0x23
    55b4:	84 a3       	std	Z+36, r24	; 0x24
    55b6:	95 a3       	std	Z+37, r25	; 0x25
    55b8:	be 01       	movw	r22, r28
    55ba:	67 5e       	subi	r22, 0xE7	; 231
    55bc:	7f 4f       	sbci	r23, 0xFF	; 255
    55be:	81 ed       	ldi	r24, 0xD1	; 209
    55c0:	9e e0       	ldi	r25, 0x0E	; 14
    55c2:	59 d3       	rcall	.+1714   	; 0x5c76 <limit_value_by_axis_maximum>
    55c4:	f8 01       	movw	r30, r16
    55c6:	66 8f       	std	Z+30, r22	; 0x1e
    55c8:	77 8f       	std	Z+31, r23	; 0x1f
    55ca:	80 a3       	std	Z+32, r24	; 0x20
    55cc:	91 a3       	std	Z+33, r25	; 0x21
    55ce:	be 01       	movw	r22, r28
    55d0:	67 5e       	subi	r22, 0xE7	; 231
    55d2:	7f 4f       	sbci	r23, 0xFF	; 255
    55d4:	85 ec       	ldi	r24, 0xC5	; 197
    55d6:	9e e0       	ldi	r25, 0x0E	; 14
    55d8:	4e d3       	rcall	.+1692   	; 0x5c76 <limit_value_by_axis_maximum>
    55da:	f8 01       	movw	r30, r16
    55dc:	62 a7       	std	Z+42, r22	; 0x2a
    55de:	73 a7       	std	Z+43, r23	; 0x2b
    55e0:	84 a7       	std	Z+44, r24	; 0x2c
    55e2:	95 a7       	std	Z+45, r25	; 0x2d
    55e4:	11 89       	ldd	r17, Z+17	; 0x11
    55e6:	10 ff       	sbrs	r17, 0
    55e8:	0d c0       	rjmp	.+26     	; 0x5604 <plan_buffer_line+0x278>
    55ea:	26 e3       	ldi	r18, 0x36	; 54
    55ec:	2c 9d       	mul	r18, r12
    55ee:	f0 01       	movw	r30, r0
    55f0:	2d 9d       	mul	r18, r13
    55f2:	f0 0d       	add	r31, r0
    55f4:	11 24       	eor	r1, r1
    55f6:	e8 58       	subi	r30, 0x88	; 136
    55f8:	fb 4f       	sbci	r31, 0xFB	; 251
    55fa:	66 a7       	std	Z+46, r22	; 0x2e
    55fc:	77 a7       	std	Z+47, r23	; 0x2f
    55fe:	80 ab       	std	Z+48, r24	; 0x30
    5600:	91 ab       	std	Z+49, r25	; 0x31
    5602:	20 c0       	rjmp	.+64     	; 0x5644 <plan_buffer_line+0x2b8>
    5604:	ed a9       	ldd	r30, Y+53	; 0x35
    5606:	fe a9       	ldd	r31, Y+54	; 0x36
    5608:	60 81       	ld	r22, Z
    560a:	71 81       	ldd	r23, Z+1	; 0x01
    560c:	82 81       	ldd	r24, Z+2	; 0x02
    560e:	93 81       	ldd	r25, Z+3	; 0x03
    5610:	26 e3       	ldi	r18, 0x36	; 54
    5612:	2c 9d       	mul	r18, r12
    5614:	f0 01       	movw	r30, r0
    5616:	2d 9d       	mul	r18, r13
    5618:	f0 0d       	add	r31, r0
    561a:	11 24       	eor	r1, r1
    561c:	e8 58       	subi	r30, 0x88	; 136
    561e:	fb 4f       	sbci	r31, 0xFB	; 251
    5620:	66 a7       	std	Z+46, r22	; 0x2e
    5622:	77 a7       	std	Z+47, r23	; 0x2f
    5624:	80 ab       	std	Z+48, r24	; 0x30
    5626:	91 ab       	std	Z+49, r25	; 0x31
    5628:	13 ff       	sbrs	r17, 3
    562a:	0c c0       	rjmp	.+24     	; 0x5644 <plan_buffer_line+0x2b8>
    562c:	7f 01       	movw	r14, r30
    562e:	22 a1       	ldd	r18, Z+34	; 0x22
    5630:	33 a1       	ldd	r19, Z+35	; 0x23
    5632:	44 a1       	ldd	r20, Z+36	; 0x24
    5634:	55 a1       	ldd	r21, Z+37	; 0x25
    5636:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
    563a:	f7 01       	movw	r30, r14
    563c:	66 a7       	std	Z+46, r22	; 0x2e
    563e:	77 a7       	std	Z+47, r23	; 0x2f
    5640:	80 ab       	std	Z+48, r24	; 0x30
    5642:	91 ab       	std	Z+49, r25	; 0x31
    5644:	90 91 76 04 	lds	r25, 0x0476	; 0x800476 <block_buffer_head>
    5648:	80 91 77 04 	lds	r24, 0x0477	; 0x800477 <block_buffer_tail>
    564c:	98 17       	cp	r25, r24
    564e:	11 f0       	breq	.+4      	; 0x5654 <plan_buffer_line+0x2c8>
    5650:	11 ff       	sbrs	r17, 1
    5652:	4d c0       	rjmp	.+154    	; 0x56ee <plan_buffer_line+0x362>
    5654:	86 e3       	ldi	r24, 0x36	; 54
    5656:	8c 9d       	mul	r24, r12
    5658:	f0 01       	movw	r30, r0
    565a:	8d 9d       	mul	r24, r13
    565c:	f0 0d       	add	r31, r0
    565e:	11 24       	eor	r1, r1
    5660:	e8 58       	subi	r30, 0x88	; 136
    5662:	fb 4f       	sbci	r31, 0xFB	; 251
    5664:	16 8a       	std	Z+22, r1	; 0x16
    5666:	17 8a       	std	Z+23, r1	; 0x17
    5668:	10 8e       	std	Z+24, r1	; 0x18
    566a:	11 8e       	std	Z+25, r1	; 0x19
    566c:	16 a2       	std	Z+38, r1	; 0x26
    566e:	17 a2       	std	Z+39, r1	; 0x27
    5670:	10 a6       	std	Z+40, r1	; 0x28
    5672:	11 a6       	std	Z+41, r1	; 0x29
    5674:	da c0       	rjmp	.+436    	; 0x582a <plan_buffer_line+0x49e>
    5676:	e1 2e       	mov	r14, r17
    5678:	f1 2c       	mov	r15, r1
    567a:	f7 01       	movw	r30, r14
    567c:	33 96       	adiw	r30, 0x03	; 3
    567e:	ee 0f       	add	r30, r30
    5680:	ff 1f       	adc	r31, r31
    5682:	ee 0f       	add	r30, r30
    5684:	ff 1f       	adc	r31, r31
    5686:	e8 5a       	subi	r30, 0xA8	; 168
    5688:	fb 4f       	sbci	r31, 0xFB	; 251
    568a:	80 80       	ld	r8, Z
    568c:	91 80       	ldd	r9, Z+1	; 0x01
    568e:	a2 80       	ldd	r10, Z+2	; 0x02
    5690:	b3 80       	ldd	r11, Z+3	; 0x03
    5692:	ee 0c       	add	r14, r14
    5694:	ff 1c       	adc	r15, r15
    5696:	ee 0c       	add	r14, r14
    5698:	ff 1c       	adc	r15, r15
    569a:	21 e0       	ldi	r18, 0x01	; 1
    569c:	30 e0       	ldi	r19, 0x00	; 0
    569e:	2c 0f       	add	r18, r28
    56a0:	3d 1f       	adc	r19, r29
    56a2:	e2 0e       	add	r14, r18
    56a4:	f3 1e       	adc	r15, r19
    56a6:	f7 01       	movw	r30, r14
    56a8:	40 8c       	ldd	r4, Z+24	; 0x18
    56aa:	51 8c       	ldd	r5, Z+25	; 0x19
    56ac:	62 8c       	ldd	r6, Z+26	; 0x1a
    56ae:	73 8c       	ldd	r7, Z+27	; 0x1b
    56b0:	a3 01       	movw	r20, r6
    56b2:	92 01       	movw	r18, r4
    56b4:	c5 01       	movw	r24, r10
    56b6:	b4 01       	movw	r22, r8
    56b8:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
    56bc:	9b 01       	movw	r18, r22
    56be:	ac 01       	movw	r20, r24
    56c0:	69 a9       	ldd	r22, Y+49	; 0x31
    56c2:	7a a9       	ldd	r23, Y+50	; 0x32
    56c4:	8b a9       	ldd	r24, Y+51	; 0x33
    56c6:	9c a9       	ldd	r25, Y+52	; 0x34
    56c8:	0e 94 34 3c 	call	0x7868	; 0x7868 <__subsf3>
    56cc:	69 ab       	std	Y+49, r22	; 0x31
    56ce:	7a ab       	std	Y+50, r23	; 0x32
    56d0:	8b ab       	std	Y+51, r24	; 0x33
    56d2:	9c ab       	std	Y+52, r25	; 0x34
    56d4:	a5 01       	movw	r20, r10
    56d6:	94 01       	movw	r18, r8
    56d8:	c3 01       	movw	r24, r6
    56da:	b2 01       	movw	r22, r4
    56dc:	0e 94 34 3c 	call	0x7868	; 0x7868 <__subsf3>
    56e0:	f7 01       	movw	r30, r14
    56e2:	64 a3       	std	Z+36, r22	; 0x24
    56e4:	75 a3       	std	Z+37, r23	; 0x25
    56e6:	86 a3       	std	Z+38, r24	; 0x26
    56e8:	97 a3       	std	Z+39, r25	; 0x27
    56ea:	1f 5f       	subi	r17, 0xFF	; 255
    56ec:	05 c0       	rjmp	.+10     	; 0x56f8 <plan_buffer_line+0x36c>
    56ee:	19 aa       	std	Y+49, r1	; 0x31
    56f0:	1a aa       	std	Y+50, r1	; 0x32
    56f2:	1b aa       	std	Y+51, r1	; 0x33
    56f4:	1c aa       	std	Y+52, r1	; 0x34
    56f6:	10 e0       	ldi	r17, 0x00	; 0
    56f8:	13 30       	cpi	r17, 0x03	; 3
    56fa:	08 f4       	brcc	.+2      	; 0x56fe <plan_buffer_line+0x372>
    56fc:	bc cf       	rjmp	.-136    	; 0x5676 <plan_buffer_line+0x2ea>
    56fe:	2f ee       	ldi	r18, 0xEF	; 239
    5700:	3f ef       	ldi	r19, 0xFF	; 255
    5702:	4f e7       	ldi	r20, 0x7F	; 127
    5704:	5f e3       	ldi	r21, 0x3F	; 63
    5706:	69 a9       	ldd	r22, Y+49	; 0x31
    5708:	7a a9       	ldd	r23, Y+50	; 0x32
    570a:	8b a9       	ldd	r24, Y+51	; 0x33
    570c:	9c a9       	ldd	r25, Y+52	; 0x34
    570e:	0e 94 11 3f 	call	0x7e22	; 0x7e22 <__gesf2>
    5712:	18 16       	cp	r1, r24
    5714:	6c f4       	brge	.+26     	; 0x5730 <plan_buffer_line+0x3a4>
    5716:	86 e3       	ldi	r24, 0x36	; 54
    5718:	8c 9d       	mul	r24, r12
    571a:	f0 01       	movw	r30, r0
    571c:	8d 9d       	mul	r24, r13
    571e:	f0 0d       	add	r31, r0
    5720:	11 24       	eor	r1, r1
    5722:	e8 58       	subi	r30, 0x88	; 136
    5724:	fb 4f       	sbci	r31, 0xFB	; 251
    5726:	16 a2       	std	Z+38, r1	; 0x26
    5728:	17 a2       	std	Z+39, r1	; 0x27
    572a:	10 a6       	std	Z+40, r1	; 0x28
    572c:	11 a6       	std	Z+41, r1	; 0x29
    572e:	7d c0       	rjmp	.+250    	; 0x582a <plan_buffer_line+0x49e>
    5730:	2f ee       	ldi	r18, 0xEF	; 239
    5732:	3f ef       	ldi	r19, 0xFF	; 255
    5734:	4f e7       	ldi	r20, 0x7F	; 127
    5736:	5f eb       	ldi	r21, 0xBF	; 191
    5738:	69 a9       	ldd	r22, Y+49	; 0x31
    573a:	7a a9       	ldd	r23, Y+50	; 0x32
    573c:	8b a9       	ldd	r24, Y+51	; 0x33
    573e:	9c a9       	ldd	r25, Y+52	; 0x34
    5740:	0e 94 0e 3d 	call	0x7a1c	; 0x7a1c <__cmpsf2>
    5744:	88 23       	and	r24, r24
    5746:	8c f4       	brge	.+34     	; 0x576a <plan_buffer_line+0x3de>
    5748:	86 e3       	ldi	r24, 0x36	; 54
    574a:	8c 9d       	mul	r24, r12
    574c:	f0 01       	movw	r30, r0
    574e:	8d 9d       	mul	r24, r13
    5750:	f0 0d       	add	r31, r0
    5752:	11 24       	eor	r1, r1
    5754:	e8 58       	subi	r30, 0x88	; 136
    5756:	fb 4f       	sbci	r31, 0xFB	; 251
    5758:	89 e9       	ldi	r24, 0x99	; 153
    575a:	96 e7       	ldi	r25, 0x76	; 118
    575c:	a6 e9       	ldi	r26, 0x96	; 150
    575e:	be e7       	ldi	r27, 0x7E	; 126
    5760:	86 a3       	std	Z+38, r24	; 0x26
    5762:	97 a3       	std	Z+39, r25	; 0x27
    5764:	a0 a7       	std	Z+40, r26	; 0x28
    5766:	b1 a7       	std	Z+41, r27	; 0x29
    5768:	60 c0       	rjmp	.+192    	; 0x582a <plan_buffer_line+0x49e>
    576a:	ce 01       	movw	r24, r28
    576c:	85 96       	adiw	r24, 0x25	; 37
    576e:	11 d2       	rcall	.+1058   	; 0x5b92 <convert_delta_vector_to_unit_vector>
    5770:	be 01       	movw	r22, r28
    5772:	6b 5d       	subi	r22, 0xDB	; 219
    5774:	7f 4f       	sbci	r23, 0xFF	; 255
    5776:	81 ed       	ldi	r24, 0xD1	; 209
    5778:	9e e0       	ldi	r25, 0x0E	; 14
    577a:	7d d2       	rcall	.+1274   	; 0x5c76 <limit_value_by_axis_maximum>
    577c:	4b 01       	movw	r8, r22
    577e:	5c 01       	movw	r10, r24
    5780:	29 a9       	ldd	r18, Y+49	; 0x31
    5782:	3a a9       	ldd	r19, Y+50	; 0x32
    5784:	4b a9       	ldd	r20, Y+51	; 0x33
    5786:	5c a9       	ldd	r21, Y+52	; 0x34
    5788:	60 e0       	ldi	r22, 0x00	; 0
    578a:	70 e0       	ldi	r23, 0x00	; 0
    578c:	80 e8       	ldi	r24, 0x80	; 128
    578e:	9f e3       	ldi	r25, 0x3F	; 63
    5790:	0e 94 34 3c 	call	0x7868	; 0x7868 <__subsf3>
    5794:	20 e0       	ldi	r18, 0x00	; 0
    5796:	30 e0       	ldi	r19, 0x00	; 0
    5798:	40 e0       	ldi	r20, 0x00	; 0
    579a:	5f e3       	ldi	r21, 0x3F	; 63
    579c:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
    57a0:	0e 94 d9 3f 	call	0x7fb2	; 0x7fb2 <sqrt>
    57a4:	2b 01       	movw	r4, r22
    57a6:	3c 01       	movw	r6, r24
    57a8:	20 91 ee 0e 	lds	r18, 0x0EEE	; 0x800eee <settings+0x35>
    57ac:	30 91 ef 0e 	lds	r19, 0x0EEF	; 0x800eef <settings+0x36>
    57b0:	40 91 f0 0e 	lds	r20, 0x0EF0	; 0x800ef0 <settings+0x37>
    57b4:	50 91 f1 0e 	lds	r21, 0x0EF1	; 0x800ef1 <settings+0x38>
    57b8:	c5 01       	movw	r24, r10
    57ba:	b4 01       	movw	r22, r8
    57bc:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
    57c0:	9b 01       	movw	r18, r22
    57c2:	ac 01       	movw	r20, r24
    57c4:	c3 01       	movw	r24, r6
    57c6:	b2 01       	movw	r22, r4
    57c8:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
    57cc:	4b 01       	movw	r8, r22
    57ce:	5c 01       	movw	r10, r24
    57d0:	a3 01       	movw	r20, r6
    57d2:	92 01       	movw	r18, r4
    57d4:	60 e0       	ldi	r22, 0x00	; 0
    57d6:	70 e0       	ldi	r23, 0x00	; 0
    57d8:	80 e8       	ldi	r24, 0x80	; 128
    57da:	9f e3       	ldi	r25, 0x3F	; 63
    57dc:	0e 94 34 3c 	call	0x7868	; 0x7868 <__subsf3>
    57e0:	9b 01       	movw	r18, r22
    57e2:	ac 01       	movw	r20, r24
    57e4:	c5 01       	movw	r24, r10
    57e6:	b4 01       	movw	r22, r8
    57e8:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <__divsf3>
    57ec:	e6 2e       	mov	r14, r22
    57ee:	f7 2e       	mov	r15, r23
    57f0:	08 2f       	mov	r16, r24
    57f2:	19 2f       	mov	r17, r25
    57f4:	20 e0       	ldi	r18, 0x00	; 0
    57f6:	30 e0       	ldi	r19, 0x00	; 0
    57f8:	a9 01       	movw	r20, r18
    57fa:	0e 94 0e 3d 	call	0x7a1c	; 0x7a1c <__cmpsf2>
    57fe:	88 23       	and	r24, r24
    5800:	24 f4       	brge	.+8      	; 0x580a <plan_buffer_line+0x47e>
    5802:	e1 2c       	mov	r14, r1
    5804:	f1 2c       	mov	r15, r1
    5806:	00 e0       	ldi	r16, 0x00	; 0
    5808:	10 e0       	ldi	r17, 0x00	; 0
    580a:	86 e3       	ldi	r24, 0x36	; 54
    580c:	8c 9d       	mul	r24, r12
    580e:	f0 01       	movw	r30, r0
    5810:	8d 9d       	mul	r24, r13
    5812:	f0 0d       	add	r31, r0
    5814:	11 24       	eor	r1, r1
    5816:	e8 58       	subi	r30, 0x88	; 136
    5818:	fb 4f       	sbci	r31, 0xFB	; 251
    581a:	4e 2d       	mov	r20, r14
    581c:	5f 2d       	mov	r21, r15
    581e:	60 2f       	mov	r22, r16
    5820:	71 2f       	mov	r23, r17
    5822:	46 a3       	std	Z+38, r20	; 0x26
    5824:	57 a3       	std	Z+39, r21	; 0x27
    5826:	60 a7       	std	Z+40, r22	; 0x28
    5828:	71 a7       	std	Z+41, r23	; 0x29
    582a:	86 e3       	ldi	r24, 0x36	; 54
    582c:	8c 9d       	mul	r24, r12
    582e:	f0 01       	movw	r30, r0
    5830:	8d 9d       	mul	r24, r13
    5832:	f0 0d       	add	r31, r0
    5834:	11 24       	eor	r1, r1
    5836:	e8 58       	subi	r30, 0x88	; 136
    5838:	fb 4f       	sbci	r31, 0xFB	; 251
    583a:	81 89       	ldd	r24, Z+17	; 0x11
    583c:	81 fd       	sbrc	r24, 1
    583e:	35 c0       	rjmp	.+106    	; 0x58aa <plan_buffer_line+0x51e>
    5840:	c1 01       	movw	r24, r2
    5842:	d1 dc       	rcall	.-1630   	; 0x51e6 <plan_compute_profile_nominal_speed>
    5844:	4b 01       	movw	r8, r22
    5846:	5c 01       	movw	r10, r24
    5848:	0f 2e       	mov	r0, r31
    584a:	f8 e5       	ldi	r31, 0x58	; 88
    584c:	ef 2e       	mov	r14, r31
    584e:	f4 e0       	ldi	r31, 0x04	; 4
    5850:	ff 2e       	mov	r15, r31
    5852:	f0 2d       	mov	r31, r0
    5854:	f7 01       	movw	r30, r14
    5856:	00 8d       	ldd	r16, Z+24	; 0x18
    5858:	11 8d       	ldd	r17, Z+25	; 0x19
    585a:	22 8d       	ldd	r18, Z+26	; 0x1a
    585c:	33 8d       	ldd	r19, Z+27	; 0x1b
    585e:	ab 01       	movw	r20, r22
    5860:	bc 01       	movw	r22, r24
    5862:	c1 01       	movw	r24, r2
    5864:	c2 da       	rcall	.-2684   	; 0x4dea <plan_compute_profile_parameters>
    5866:	f7 01       	movw	r30, r14
    5868:	80 8e       	std	Z+24, r8	; 0x18
    586a:	91 8e       	std	Z+25, r9	; 0x19
    586c:	a2 8e       	std	Z+26, r10	; 0x1a
    586e:	b3 8e       	std	Z+27, r11	; 0x1b
    5870:	8c e0       	ldi	r24, 0x0C	; 12
    5872:	fe 01       	movw	r30, r28
    5874:	79 96       	adiw	r30, 0x19	; 25
    5876:	a4 e6       	ldi	r26, 0x64	; 100
    5878:	b4 e0       	ldi	r27, 0x04	; 4
    587a:	01 90       	ld	r0, Z+
    587c:	0d 92       	st	X+, r0
    587e:	8a 95       	dec	r24
    5880:	e1 f7       	brne	.-8      	; 0x587a <plan_buffer_line+0x4ee>
    5882:	8c e0       	ldi	r24, 0x0C	; 12
    5884:	fe 01       	movw	r30, r28
    5886:	31 96       	adiw	r30, 0x01	; 1
    5888:	d7 01       	movw	r26, r14
    588a:	01 90       	ld	r0, Z+
    588c:	0d 92       	st	X+, r0
    588e:	8a 95       	dec	r24
    5890:	e1 f7       	brne	.-8      	; 0x588a <plan_buffer_line+0x4fe>
    5892:	80 91 75 04 	lds	r24, 0x0475	; 0x800475 <next_buffer_head>
    5896:	80 93 76 04 	sts	0x0476, r24	; 0x800476 <block_buffer_head>
    589a:	f4 da       	rcall	.-2584   	; 0x4e84 <plan_next_block_index>
    589c:	80 93 75 04 	sts	0x0475, r24	; 0x800475 <next_buffer_head>
    58a0:	f6 da       	rcall	.-2580   	; 0x4e8e <planner_recalculate>
    58a2:	81 e0       	ldi	r24, 0x01	; 1
    58a4:	03 c0       	rjmp	.+6      	; 0x58ac <plan_buffer_line+0x520>
    58a6:	80 e0       	ldi	r24, 0x00	; 0
    58a8:	01 c0       	rjmp	.+2      	; 0x58ac <plan_buffer_line+0x520>
    58aa:	81 e0       	ldi	r24, 0x01	; 1
    58ac:	e6 96       	adiw	r28, 0x36	; 54
    58ae:	0f b6       	in	r0, 0x3f	; 63
    58b0:	f8 94       	cli
    58b2:	de bf       	out	0x3e, r29	; 62
    58b4:	0f be       	out	0x3f, r0	; 63
    58b6:	cd bf       	out	0x3d, r28	; 61
    58b8:	df 91       	pop	r29
    58ba:	cf 91       	pop	r28
    58bc:	1f 91       	pop	r17
    58be:	0f 91       	pop	r16
    58c0:	ff 90       	pop	r15
    58c2:	ef 90       	pop	r14
    58c4:	df 90       	pop	r13
    58c6:	cf 90       	pop	r12
    58c8:	bf 90       	pop	r11
    58ca:	af 90       	pop	r10
    58cc:	9f 90       	pop	r9
    58ce:	8f 90       	pop	r8
    58d0:	7f 90       	pop	r7
    58d2:	6f 90       	pop	r6
    58d4:	5f 90       	pop	r5
    58d6:	4f 90       	pop	r4
    58d8:	3f 90       	pop	r3
    58da:	2f 90       	pop	r2
    58dc:	08 95       	ret

000058de <plan_sync_position>:
    58de:	20 e0       	ldi	r18, 0x00	; 0
    58e0:	15 c0       	rjmp	.+42     	; 0x590c <plan_sync_position+0x2e>
    58e2:	82 2f       	mov	r24, r18
    58e4:	90 e0       	ldi	r25, 0x00	; 0
    58e6:	88 0f       	add	r24, r24
    58e8:	99 1f       	adc	r25, r25
    58ea:	88 0f       	add	r24, r24
    58ec:	99 1f       	adc	r25, r25
    58ee:	fc 01       	movw	r30, r24
    58f0:	ef 5c       	subi	r30, 0xCF	; 207
    58f2:	f3 4f       	sbci	r31, 0xF3	; 243
    58f4:	40 81       	ld	r20, Z
    58f6:	51 81       	ldd	r21, Z+1	; 0x01
    58f8:	62 81       	ldd	r22, Z+2	; 0x02
    58fa:	73 81       	ldd	r23, Z+3	; 0x03
    58fc:	fc 01       	movw	r30, r24
    58fe:	e8 5a       	subi	r30, 0xA8	; 168
    5900:	fb 4f       	sbci	r31, 0xFB	; 251
    5902:	40 83       	st	Z, r20
    5904:	51 83       	std	Z+1, r21	; 0x01
    5906:	62 83       	std	Z+2, r22	; 0x02
    5908:	73 83       	std	Z+3, r23	; 0x03
    590a:	2f 5f       	subi	r18, 0xFF	; 255
    590c:	23 30       	cpi	r18, 0x03	; 3
    590e:	48 f3       	brcs	.-46     	; 0x58e2 <plan_sync_position+0x4>
    5910:	08 95       	ret

00005912 <plan_get_block_buffer_available>:
    5912:	90 91 76 04 	lds	r25, 0x0476	; 0x800476 <block_buffer_head>
    5916:	80 91 77 04 	lds	r24, 0x0477	; 0x800477 <block_buffer_tail>
    591a:	98 17       	cp	r25, r24
    591c:	18 f0       	brcs	.+6      	; 0x5924 <plan_get_block_buffer_available+0x12>
    591e:	89 1b       	sub	r24, r25
    5920:	8d 5d       	subi	r24, 0xDD	; 221
    5922:	08 95       	ret
    5924:	89 1b       	sub	r24, r25
    5926:	81 50       	subi	r24, 0x01	; 1
    5928:	08 95       	ret

0000592a <plan_cycle_reinitialize>:
// Re-initialize buffer plan with a partially completed block, assumed to exist at the buffer tail.
// Called after a steppers have come to a complete stop for a feed hold and the cycle is stopped.
void plan_cycle_reinitialize()
{
  // Re-plan from a complete stop. Reset planner entry speeds and buffer planned pointer.
  st_update_plan_block_parameters();
    592a:	0e 94 66 1b 	call	0x36cc	; 0x36cc <st_update_plan_block_parameters>
  block_buffer_planned = block_buffer_tail;
    592e:	80 91 77 04 	lds	r24, 0x0477	; 0x800477 <block_buffer_tail>
    5932:	80 93 74 04 	sts	0x0474, r24	; 0x800474 <block_buffer_planned>
  planner_recalculate();
    5936:	ab ca       	rjmp	.-2730   	; 0x4e8e <planner_recalculate>
    5938:	08 95       	ret

0000593a <read_float>:
    } else {
      _delay_ms(1);
      us -= 1000;
    }
  }
}
    593a:	4f 92       	push	r4
    593c:	5f 92       	push	r5
    593e:	6f 92       	push	r6
    5940:	7f 92       	push	r7
    5942:	8f 92       	push	r8
    5944:	9f 92       	push	r9
    5946:	af 92       	push	r10
    5948:	bf 92       	push	r11
    594a:	cf 92       	push	r12
    594c:	df 92       	push	r13
    594e:	ef 92       	push	r14
    5950:	ff 92       	push	r15
    5952:	0f 93       	push	r16
    5954:	1f 93       	push	r17
    5956:	cf 93       	push	r28
    5958:	df 93       	push	r29
    595a:	fc 01       	movw	r30, r24
    595c:	db 01       	movw	r26, r22
    595e:	cc 91       	ld	r28, X
    5960:	d0 e0       	ldi	r29, 0x00	; 0
    5962:	dc 01       	movw	r26, r24
    5964:	ac 0f       	add	r26, r28
    5966:	bd 1f       	adc	r27, r29
    5968:	21 96       	adiw	r28, 0x01	; 1
    596a:	c8 0f       	add	r28, r24
    596c:	d9 1f       	adc	r29, r25
    596e:	9c 91       	ld	r25, X
    5970:	9d 32       	cpi	r25, 0x2D	; 45
    5972:	31 f4       	brne	.+12     	; 0x5980 <read_float+0x46>
    5974:	ed 01       	movw	r28, r26
    5976:	22 96       	adiw	r28, 0x02	; 2
    5978:	11 96       	adiw	r26, 0x01	; 1
    597a:	9c 91       	ld	r25, X
    597c:	01 e0       	ldi	r16, 0x01	; 1
    597e:	09 c0       	rjmp	.+18     	; 0x5992 <read_float+0x58>
    5980:	9b 32       	cpi	r25, 0x2B	; 43
    5982:	31 f4       	brne	.+12     	; 0x5990 <read_float+0x56>
    5984:	ed 01       	movw	r28, r26
    5986:	22 96       	adiw	r28, 0x02	; 2
    5988:	11 96       	adiw	r26, 0x01	; 1
    598a:	9c 91       	ld	r25, X
    598c:	00 e0       	ldi	r16, 0x00	; 0
    598e:	01 c0       	rjmp	.+2      	; 0x5992 <read_float+0x58>
    5990:	00 e0       	ldi	r16, 0x00	; 0
    5992:	80 e0       	ldi	r24, 0x00	; 0
    5994:	20 e0       	ldi	r18, 0x00	; 0
    5996:	10 e0       	ldi	r17, 0x00	; 0
    5998:	41 2c       	mov	r4, r1
    599a:	51 2c       	mov	r5, r1
    599c:	32 01       	movw	r6, r4
    599e:	90 53       	subi	r25, 0x30	; 48
    59a0:	9a 30       	cpi	r25, 0x0A	; 10
    59a2:	10 f5       	brcc	.+68     	; 0x59e8 <read_float+0xae>
    59a4:	2f 5f       	subi	r18, 0xFF	; 255
    59a6:	29 30       	cpi	r18, 0x09	; 9
    59a8:	d8 f4       	brcc	.+54     	; 0x59e0 <read_float+0xa6>
    59aa:	81 11       	cpse	r24, r1
    59ac:	11 50       	subi	r17, 0x01	; 1
    59ae:	53 01       	movw	r10, r6
    59b0:	42 01       	movw	r8, r4
    59b2:	88 0c       	add	r8, r8
    59b4:	99 1c       	adc	r9, r9
    59b6:	aa 1c       	adc	r10, r10
    59b8:	bb 1c       	adc	r11, r11
    59ba:	88 0c       	add	r8, r8
    59bc:	99 1c       	adc	r9, r9
    59be:	aa 1c       	adc	r10, r10
    59c0:	bb 1c       	adc	r11, r11
    59c2:	84 0c       	add	r8, r4
    59c4:	95 1c       	adc	r9, r5
    59c6:	a6 1c       	adc	r10, r6
    59c8:	b7 1c       	adc	r11, r7
    59ca:	88 0c       	add	r8, r8
    59cc:	99 1c       	adc	r9, r9
    59ce:	aa 1c       	adc	r10, r10
    59d0:	bb 1c       	adc	r11, r11
    59d2:	24 01       	movw	r4, r8
    59d4:	35 01       	movw	r6, r10
    59d6:	49 0e       	add	r4, r25
    59d8:	51 1c       	adc	r5, r1
    59da:	61 1c       	adc	r6, r1
    59dc:	71 1c       	adc	r7, r1
    59de:	09 c0       	rjmp	.+18     	; 0x59f2 <read_float+0xb8>
    59e0:	81 11       	cpse	r24, r1
    59e2:	07 c0       	rjmp	.+14     	; 0x59f2 <read_float+0xb8>
    59e4:	1f 5f       	subi	r17, 0xFF	; 255
    59e6:	05 c0       	rjmp	.+10     	; 0x59f2 <read_float+0xb8>
    59e8:	9e 3f       	cpi	r25, 0xFE	; 254
    59ea:	31 f4       	brne	.+12     	; 0x59f8 <read_float+0xbe>
    59ec:	81 11       	cpse	r24, r1
    59ee:	04 c0       	rjmp	.+8      	; 0x59f8 <read_float+0xbe>
    59f0:	81 e0       	ldi	r24, 0x01	; 1
    59f2:	98 81       	ld	r25, Y
    59f4:	21 96       	adiw	r28, 0x01	; 1
    59f6:	d3 cf       	rjmp	.-90     	; 0x599e <read_float+0x64>
    59f8:	22 23       	and	r18, r18
    59fa:	09 f4       	brne	.+2      	; 0x59fe <read_float+0xc4>
    59fc:	53 c0       	rjmp	.+166    	; 0x5aa4 <read_float+0x16a>
    59fe:	6a 01       	movw	r12, r20
    5a00:	7b 01       	movw	r14, r22
    5a02:	5f 01       	movw	r10, r30
    5a04:	c3 01       	movw	r24, r6
    5a06:	b2 01       	movw	r22, r4
    5a08:	0e 94 ae 3d 	call	0x7b5c	; 0x7b5c <__floatunsisf>
    5a0c:	2b 01       	movw	r4, r22
    5a0e:	3c 01       	movw	r6, r24
    5a10:	20 e0       	ldi	r18, 0x00	; 0
    5a12:	30 e0       	ldi	r19, 0x00	; 0
    5a14:	a9 01       	movw	r20, r18
    5a16:	0e 94 0e 3d 	call	0x7a1c	; 0x7a1c <__cmpsf2>
    5a1a:	81 11       	cpse	r24, r1
    5a1c:	0c c0       	rjmp	.+24     	; 0x5a36 <read_float+0xfc>
    5a1e:	29 c0       	rjmp	.+82     	; 0x5a72 <read_float+0x138>
    5a20:	2a e0       	ldi	r18, 0x0A	; 10
    5a22:	37 ed       	ldi	r19, 0xD7	; 215
    5a24:	43 e2       	ldi	r20, 0x23	; 35
    5a26:	5c e3       	ldi	r21, 0x3C	; 60
    5a28:	c3 01       	movw	r24, r6
    5a2a:	b2 01       	movw	r22, r4
    5a2c:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
    5a30:	2b 01       	movw	r4, r22
    5a32:	3c 01       	movw	r6, r24
    5a34:	1e 5f       	subi	r17, 0xFE	; 254
    5a36:	1f 3f       	cpi	r17, 0xFF	; 255
    5a38:	9c f3       	brlt	.-26     	; 0x5a20 <read_float+0xe6>
    5a3a:	11 23       	and	r17, r17
    5a3c:	5c f4       	brge	.+22     	; 0x5a54 <read_float+0x11a>
    5a3e:	2d ec       	ldi	r18, 0xCD	; 205
    5a40:	3c ec       	ldi	r19, 0xCC	; 204
    5a42:	4c ec       	ldi	r20, 0xCC	; 204
    5a44:	5d e3       	ldi	r21, 0x3D	; 61
    5a46:	c3 01       	movw	r24, r6
    5a48:	b2 01       	movw	r22, r4
    5a4a:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
    5a4e:	2b 01       	movw	r4, r22
    5a50:	3c 01       	movw	r6, r24
    5a52:	0f c0       	rjmp	.+30     	; 0x5a72 <read_float+0x138>
    5a54:	11 16       	cp	r1, r17
    5a56:	6c f4       	brge	.+26     	; 0x5a72 <read_float+0x138>
    5a58:	20 e0       	ldi	r18, 0x00	; 0
    5a5a:	30 e0       	ldi	r19, 0x00	; 0
    5a5c:	40 e2       	ldi	r20, 0x20	; 32
    5a5e:	51 e4       	ldi	r21, 0x41	; 65
    5a60:	c3 01       	movw	r24, r6
    5a62:	b2 01       	movw	r22, r4
    5a64:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
    5a68:	2b 01       	movw	r4, r22
    5a6a:	3c 01       	movw	r6, r24
    5a6c:	11 50       	subi	r17, 0x01	; 1
    5a6e:	11 16       	cp	r1, r17
    5a70:	9c f3       	brlt	.-26     	; 0x5a58 <read_float+0x11e>
    5a72:	00 23       	and	r16, r16
    5a74:	51 f0       	breq	.+20     	; 0x5a8a <read_float+0x150>
    5a76:	77 fa       	bst	r7, 7
    5a78:	70 94       	com	r7
    5a7a:	77 f8       	bld	r7, 7
    5a7c:	70 94       	com	r7
    5a7e:	f6 01       	movw	r30, r12
    5a80:	40 82       	st	Z, r4
    5a82:	51 82       	std	Z+1, r5	; 0x01
    5a84:	62 82       	std	Z+2, r6	; 0x02
    5a86:	73 82       	std	Z+3, r7	; 0x03
    5a88:	06 c0       	rjmp	.+12     	; 0x5a96 <read_float+0x15c>
    5a8a:	d6 01       	movw	r26, r12
    5a8c:	4d 92       	st	X+, r4
    5a8e:	5d 92       	st	X+, r5
    5a90:	6d 92       	st	X+, r6
    5a92:	7c 92       	st	X, r7
    5a94:	13 97       	sbiw	r26, 0x03	; 3
    5a96:	ca 19       	sub	r28, r10
    5a98:	db 09       	sbc	r29, r11
    5a9a:	c1 50       	subi	r28, 0x01	; 1
    5a9c:	f7 01       	movw	r30, r14
    5a9e:	c0 83       	st	Z, r28
    5aa0:	81 e0       	ldi	r24, 0x01	; 1
    5aa2:	01 c0       	rjmp	.+2      	; 0x5aa6 <read_float+0x16c>
    5aa4:	80 e0       	ldi	r24, 0x00	; 0
    5aa6:	df 91       	pop	r29
    5aa8:	cf 91       	pop	r28
    5aaa:	1f 91       	pop	r17
    5aac:	0f 91       	pop	r16
    5aae:	ff 90       	pop	r15
    5ab0:	ef 90       	pop	r14
    5ab2:	df 90       	pop	r13
    5ab4:	cf 90       	pop	r12
    5ab6:	bf 90       	pop	r11
    5ab8:	af 90       	pop	r10
    5aba:	9f 90       	pop	r9
    5abc:	8f 90       	pop	r8
    5abe:	7f 90       	pop	r7
    5ac0:	6f 90       	pop	r6
    5ac2:	5f 90       	pop	r5
    5ac4:	4f 90       	pop	r4
    5ac6:	08 95       	ret

00005ac8 <delay_sec>:
    5ac8:	1f 93       	push	r17
    5aca:	cf 93       	push	r28
    5acc:	df 93       	push	r29
    5ace:	14 2f       	mov	r17, r20
    5ad0:	20 e0       	ldi	r18, 0x00	; 0
    5ad2:	30 e0       	ldi	r19, 0x00	; 0
    5ad4:	40 ea       	ldi	r20, 0xA0	; 160
    5ad6:	51 e4       	ldi	r21, 0x41	; 65
    5ad8:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
    5adc:	0e 94 fb 3c 	call	0x79f6	; 0x79f6 <ceil>
    5ae0:	0e 94 82 3d 	call	0x7b04	; 0x7b04 <__fixunssfsi>
    5ae4:	19 c0       	rjmp	.+50     	; 0x5b18 <delay_sec+0x50>
    5ae6:	80 91 12 0c 	lds	r24, 0x0C12	; 0x800c12 <sys+0x1>
    5aea:	81 11       	cpse	r24, r1
    5aec:	19 c0       	rjmp	.+50     	; 0x5b20 <delay_sec+0x58>
    5aee:	11 11       	cpse	r17, r1
    5af0:	03 c0       	rjmp	.+6      	; 0x5af8 <delay_sec+0x30>
    5af2:	0e 94 b2 17 	call	0x2f64	; 0x2f64 <protocol_execute_realtime>
    5af6:	06 c0       	rjmp	.+12     	; 0x5b04 <delay_sec+0x3c>
    5af8:	0e 94 08 15 	call	0x2a10	; 0x2a10 <protocol_exec_rt_system>
    5afc:	80 91 13 0c 	lds	r24, 0x0C13	; 0x800c13 <sys+0x2>
    5b00:	81 fd       	sbrc	r24, 1
    5b02:	0e c0       	rjmp	.+28     	; 0x5b20 <delay_sec+0x58>
    5b04:	2f ef       	ldi	r18, 0xFF	; 255
    5b06:	80 e7       	ldi	r24, 0x70	; 112
    5b08:	92 e0       	ldi	r25, 0x02	; 2
    5b0a:	21 50       	subi	r18, 0x01	; 1
    5b0c:	80 40       	sbci	r24, 0x00	; 0
    5b0e:	90 40       	sbci	r25, 0x00	; 0
    5b10:	e1 f7       	brne	.-8      	; 0x5b0a <delay_sec+0x42>
    5b12:	00 c0       	rjmp	.+0      	; 0x5b14 <delay_sec+0x4c>
    5b14:	00 00       	nop
    5b16:	be 01       	movw	r22, r28
    5b18:	eb 01       	movw	r28, r22
    5b1a:	21 97       	sbiw	r28, 0x01	; 1
    5b1c:	67 2b       	or	r22, r23
    5b1e:	19 f7       	brne	.-58     	; 0x5ae6 <delay_sec+0x1e>
    5b20:	df 91       	pop	r29
    5b22:	cf 91       	pop	r28
    5b24:	1f 91       	pop	r17
    5b26:	08 95       	ret

00005b28 <delay_ms>:
    5b28:	07 c0       	rjmp	.+14     	; 0x5b38 <delay_ms+0x10>
    5b2a:	8f e9       	ldi	r24, 0x9F	; 159
    5b2c:	9f e0       	ldi	r25, 0x0F	; 15
    5b2e:	01 97       	sbiw	r24, 0x01	; 1
    5b30:	f1 f7       	brne	.-4      	; 0x5b2e <delay_ms+0x6>
    5b32:	00 c0       	rjmp	.+0      	; 0x5b34 <delay_ms+0xc>
    5b34:	00 00       	nop
    5b36:	c9 01       	movw	r24, r18
    5b38:	9c 01       	movw	r18, r24
    5b3a:	21 50       	subi	r18, 0x01	; 1
    5b3c:	31 09       	sbc	r19, r1
    5b3e:	89 2b       	or	r24, r25
    5b40:	a1 f7       	brne	.-24     	; 0x5b2a <delay_ms+0x2>
    5b42:	08 95       	ret

00005b44 <hypot_f>:


// Simple hypotenuse computation function.
float hypot_f(float x, float y) { return(sqrt(x*x + y*y)); }
    5b44:	8f 92       	push	r8
    5b46:	9f 92       	push	r9
    5b48:	af 92       	push	r10
    5b4a:	bf 92       	push	r11
    5b4c:	cf 92       	push	r12
    5b4e:	df 92       	push	r13
    5b50:	ef 92       	push	r14
    5b52:	ff 92       	push	r15
    5b54:	69 01       	movw	r12, r18
    5b56:	7a 01       	movw	r14, r20
    5b58:	9b 01       	movw	r18, r22
    5b5a:	ac 01       	movw	r20, r24
    5b5c:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
    5b60:	4b 01       	movw	r8, r22
    5b62:	5c 01       	movw	r10, r24
    5b64:	a7 01       	movw	r20, r14
    5b66:	96 01       	movw	r18, r12
    5b68:	c7 01       	movw	r24, r14
    5b6a:	b6 01       	movw	r22, r12
    5b6c:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
    5b70:	9b 01       	movw	r18, r22
    5b72:	ac 01       	movw	r20, r24
    5b74:	c5 01       	movw	r24, r10
    5b76:	b4 01       	movw	r22, r8
    5b78:	0e 94 35 3c 	call	0x786a	; 0x786a <__addsf3>
    5b7c:	0e 94 d9 3f 	call	0x7fb2	; 0x7fb2 <sqrt>
    5b80:	ff 90       	pop	r15
    5b82:	ef 90       	pop	r14
    5b84:	df 90       	pop	r13
    5b86:	cf 90       	pop	r12
    5b88:	bf 90       	pop	r11
    5b8a:	af 90       	pop	r10
    5b8c:	9f 90       	pop	r9
    5b8e:	8f 90       	pop	r8
    5b90:	08 95       	ret

00005b92 <convert_delta_vector_to_unit_vector>:


float convert_delta_vector_to_unit_vector(float *vector)
{
    5b92:	4f 92       	push	r4
    5b94:	5f 92       	push	r5
    5b96:	6f 92       	push	r6
    5b98:	7f 92       	push	r7
    5b9a:	8f 92       	push	r8
    5b9c:	9f 92       	push	r9
    5b9e:	af 92       	push	r10
    5ba0:	bf 92       	push	r11
    5ba2:	ef 92       	push	r14
    5ba4:	ff 92       	push	r15
    5ba6:	1f 93       	push	r17
    5ba8:	cf 93       	push	r28
    5baa:	df 93       	push	r29
    5bac:	7c 01       	movw	r14, r24
  uint8_t idx;
  float magnitude = 0.0;
    5bae:	81 2c       	mov	r8, r1
    5bb0:	91 2c       	mov	r9, r1
    5bb2:	54 01       	movw	r10, r8
  for (idx=0; idx<N_AXIS; idx++) {
    5bb4:	c0 e0       	ldi	r28, 0x00	; 0
    5bb6:	24 c0       	rjmp	.+72     	; 0x5c00 <convert_delta_vector_to_unit_vector+0x6e>
    if (vector[idx] != 0.0) {
    5bb8:	ec 2f       	mov	r30, r28
    5bba:	f0 e0       	ldi	r31, 0x00	; 0
    5bbc:	ee 0f       	add	r30, r30
    5bbe:	ff 1f       	adc	r31, r31
    5bc0:	ee 0f       	add	r30, r30
    5bc2:	ff 1f       	adc	r31, r31
    5bc4:	ee 0d       	add	r30, r14
    5bc6:	ff 1d       	adc	r31, r15
    5bc8:	40 80       	ld	r4, Z
    5bca:	51 80       	ldd	r5, Z+1	; 0x01
    5bcc:	62 80       	ldd	r6, Z+2	; 0x02
    5bce:	73 80       	ldd	r7, Z+3	; 0x03
    5bd0:	20 e0       	ldi	r18, 0x00	; 0
    5bd2:	30 e0       	ldi	r19, 0x00	; 0
    5bd4:	a9 01       	movw	r20, r18
    5bd6:	c3 01       	movw	r24, r6
    5bd8:	b2 01       	movw	r22, r4
    5bda:	0e 94 0e 3d 	call	0x7a1c	; 0x7a1c <__cmpsf2>
    5bde:	88 23       	and	r24, r24
    5be0:	71 f0       	breq	.+28     	; 0x5bfe <convert_delta_vector_to_unit_vector+0x6c>
      magnitude += vector[idx]*vector[idx];
    5be2:	a3 01       	movw	r20, r6
    5be4:	92 01       	movw	r18, r4
    5be6:	c3 01       	movw	r24, r6
    5be8:	b2 01       	movw	r22, r4
    5bea:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
    5bee:	9b 01       	movw	r18, r22
    5bf0:	ac 01       	movw	r20, r24
    5bf2:	c5 01       	movw	r24, r10
    5bf4:	b4 01       	movw	r22, r8
    5bf6:	0e 94 35 3c 	call	0x786a	; 0x786a <__addsf3>
    5bfa:	4b 01       	movw	r8, r22
    5bfc:	5c 01       	movw	r10, r24

float convert_delta_vector_to_unit_vector(float *vector)
{
  uint8_t idx;
  float magnitude = 0.0;
  for (idx=0; idx<N_AXIS; idx++) {
    5bfe:	cf 5f       	subi	r28, 0xFF	; 255
    5c00:	c3 30       	cpi	r28, 0x03	; 3
    5c02:	d0 f2       	brcs	.-76     	; 0x5bb8 <convert_delta_vector_to_unit_vector+0x26>
    if (vector[idx] != 0.0) {
      magnitude += vector[idx]*vector[idx];
    }
  }
  magnitude = sqrt(magnitude);
    5c04:	c5 01       	movw	r24, r10
    5c06:	b4 01       	movw	r22, r8
    5c08:	0e 94 d9 3f 	call	0x7fb2	; 0x7fb2 <sqrt>
    5c0c:	2b 01       	movw	r4, r22
    5c0e:	3c 01       	movw	r6, r24
  float inv_magnitude = 1.0/magnitude;
    5c10:	9b 01       	movw	r18, r22
    5c12:	ac 01       	movw	r20, r24
    5c14:	60 e0       	ldi	r22, 0x00	; 0
    5c16:	70 e0       	ldi	r23, 0x00	; 0
    5c18:	80 e8       	ldi	r24, 0x80	; 128
    5c1a:	9f e3       	ldi	r25, 0x3F	; 63
    5c1c:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <__divsf3>
    5c20:	4b 01       	movw	r8, r22
    5c22:	5c 01       	movw	r10, r24
  for (idx=0; idx<N_AXIS; idx++) { vector[idx] *= inv_magnitude; }
    5c24:	10 e0       	ldi	r17, 0x00	; 0
    5c26:	15 c0       	rjmp	.+42     	; 0x5c52 <convert_delta_vector_to_unit_vector+0xc0>
    5c28:	c1 2f       	mov	r28, r17
    5c2a:	d0 e0       	ldi	r29, 0x00	; 0
    5c2c:	cc 0f       	add	r28, r28
    5c2e:	dd 1f       	adc	r29, r29
    5c30:	cc 0f       	add	r28, r28
    5c32:	dd 1f       	adc	r29, r29
    5c34:	ce 0d       	add	r28, r14
    5c36:	df 1d       	adc	r29, r15
    5c38:	a5 01       	movw	r20, r10
    5c3a:	94 01       	movw	r18, r8
    5c3c:	68 81       	ld	r22, Y
    5c3e:	79 81       	ldd	r23, Y+1	; 0x01
    5c40:	8a 81       	ldd	r24, Y+2	; 0x02
    5c42:	9b 81       	ldd	r25, Y+3	; 0x03
    5c44:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
    5c48:	68 83       	st	Y, r22
    5c4a:	79 83       	std	Y+1, r23	; 0x01
    5c4c:	8a 83       	std	Y+2, r24	; 0x02
    5c4e:	9b 83       	std	Y+3, r25	; 0x03
    5c50:	1f 5f       	subi	r17, 0xFF	; 255
    5c52:	13 30       	cpi	r17, 0x03	; 3
    5c54:	48 f3       	brcs	.-46     	; 0x5c28 <convert_delta_vector_to_unit_vector+0x96>
  return(magnitude);
}
    5c56:	c3 01       	movw	r24, r6
    5c58:	b2 01       	movw	r22, r4
    5c5a:	df 91       	pop	r29
    5c5c:	cf 91       	pop	r28
    5c5e:	1f 91       	pop	r17
    5c60:	ff 90       	pop	r15
    5c62:	ef 90       	pop	r14
    5c64:	bf 90       	pop	r11
    5c66:	af 90       	pop	r10
    5c68:	9f 90       	pop	r9
    5c6a:	8f 90       	pop	r8
    5c6c:	7f 90       	pop	r7
    5c6e:	6f 90       	pop	r6
    5c70:	5f 90       	pop	r5
    5c72:	4f 90       	pop	r4
    5c74:	08 95       	ret

00005c76 <limit_value_by_axis_maximum>:


float limit_value_by_axis_maximum(float *max_value, float *unit_vec)
{
    5c76:	5f 92       	push	r5
    5c78:	6f 92       	push	r6
    5c7a:	7f 92       	push	r7
    5c7c:	8f 92       	push	r8
    5c7e:	9f 92       	push	r9
    5c80:	af 92       	push	r10
    5c82:	bf 92       	push	r11
    5c84:	cf 92       	push	r12
    5c86:	df 92       	push	r13
    5c88:	ef 92       	push	r14
    5c8a:	ff 92       	push	r15
    5c8c:	0f 93       	push	r16
    5c8e:	1f 93       	push	r17
    5c90:	cf 93       	push	r28
    5c92:	df 93       	push	r29
    5c94:	7c 01       	movw	r14, r24
    5c96:	8b 01       	movw	r16, r22
  uint8_t idx;
  float limit_value = SOME_LARGE_VALUE;
    5c98:	0f 2e       	mov	r0, r31
    5c9a:	f9 e9       	ldi	r31, 0x99	; 153
    5c9c:	6f 2e       	mov	r6, r31
    5c9e:	f0 2d       	mov	r31, r0
    5ca0:	0f 2e       	mov	r0, r31
    5ca2:	f6 e7       	ldi	r31, 0x76	; 118
    5ca4:	7f 2e       	mov	r7, r31
    5ca6:	f0 2d       	mov	r31, r0
    5ca8:	0f 2e       	mov	r0, r31
    5caa:	f6 e9       	ldi	r31, 0x96	; 150
    5cac:	cf 2e       	mov	r12, r31
    5cae:	f0 2d       	mov	r31, r0
    5cb0:	0f 2e       	mov	r0, r31
    5cb2:	fe e7       	ldi	r31, 0x7E	; 126
    5cb4:	5f 2e       	mov	r5, r31
    5cb6:	f0 2d       	mov	r31, r0
  for (idx=0; idx<N_AXIS; idx++) {
    5cb8:	d1 2c       	mov	r13, r1
    5cba:	33 c0       	rjmp	.+102    	; 0x5d22 <limit_value_by_axis_maximum+0xac>
    if (unit_vec[idx] != 0) {  // Avoid divide by zero.
    5cbc:	cd 2d       	mov	r28, r13
    5cbe:	d0 e0       	ldi	r29, 0x00	; 0
    5cc0:	cc 0f       	add	r28, r28
    5cc2:	dd 1f       	adc	r29, r29
    5cc4:	cc 0f       	add	r28, r28
    5cc6:	dd 1f       	adc	r29, r29
    5cc8:	f8 01       	movw	r30, r16
    5cca:	ec 0f       	add	r30, r28
    5ccc:	fd 1f       	adc	r31, r29
    5cce:	80 80       	ld	r8, Z
    5cd0:	91 80       	ldd	r9, Z+1	; 0x01
    5cd2:	a2 80       	ldd	r10, Z+2	; 0x02
    5cd4:	b3 80       	ldd	r11, Z+3	; 0x03
    5cd6:	20 e0       	ldi	r18, 0x00	; 0
    5cd8:	30 e0       	ldi	r19, 0x00	; 0
    5cda:	a9 01       	movw	r20, r18
    5cdc:	c5 01       	movw	r24, r10
    5cde:	b4 01       	movw	r22, r8
    5ce0:	0e 94 0e 3d 	call	0x7a1c	; 0x7a1c <__cmpsf2>
    5ce4:	88 23       	and	r24, r24
    5ce6:	e1 f0       	breq	.+56     	; 0x5d20 <limit_value_by_axis_maximum+0xaa>
      limit_value = min(limit_value,fabs(max_value[idx]/unit_vec[idx]));
    5ce8:	ce 0d       	add	r28, r14
    5cea:	df 1d       	adc	r29, r15
    5cec:	68 81       	ld	r22, Y
    5cee:	79 81       	ldd	r23, Y+1	; 0x01
    5cf0:	8a 81       	ldd	r24, Y+2	; 0x02
    5cf2:	9b 81       	ldd	r25, Y+3	; 0x03
    5cf4:	a5 01       	movw	r20, r10
    5cf6:	94 01       	movw	r18, r8
    5cf8:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <__divsf3>
    5cfc:	4b 01       	movw	r8, r22
    5cfe:	5c 01       	movw	r10, r24
    5d00:	e8 94       	clt
    5d02:	b7 f8       	bld	r11, 7
    5d04:	a5 01       	movw	r20, r10
    5d06:	94 01       	movw	r18, r8
    5d08:	66 2d       	mov	r22, r6
    5d0a:	77 2d       	mov	r23, r7
    5d0c:	8c 2d       	mov	r24, r12
    5d0e:	95 2d       	mov	r25, r5
    5d10:	0e 94 0e 3d 	call	0x7a1c	; 0x7a1c <__cmpsf2>
    5d14:	88 23       	and	r24, r24
    5d16:	24 f0       	brlt	.+8      	; 0x5d20 <limit_value_by_axis_maximum+0xaa>
    5d18:	68 2c       	mov	r6, r8
    5d1a:	79 2c       	mov	r7, r9
    5d1c:	ca 2c       	mov	r12, r10
    5d1e:	5b 2c       	mov	r5, r11

float limit_value_by_axis_maximum(float *max_value, float *unit_vec)
{
  uint8_t idx;
  float limit_value = SOME_LARGE_VALUE;
  for (idx=0; idx<N_AXIS; idx++) {
    5d20:	d3 94       	inc	r13
    5d22:	82 e0       	ldi	r24, 0x02	; 2
    5d24:	8d 15       	cp	r24, r13
    5d26:	50 f6       	brcc	.-108    	; 0x5cbc <limit_value_by_axis_maximum+0x46>
    if (unit_vec[idx] != 0) {  // Avoid divide by zero.
      limit_value = min(limit_value,fabs(max_value[idx]/unit_vec[idx]));
    }
  }
  return(limit_value);
}
    5d28:	66 2d       	mov	r22, r6
    5d2a:	77 2d       	mov	r23, r7
    5d2c:	8c 2d       	mov	r24, r12
    5d2e:	95 2d       	mov	r25, r5
    5d30:	df 91       	pop	r29
    5d32:	cf 91       	pop	r28
    5d34:	1f 91       	pop	r17
    5d36:	0f 91       	pop	r16
    5d38:	ff 90       	pop	r15
    5d3a:	ef 90       	pop	r14
    5d3c:	df 90       	pop	r13
    5d3e:	cf 90       	pop	r12
    5d40:	bf 90       	pop	r11
    5d42:	af 90       	pop	r10
    5d44:	9f 90       	pop	r9
    5d46:	8f 90       	pop	r8
    5d48:	7f 90       	pop	r7
    5d4a:	6f 90       	pop	r6
    5d4c:	5f 90       	pop	r5
    5d4e:	08 95       	ret

00005d50 <limits_disable>:
    #ifndef DISABLE_HW_LIMITS
     LIMIT_PCMSK &= ~LIMIT_MASK;  // Disable specific pins of the Pin Change Interrupt
     PCICR &= ~(1 << LIMIT_INT);  // Disable Pin Change Interrupt
    #endif
  #else
    LIMIT_PCMSK &= ~LIMIT_MASK;  // Disable specific pins of the Pin Change Interrupt
    5d50:	eb e6       	ldi	r30, 0x6B	; 107
    5d52:	f0 e0       	ldi	r31, 0x00	; 0
    5d54:	80 81       	ld	r24, Z
    5d56:	8f 78       	andi	r24, 0x8F	; 143
    5d58:	80 83       	st	Z, r24
    PCICR &= ~(1 << LIMIT_INT);  // Disable Pin Change Interrupt
    5d5a:	e8 e6       	ldi	r30, 0x68	; 104
    5d5c:	f0 e0       	ldi	r31, 0x00	; 0
    5d5e:	80 81       	ld	r24, Z
    5d60:	8e 7f       	andi	r24, 0xFE	; 254
    5d62:	80 83       	st	Z, r24
    5d64:	08 95       	ret

00005d66 <limits_init>:
        WDTCSR |= (1<<WDCE) | (1<<WDE);
        WDTCSR = (1<<WDP0); // Set time-out at ~32msec.
      #endif
    #endif // DISABLE_HW_LIMITS
  #else
    LIMIT_DDR &= ~(LIMIT_MASK); // Set as input pins
    5d66:	84 b1       	in	r24, 0x04	; 4
    5d68:	8f 78       	andi	r24, 0x8F	; 143
    5d6a:	84 b9       	out	0x04, r24	; 4

    #ifdef DISABLE_LIMIT_PIN_PULL_UP
      LIMIT_PORT &= ~(LIMIT_MASK); // Normal low operation. Requires external pull-down.
    #else
      LIMIT_PORT |= (LIMIT_MASK);  // Enable internal pull-up resistors. Normal high operation.
    5d6c:	85 b1       	in	r24, 0x05	; 5
    5d6e:	80 67       	ori	r24, 0x70	; 112
    5d70:	85 b9       	out	0x05, r24	; 5
    #endif

    if (bit_istrue(settings.flags,BITFLAG_HARD_LIMIT_ENABLE)) {
    5d72:	80 91 fe 0e 	lds	r24, 0x0EFE	; 0x800efe <settings+0x45>
    5d76:	83 ff       	sbrs	r24, 3
    5d78:	0b c0       	rjmp	.+22     	; 0x5d90 <limits_init+0x2a>
      LIMIT_PCMSK |= LIMIT_MASK; // Enable specific pins of the Pin Change Interrupt
    5d7a:	eb e6       	ldi	r30, 0x6B	; 107
    5d7c:	f0 e0       	ldi	r31, 0x00	; 0
    5d7e:	80 81       	ld	r24, Z
    5d80:	80 67       	ori	r24, 0x70	; 112
    5d82:	80 83       	st	Z, r24
      PCICR |= (1 << LIMIT_INT); // Enable Pin Change Interrupt
    5d84:	e8 e6       	ldi	r30, 0x68	; 104
    5d86:	f0 e0       	ldi	r31, 0x00	; 0
    5d88:	80 81       	ld	r24, Z
    5d8a:	81 60       	ori	r24, 0x01	; 1
    5d8c:	80 83       	st	Z, r24
    5d8e:	08 95       	ret
    } else {
      limits_disable();
    5d90:	df cf       	rjmp	.-66     	; 0x5d50 <limits_disable>
    5d92:	08 95       	ret

00005d94 <limits_get_state>:

// Returns limit state as a bit-wise uint8 variable. Each bit indicates an axis limit, where 
// triggered is 1 and not triggered is 0. Invert mask is applied. Axes are defined by their
// number in bit position, i.e. Z_AXIS is (1<<2) or bit 2, and Y_AXIS is (1<<1) or bit 1.
uint8_t limits_get_state()
{
    5d94:	1f 93       	push	r17
    5d96:	cf 93       	push	r28
    5d98:	df 93       	push	r29
      if (pin)
        limit_state |= (1 << idx);
    } 
    return(limit_state);
  #else
    uint8_t pin = (LIMIT_PIN & LIMIT_MASK);
    5d9a:	d3 b1       	in	r29, 0x03	; 3
    5d9c:	d0 77       	andi	r29, 0x70	; 112
    #ifdef INVERT_LIMIT_PIN_MASK
      pin ^= INVERT_LIMIT_PIN_MASK;
    #endif
    if (bit_isfalse(settings.flags,BITFLAG_INVERT_LIMIT_PINS)) { pin ^= LIMIT_MASK; }
    5d9e:	80 91 fe 0e 	lds	r24, 0x0EFE	; 0x800efe <settings+0x45>
    5da2:	86 fd       	sbrc	r24, 6
    5da4:	02 c0       	rjmp	.+4      	; 0x5daa <limits_get_state+0x16>
    5da6:	80 e7       	ldi	r24, 0x70	; 112
    5da8:	d8 27       	eor	r29, r24
    if (pin) {  
    5daa:	d1 11       	cpse	r29, r1
    5dac:	11 c0       	rjmp	.+34     	; 0x5dd0 <limits_get_state+0x3c>
// Returns limit state as a bit-wise uint8 variable. Each bit indicates an axis limit, where 
// triggered is 1 and not triggered is 0. Invert mask is applied. Axes are defined by their
// number in bit position, i.e. Z_AXIS is (1<<2) or bit 2, and Y_AXIS is (1<<1) or bit 1.
uint8_t limits_get_state()
{
  uint8_t limit_state = 0;
    5dae:	10 e0       	ldi	r17, 0x00	; 0
    5db0:	13 c0       	rjmp	.+38     	; 0x5dd8 <limits_get_state+0x44>
    #endif
    if (bit_isfalse(settings.flags,BITFLAG_INVERT_LIMIT_PINS)) { pin ^= LIMIT_MASK; }
    if (pin) {  
      uint8_t idx;
      for (idx=0; idx<N_AXIS; idx++) {
        if (pin & get_limit_pin_mask(idx)) { limit_state |= (1 << idx); }
    5db2:	8c 2f       	mov	r24, r28
    5db4:	0b d8       	rcall	.-4074   	; 0x4dcc <get_limit_pin_mask>
    5db6:	8d 23       	and	r24, r29
    5db8:	49 f0       	breq	.+18     	; 0x5dcc <limits_get_state+0x38>
    5dba:	81 e0       	ldi	r24, 0x01	; 1
    5dbc:	90 e0       	ldi	r25, 0x00	; 0
    5dbe:	0c 2e       	mov	r0, r28
    5dc0:	02 c0       	rjmp	.+4      	; 0x5dc6 <limits_get_state+0x32>
    5dc2:	88 0f       	add	r24, r24
    5dc4:	99 1f       	adc	r25, r25
    5dc6:	0a 94       	dec	r0
    5dc8:	e2 f7       	brpl	.-8      	; 0x5dc2 <limits_get_state+0x2e>
    5dca:	18 2b       	or	r17, r24
      pin ^= INVERT_LIMIT_PIN_MASK;
    #endif
    if (bit_isfalse(settings.flags,BITFLAG_INVERT_LIMIT_PINS)) { pin ^= LIMIT_MASK; }
    if (pin) {  
      uint8_t idx;
      for (idx=0; idx<N_AXIS; idx++) {
    5dcc:	cf 5f       	subi	r28, 0xFF	; 255
    5dce:	02 c0       	rjmp	.+4      	; 0x5dd4 <limits_get_state+0x40>
    5dd0:	c0 e0       	ldi	r28, 0x00	; 0
    5dd2:	10 e0       	ldi	r17, 0x00	; 0
    5dd4:	c3 30       	cpi	r28, 0x03	; 3
    5dd6:	68 f3       	brcs	.-38     	; 0x5db2 <limits_get_state+0x1e>
        if (pin & get_limit_pin_mask(idx)) { limit_state |= (1 << idx); }
      }
    }
    return(limit_state);
  #endif //DEFAULTS_RAMPS_BOARD
}
    5dd8:	81 2f       	mov	r24, r17
    5dda:	df 91       	pop	r29
    5ddc:	cf 91       	pop	r28
    5dde:	1f 91       	pop	r17
    5de0:	08 95       	ret

00005de2 <__vector_9>:
// homing cycles and will not respond correctly. Upon user request or need, there may be a
// special pinout for an e-stop, but it is generally recommended to just directly connect
// your e-stop switch to the Arduino reset pin, since it is the most correct way to do this.
  #ifndef ENABLE_SOFTWARE_DEBOUNCE
    ISR(LIMIT_INT_vect) // DEFAULT: Limit pin change interrupt process. 
    {
    5de2:	1f 92       	push	r1
    5de4:	0f 92       	push	r0
    5de6:	0f b6       	in	r0, 0x3f	; 63
    5de8:	0f 92       	push	r0
    5dea:	11 24       	eor	r1, r1
    5dec:	0b b6       	in	r0, 0x3b	; 59
    5dee:	0f 92       	push	r0
    5df0:	2f 93       	push	r18
    5df2:	3f 93       	push	r19
    5df4:	4f 93       	push	r20
    5df6:	5f 93       	push	r21
    5df8:	6f 93       	push	r22
    5dfa:	7f 93       	push	r23
    5dfc:	8f 93       	push	r24
    5dfe:	9f 93       	push	r25
    5e00:	af 93       	push	r26
    5e02:	bf 93       	push	r27
    5e04:	ef 93       	push	r30
    5e06:	ff 93       	push	r31
      // Ignore limit switches if already in an alarm state or in-process of executing an alarm.
      // When in the alarm state, Grbl should have been reset or will force a reset, so any pending 
      // moves in the planner and serial buffers are all cleared and newly sent blocks will be 
      // locked out until a homing cycle or a kill lock command. Allows the user to disable the hard
      // limit setting if their limits are constantly triggering after a reset and move their axes.
      if (sys.state != STATE_ALARM) { 
    5e08:	80 91 11 0c 	lds	r24, 0x0C11	; 0x800c11 <sys>
    5e0c:	81 30       	cpi	r24, 0x01	; 1
    5e0e:	49 f0       	breq	.+18     	; 0x5e22 <__vector_9+0x40>
        if (!(sys_rt_exec_alarm)) {
    5e10:	80 91 3d 0c 	lds	r24, 0x0C3D	; 0x800c3d <sys_rt_exec_alarm>
    5e14:	81 11       	cpse	r24, r1
    5e16:	05 c0       	rjmp	.+10     	; 0x5e22 <__vector_9+0x40>
            if (limits_get_state()) {
              mc_reset(); // Initiate system kill.
              system_set_exec_alarm(EXEC_ALARM_HARD_LIMIT); // Indicate hard limit critical event
            }
          #else
            mc_reset(); // Initiate system kill.
    5e18:	0e 94 ac 06 	call	0xd58	; 0xd58 <mc_reset>
            system_set_exec_alarm(EXEC_ALARM_HARD_LIMIT); // Indicate hard limit critical event
    5e1c:	81 e0       	ldi	r24, 0x01	; 1
    5e1e:	0e 94 a4 3b 	call	0x7748	; 0x7748 <system_set_exec_alarm>
          #endif
        }
      }
    }  
    5e22:	ff 91       	pop	r31
    5e24:	ef 91       	pop	r30
    5e26:	bf 91       	pop	r27
    5e28:	af 91       	pop	r26
    5e2a:	9f 91       	pop	r25
    5e2c:	8f 91       	pop	r24
    5e2e:	7f 91       	pop	r23
    5e30:	6f 91       	pop	r22
    5e32:	5f 91       	pop	r21
    5e34:	4f 91       	pop	r20
    5e36:	3f 91       	pop	r19
    5e38:	2f 91       	pop	r18
    5e3a:	0f 90       	pop	r0
    5e3c:	0b be       	out	0x3b, r0	; 59
    5e3e:	0f 90       	pop	r0
    5e40:	0f be       	out	0x3f, r0	; 63
    5e42:	0f 90       	pop	r0
    5e44:	1f 90       	pop	r1
    5e46:	18 95       	reti

00005e48 <limits_go_home>:
// mask, which prevents the stepper algorithm from executing step pulses. Homing motions typically
// circumvent the processes for executing motions in normal operation.
// NOTE: Only the abort realtime command can interrupt this process.
// TODO: Move limit pin-specific calls to a general function for portability.
void limits_go_home(uint8_t cycle_mask)
{
    5e48:	4f 92       	push	r4
    5e4a:	5f 92       	push	r5
    5e4c:	6f 92       	push	r6
    5e4e:	7f 92       	push	r7
    5e50:	8f 92       	push	r8
    5e52:	9f 92       	push	r9
    5e54:	af 92       	push	r10
    5e56:	bf 92       	push	r11
    5e58:	cf 92       	push	r12
    5e5a:	df 92       	push	r13
    5e5c:	ef 92       	push	r14
    5e5e:	ff 92       	push	r15
    5e60:	0f 93       	push	r16
    5e62:	1f 93       	push	r17
    5e64:	cf 93       	push	r28
    5e66:	df 93       	push	r29
    5e68:	cd b7       	in	r28, 0x3d	; 61
    5e6a:	de b7       	in	r29, 0x3e	; 62
    5e6c:	a0 97       	sbiw	r28, 0x20	; 32
    5e6e:	0f b6       	in	r0, 0x3f	; 63
    5e70:	f8 94       	cli
    5e72:	de bf       	out	0x3e, r29	; 62
    5e74:	0f be       	out	0x3f, r0	; 63
    5e76:	cd bf       	out	0x3d, r28	; 61
  if (sys.abort) { return; } // Block if system reset has been issued.
    5e78:	90 91 12 0c 	lds	r25, 0x0C12	; 0x800c12 <sys+0x1>
    5e7c:	91 11       	cpse	r25, r1
    5e7e:	fe c1       	rjmp	.+1020   	; 0x627c <limits_go_home+0x434>
    5e80:	08 2f       	mov	r16, r24

  // Initialize plan data struct for homing motion. Spindle and coolant are disabled.
  plan_line_data_t plan_data;
  plan_line_data_t *pl_data = &plan_data;
  memset(pl_data,0,sizeof(plan_line_data_t));
    5e82:	fe 01       	movw	r30, r28
    5e84:	31 96       	adiw	r30, 0x01	; 1
    5e86:	8d e0       	ldi	r24, 0x0D	; 13
    5e88:	df 01       	movw	r26, r30
    5e8a:	1d 92       	st	X+, r1
    5e8c:	8a 95       	dec	r24
    5e8e:	e9 f7       	brne	.-6      	; 0x5e8a <limits_go_home+0x42>
  pl_data->condition = (PL_COND_FLAG_SYSTEM_MOTION|PL_COND_FLAG_NO_FEED_OVERRIDE);
    5e90:	86 e0       	ldi	r24, 0x06	; 6
    5e92:	8d 87       	std	Y+13, r24	; 0x0d
  uint8_t n_cycle = (2*N_HOMING_LOCATE_CYCLE+1);
  uint8_t step_pin[N_AXIS];
  float target[N_AXIS];
  float max_travel = 0.0;
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {
    5e94:	10 e0       	ldi	r17, 0x00	; 0

  // Initialize variables used for homing computations.
  uint8_t n_cycle = (2*N_HOMING_LOCATE_CYCLE+1);
  uint8_t step_pin[N_AXIS];
  float target[N_AXIS];
  float max_travel = 0.0;
    5e96:	81 2c       	mov	r8, r1
    5e98:	91 2c       	mov	r9, r1
    5e9a:	54 01       	movw	r10, r8
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {
    5e9c:	3d c0       	rjmp	.+122    	; 0x5f18 <limits_go_home+0xd0>
    // Initialize step pin masks
    step_pin[idx] = get_step_pin_mask(idx);
    5e9e:	e1 2e       	mov	r14, r17
    5ea0:	f1 2c       	mov	r15, r1
    5ea2:	81 2f       	mov	r24, r17
    5ea4:	0e 94 d2 26 	call	0x4da4	; 0x4da4 <get_step_pin_mask>
    5ea8:	ee e0       	ldi	r30, 0x0E	; 14
    5eaa:	f0 e0       	ldi	r31, 0x00	; 0
    5eac:	ec 0f       	add	r30, r28
    5eae:	fd 1f       	adc	r31, r29
    5eb0:	ee 0d       	add	r30, r14
    5eb2:	ff 1d       	adc	r31, r15
    5eb4:	80 83       	st	Z, r24
    #ifdef COREXY
      if ((idx==A_MOTOR)||(idx==B_MOTOR)) { step_pin[idx] = (get_step_pin_mask(X_AXIS)|get_step_pin_mask(Y_AXIS)); }
    #endif

    if (bit_istrue(cycle_mask,bit(idx))) {
    5eb6:	80 2f       	mov	r24, r16
    5eb8:	90 e0       	ldi	r25, 0x00	; 0
    5eba:	01 2e       	mov	r0, r17
    5ebc:	02 c0       	rjmp	.+4      	; 0x5ec2 <limits_go_home+0x7a>
    5ebe:	95 95       	asr	r25
    5ec0:	87 95       	ror	r24
    5ec2:	0a 94       	dec	r0
    5ec4:	e2 f7       	brpl	.-8      	; 0x5ebe <limits_go_home+0x76>
    5ec6:	80 ff       	sbrs	r24, 0
    5ec8:	26 c0       	rjmp	.+76     	; 0x5f16 <limits_go_home+0xce>
      // Set target based on max_travel setting. Ensure homing switches engaged with search scalar.
      // NOTE: settings.max_travel[] is stored as a negative value.
      max_travel = max(max_travel,(-HOMING_AXIS_SEARCH_SCALAR)*settings.max_travel[idx]);
    5eca:	f7 01       	movw	r30, r14
    5ecc:	39 96       	adiw	r30, 0x09	; 9
    5ece:	ee 0f       	add	r30, r30
    5ed0:	ff 1f       	adc	r31, r31
    5ed2:	ee 0f       	add	r30, r30
    5ed4:	ff 1f       	adc	r31, r31
    5ed6:	e7 54       	subi	r30, 0x47	; 71
    5ed8:	f1 4f       	sbci	r31, 0xF1	; 241
    5eda:	60 81       	ld	r22, Z
    5edc:	71 81       	ldd	r23, Z+1	; 0x01
    5ede:	82 81       	ldd	r24, Z+2	; 0x02
    5ee0:	93 81       	ldd	r25, Z+3	; 0x03
    5ee2:	20 e0       	ldi	r18, 0x00	; 0
    5ee4:	30 e0       	ldi	r19, 0x00	; 0
    5ee6:	40 ec       	ldi	r20, 0xC0	; 192
    5ee8:	5f eb       	ldi	r21, 0xBF	; 191
    5eea:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
    5eee:	c6 2e       	mov	r12, r22
    5ef0:	d7 2e       	mov	r13, r23
    5ef2:	e8 2e       	mov	r14, r24
    5ef4:	f9 2e       	mov	r15, r25
    5ef6:	26 2f       	mov	r18, r22
    5ef8:	37 2f       	mov	r19, r23
    5efa:	48 2f       	mov	r20, r24
    5efc:	59 2f       	mov	r21, r25
    5efe:	c5 01       	movw	r24, r10
    5f00:	b4 01       	movw	r22, r8
    5f02:	0e 94 11 3f 	call	0x7e22	; 0x7e22 <__gesf2>
    5f06:	18 16       	cp	r1, r24
    5f08:	34 f0       	brlt	.+12     	; 0x5f16 <limits_go_home+0xce>
    5f0a:	8c 2d       	mov	r24, r12
    5f0c:	9d 2d       	mov	r25, r13
    5f0e:	ae 2d       	mov	r26, r14
    5f10:	bf 2d       	mov	r27, r15
    5f12:	4c 01       	movw	r8, r24
    5f14:	5d 01       	movw	r10, r26
  uint8_t n_cycle = (2*N_HOMING_LOCATE_CYCLE+1);
  uint8_t step_pin[N_AXIS];
  float target[N_AXIS];
  float max_travel = 0.0;
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {
    5f16:	1f 5f       	subi	r17, 0xFF	; 255
    5f18:	13 30       	cpi	r17, 0x03	; 3
    5f1a:	08 f4       	brcc	.+2      	; 0x5f1e <limits_go_home+0xd6>
    5f1c:	c0 cf       	rjmp	.-128    	; 0x5e9e <limits_go_home+0x56>
      max_travel = max(max_travel,(-HOMING_AXIS_SEARCH_SCALAR)*settings.max_travel[idx]);
    }
  }
  // Set search mode with approach at seek rate to quickly engage the specified cycle_mask limit switches.
  bool approach = true;
  float homing_rate = settings.homing_seek_rate;
    5f1e:	40 90 04 0f 	lds	r4, 0x0F04	; 0x800f04 <settings+0x4b>
    5f22:	50 90 05 0f 	lds	r5, 0x0F05	; 0x800f05 <settings+0x4c>
    5f26:	60 90 06 0f 	lds	r6, 0x0F06	; 0x800f06 <settings+0x4d>
    5f2a:	70 90 07 0f 	lds	r7, 0x0F07	; 0x800f07 <settings+0x4e>
      // NOTE: settings.max_travel[] is stored as a negative value.
      max_travel = max(max_travel,(-HOMING_AXIS_SEARCH_SCALAR)*settings.max_travel[idx]);
    }
  }
  // Set search mode with approach at seek rate to quickly engage the specified cycle_mask limit switches.
  bool approach = true;
    5f2e:	ff 24       	eor	r15, r15
    5f30:	f3 94       	inc	r15
  memset(pl_data,0,sizeof(plan_line_data_t));
  pl_data->condition = (PL_COND_FLAG_SYSTEM_MOTION|PL_COND_FLAG_NO_FEED_OVERRIDE);
  pl_data->line_number = HOMING_CYCLE_LINE_NUMBER;

  // Initialize variables used for homing computations.
  uint8_t n_cycle = (2*N_HOMING_LOCATE_CYCLE+1);
    5f32:	0f 2e       	mov	r0, r31
    5f34:	f3 e0       	ldi	r31, 0x03	; 3
    5f36:	ef 2e       	mov	r14, r31
    5f38:	f0 2d       	mov	r31, r0
    5f3a:	01 c0       	rjmp	.+2      	; 0x5f3e <limits_go_home+0xf6>
        homing_rate = settings.homing_feed_rate;
      } else {
        max_travel = settings.homing_pulloff;
        homing_rate = settings.homing_seek_rate;
      }
    } while (n_cycle-- > 0);
    5f3c:	e8 2e       	mov	r14, r24
    } while (n_cycle-- > 0);
  #else
    uint8_t limit_state, axislock, n_active_axis;
    do {

      system_convert_array_steps_to_mpos(target,sys_position);
    5f3e:	61 e3       	ldi	r22, 0x31	; 49
    5f40:	7c e0       	ldi	r23, 0x0C	; 12
    5f42:	ce 01       	movw	r24, r28
    5f44:	41 96       	adiw	r24, 0x11	; 17
    5f46:	0e 94 e6 38 	call	0x71cc	; 0x71cc <system_convert_array_steps_to_mpos>

      // Initialize and declare variables needed for homing routine.
      axislock = 0;
      n_active_axis = 0;
    5f4a:	90 e0       	ldi	r25, 0x00	; 0
    do {

      system_convert_array_steps_to_mpos(target,sys_position);

      // Initialize and declare variables needed for homing routine.
      axislock = 0;
    5f4c:	10 e0       	ldi	r17, 0x00	; 0
      n_active_axis = 0;
      for (idx=0; idx<N_AXIS; idx++) {
    5f4e:	80 e0       	ldi	r24, 0x00	; 0
    5f50:	75 c0       	rjmp	.+234    	; 0x603c <limits_go_home+0x1f4>
        // Set target location for active axes and setup computation for homing rate.
        if (bit_istrue(cycle_mask,bit(idx))) {
    5f52:	68 2f       	mov	r22, r24
    5f54:	70 e0       	ldi	r23, 0x00	; 0
    5f56:	20 2f       	mov	r18, r16
    5f58:	30 e0       	ldi	r19, 0x00	; 0
    5f5a:	08 2e       	mov	r0, r24
    5f5c:	02 c0       	rjmp	.+4      	; 0x5f62 <limits_go_home+0x11a>
    5f5e:	35 95       	asr	r19
    5f60:	27 95       	ror	r18
    5f62:	0a 94       	dec	r0
    5f64:	e2 f7       	brpl	.-8      	; 0x5f5e <limits_go_home+0x116>
    5f66:	20 ff       	sbrs	r18, 0
    5f68:	68 c0       	rjmp	.+208    	; 0x603a <limits_go_home+0x1f2>
          n_active_axis++;
    5f6a:	9f 5f       	subi	r25, 0xFF	; 255
              sys_position[A_MOTOR] = sys_position[B_MOTOR] = axis_position;
            } else {
              sys_position[Z_AXIS] = 0;
            }
          #else
            sys_position[idx] = 0;
    5f6c:	fb 01       	movw	r30, r22
    5f6e:	ee 0f       	add	r30, r30
    5f70:	ff 1f       	adc	r31, r31
    5f72:	ee 0f       	add	r30, r30
    5f74:	ff 1f       	adc	r31, r31
    5f76:	ef 5c       	subi	r30, 0xCF	; 207
    5f78:	f3 4f       	sbci	r31, 0xF3	; 243
    5f7a:	10 82       	st	Z, r1
    5f7c:	11 82       	std	Z+1, r1	; 0x01
    5f7e:	12 82       	std	Z+2, r1	; 0x02
    5f80:	13 82       	std	Z+3, r1	; 0x03
          #endif
          // Set target direction based on cycle mask and homing cycle approach state.
          // NOTE: This happens to compile smaller than any other implementation tried.
          if (bit_istrue(settings.homing_dir_mask,bit(idx))) {
    5f82:	20 91 ff 0e 	lds	r18, 0x0EFF	; 0x800eff <settings+0x46>
    5f86:	30 e0       	ldi	r19, 0x00	; 0
    5f88:	08 2e       	mov	r0, r24
    5f8a:	02 c0       	rjmp	.+4      	; 0x5f90 <limits_go_home+0x148>
    5f8c:	35 95       	asr	r19
    5f8e:	27 95       	ror	r18
    5f90:	0a 94       	dec	r0
    5f92:	e2 f7       	brpl	.-8      	; 0x5f8c <limits_go_home+0x144>
    5f94:	20 ff       	sbrs	r18, 0
    5f96:	25 c0       	rjmp	.+74     	; 0x5fe2 <limits_go_home+0x19a>
            if (approach) { target[idx] = -max_travel; }
    5f98:	ff 20       	and	r15, r15
    5f9a:	99 f0       	breq	.+38     	; 0x5fc2 <limits_go_home+0x17a>
    5f9c:	fb 01       	movw	r30, r22
    5f9e:	ee 0f       	add	r30, r30
    5fa0:	ff 1f       	adc	r31, r31
    5fa2:	ee 0f       	add	r30, r30
    5fa4:	ff 1f       	adc	r31, r31
    5fa6:	21 e0       	ldi	r18, 0x01	; 1
    5fa8:	30 e0       	ldi	r19, 0x00	; 0
    5faa:	2c 0f       	add	r18, r28
    5fac:	3d 1f       	adc	r19, r29
    5fae:	e2 0f       	add	r30, r18
    5fb0:	f3 1f       	adc	r31, r19
    5fb2:	a5 01       	movw	r20, r10
    5fb4:	94 01       	movw	r18, r8
    5fb6:	50 58       	subi	r21, 0x80	; 128
    5fb8:	20 8b       	std	Z+16, r18	; 0x10
    5fba:	31 8b       	std	Z+17, r19	; 0x11
    5fbc:	42 8b       	std	Z+18, r20	; 0x12
    5fbe:	53 8b       	std	Z+19, r21	; 0x13
    5fc0:	34 c0       	rjmp	.+104    	; 0x602a <limits_go_home+0x1e2>
            else { target[idx] = max_travel; }
    5fc2:	fb 01       	movw	r30, r22
    5fc4:	ee 0f       	add	r30, r30
    5fc6:	ff 1f       	adc	r31, r31
    5fc8:	ee 0f       	add	r30, r30
    5fca:	ff 1f       	adc	r31, r31
    5fcc:	41 e0       	ldi	r20, 0x01	; 1
    5fce:	50 e0       	ldi	r21, 0x00	; 0
    5fd0:	4c 0f       	add	r20, r28
    5fd2:	5d 1f       	adc	r21, r29
    5fd4:	e4 0f       	add	r30, r20
    5fd6:	f5 1f       	adc	r31, r21
    5fd8:	80 8a       	std	Z+16, r8	; 0x10
    5fda:	91 8a       	std	Z+17, r9	; 0x11
    5fdc:	a2 8a       	std	Z+18, r10	; 0x12
    5fde:	b3 8a       	std	Z+19, r11	; 0x13
    5fe0:	24 c0       	rjmp	.+72     	; 0x602a <limits_go_home+0x1e2>
          } else {
            if (approach) { target[idx] = max_travel; }
    5fe2:	ff 20       	and	r15, r15
    5fe4:	81 f0       	breq	.+32     	; 0x6006 <limits_go_home+0x1be>
    5fe6:	fb 01       	movw	r30, r22
    5fe8:	ee 0f       	add	r30, r30
    5fea:	ff 1f       	adc	r31, r31
    5fec:	ee 0f       	add	r30, r30
    5fee:	ff 1f       	adc	r31, r31
    5ff0:	a1 e0       	ldi	r26, 0x01	; 1
    5ff2:	b0 e0       	ldi	r27, 0x00	; 0
    5ff4:	ac 0f       	add	r26, r28
    5ff6:	bd 1f       	adc	r27, r29
    5ff8:	ea 0f       	add	r30, r26
    5ffa:	fb 1f       	adc	r31, r27
    5ffc:	80 8a       	std	Z+16, r8	; 0x10
    5ffe:	91 8a       	std	Z+17, r9	; 0x11
    6000:	a2 8a       	std	Z+18, r10	; 0x12
    6002:	b3 8a       	std	Z+19, r11	; 0x13
    6004:	12 c0       	rjmp	.+36     	; 0x602a <limits_go_home+0x1e2>
            else { target[idx] = -max_travel; }
    6006:	fb 01       	movw	r30, r22
    6008:	ee 0f       	add	r30, r30
    600a:	ff 1f       	adc	r31, r31
    600c:	ee 0f       	add	r30, r30
    600e:	ff 1f       	adc	r31, r31
    6010:	21 e0       	ldi	r18, 0x01	; 1
    6012:	30 e0       	ldi	r19, 0x00	; 0
    6014:	2c 0f       	add	r18, r28
    6016:	3d 1f       	adc	r19, r29
    6018:	e2 0f       	add	r30, r18
    601a:	f3 1f       	adc	r31, r19
    601c:	a5 01       	movw	r20, r10
    601e:	94 01       	movw	r18, r8
    6020:	50 58       	subi	r21, 0x80	; 128
    6022:	20 8b       	std	Z+16, r18	; 0x10
    6024:	31 8b       	std	Z+17, r19	; 0x11
    6026:	42 8b       	std	Z+18, r20	; 0x12
    6028:	53 8b       	std	Z+19, r21	; 0x13
          }
          // Apply axislock to the step port pins active in this cycle.
          axislock |= step_pin[idx];
    602a:	ee e0       	ldi	r30, 0x0E	; 14
    602c:	f0 e0       	ldi	r31, 0x00	; 0
    602e:	ec 0f       	add	r30, r28
    6030:	fd 1f       	adc	r31, r29
    6032:	e6 0f       	add	r30, r22
    6034:	f7 1f       	adc	r31, r23
    6036:	20 81       	ld	r18, Z
    6038:	12 2b       	or	r17, r18
      system_convert_array_steps_to_mpos(target,sys_position);

      // Initialize and declare variables needed for homing routine.
      axislock = 0;
      n_active_axis = 0;
      for (idx=0; idx<N_AXIS; idx++) {
    603a:	8f 5f       	subi	r24, 0xFF	; 255
    603c:	83 30       	cpi	r24, 0x03	; 3
    603e:	08 f4       	brcc	.+2      	; 0x6042 <limits_go_home+0x1fa>
    6040:	88 cf       	rjmp	.-240    	; 0x5f52 <limits_go_home+0x10a>
          // Apply axislock to the step port pins active in this cycle.
          axislock |= step_pin[idx];
        }

      }
      homing_rate *= sqrt(n_active_axis); // [sqrt(N_AXIS)] Adjust so individual axes all move at homing rate.
    6042:	89 2e       	mov	r8, r25
    6044:	91 2c       	mov	r9, r1
    6046:	a1 2c       	mov	r10, r1
    6048:	b1 2c       	mov	r11, r1
    604a:	c5 01       	movw	r24, r10
    604c:	b4 01       	movw	r22, r8
    604e:	0e 94 ae 3d 	call	0x7b5c	; 0x7b5c <__floatunsisf>
    6052:	0e 94 d9 3f 	call	0x7fb2	; 0x7fb2 <sqrt>
    6056:	9b 01       	movw	r18, r22
    6058:	ac 01       	movw	r20, r24
    605a:	c3 01       	movw	r24, r6
    605c:	b2 01       	movw	r22, r4
    605e:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
      sys.homing_axis_lock = axislock;
    6062:	0f 2e       	mov	r0, r31
    6064:	f1 e1       	ldi	r31, 0x11	; 17
    6066:	cf 2e       	mov	r12, r31
    6068:	fc e0       	ldi	r31, 0x0C	; 12
    606a:	df 2e       	mov	r13, r31
    606c:	f0 2d       	mov	r31, r0
    606e:	d6 01       	movw	r26, r12
    6070:	16 96       	adiw	r26, 0x06	; 6
    6072:	1c 93       	st	X, r17

      // Perform homing cycle. Planner buffer should be empty, as required to initiate the homing cycle.
      pl_data->feed_rate = homing_rate; // Set current homing rate.
    6074:	69 83       	std	Y+1, r22	; 0x01
    6076:	7a 83       	std	Y+2, r23	; 0x02
    6078:	8b 83       	std	Y+3, r24	; 0x03
    607a:	9c 83       	std	Y+4, r25	; 0x04
      plan_buffer_line(target, pl_data); // Bypass mc_line(). Directly plan homing motion.
    607c:	be 01       	movw	r22, r28
    607e:	6f 5f       	subi	r22, 0xFF	; 255
    6080:	7f 4f       	sbci	r23, 0xFF	; 255
    6082:	ce 01       	movw	r24, r28
    6084:	41 96       	adiw	r24, 0x11	; 17
    6086:	82 d9       	rcall	.-3324   	; 0x538c <plan_buffer_line>

      sys.step_control = STEP_CONTROL_EXECUTE_SYS_MOTION; // Set to execute homing motion and clear existing flags.
    6088:	84 e0       	ldi	r24, 0x04	; 4
    608a:	f6 01       	movw	r30, r12
    608c:	84 83       	std	Z+4, r24	; 0x04
      st_prep_buffer(); // Prep and fill segment buffer from newly planned block.
    608e:	0e 94 86 1b 	call	0x370c	; 0x370c <st_prep_buffer>
      st_wake_up(); // Initiate motion
    6092:	0e 94 6e 18 	call	0x30dc	; 0x30dc <st_wake_up>
      do {
        if (approach) {
    6096:	ff 20       	and	r15, r15
          // Check limit state. Lock out cycle axes when they change.
          limit_state = limits_get_state();
    6098:	f1 f0       	breq	.+60     	; 0x60d6 <limits_go_home+0x28e>
    609a:	7c de       	rcall	.-776    	; 0x5d94 <limits_get_state>
          for (idx=0; idx<N_AXIS; idx++) {
    609c:	90 e0       	ldi	r25, 0x00	; 0
    609e:	17 c0       	rjmp	.+46     	; 0x60ce <limits_go_home+0x286>
            if (axislock & step_pin[idx]) {
    60a0:	ee e0       	ldi	r30, 0x0E	; 14
    60a2:	f0 e0       	ldi	r31, 0x00	; 0
    60a4:	ec 0f       	add	r30, r28
    60a6:	fd 1f       	adc	r31, r29
    60a8:	e9 0f       	add	r30, r25
    60aa:	f1 1d       	adc	r31, r1
    60ac:	20 81       	ld	r18, Z
    60ae:	31 2f       	mov	r19, r17
    60b0:	32 23       	and	r19, r18
    60b2:	61 f0       	breq	.+24     	; 0x60cc <limits_go_home+0x284>
              if (limit_state & (1 << idx)) {
    60b4:	48 2f       	mov	r20, r24
    60b6:	50 e0       	ldi	r21, 0x00	; 0
    60b8:	09 2e       	mov	r0, r25
    60ba:	02 c0       	rjmp	.+4      	; 0x60c0 <limits_go_home+0x278>
    60bc:	55 95       	asr	r21
    60be:	47 95       	ror	r20
    60c0:	0a 94       	dec	r0
    60c2:	e2 f7       	brpl	.-8      	; 0x60bc <limits_go_home+0x274>
    60c4:	40 ff       	sbrs	r20, 0
    60c6:	02 c0       	rjmp	.+4      	; 0x60cc <limits_go_home+0x284>
                #ifdef COREXY
                  if (idx==Z_AXIS) { axislock &= ~(step_pin[Z_AXIS]); }
                  else { axislock &= ~(step_pin[A_MOTOR]|step_pin[B_MOTOR]); }
                #else
                  axislock &= ~(step_pin[idx]);
    60c8:	20 95       	com	r18
    60ca:	12 23       	and	r17, r18
      st_wake_up(); // Initiate motion
      do {
        if (approach) {
          // Check limit state. Lock out cycle axes when they change.
          limit_state = limits_get_state();
          for (idx=0; idx<N_AXIS; idx++) {
    60cc:	9f 5f       	subi	r25, 0xFF	; 255
    60ce:	93 30       	cpi	r25, 0x03	; 3
    60d0:	38 f3       	brcs	.-50     	; 0x60a0 <limits_go_home+0x258>
                  axislock &= ~(step_pin[idx]);
                #endif
              }
            }
          }
          sys.homing_axis_lock = axislock;
    60d2:	10 93 17 0c 	sts	0x0C17, r17	; 0x800c17 <sys+0x6>
        }

        st_prep_buffer(); // Check and prep segment buffer. NOTE: Should take no longer than 200us.
    60d6:	0e 94 86 1b 	call	0x370c	; 0x370c <st_prep_buffer>

        // Exit routines: No time to run protocol_execute_realtime() in this loop.
        if (sys_rt_exec_state & (EXEC_SAFETY_DOOR | EXEC_RESET | EXEC_CYCLE_STOP)) {
    60da:	90 91 23 0c 	lds	r25, 0x0C23	; 0x800c23 <sys_rt_exec_state>
    60de:	94 73       	andi	r25, 0x34	; 52
    60e0:	41 f1       	breq	.+80     	; 0x6132 <limits_go_home+0x2ea>
          uint8_t rt_exec = sys_rt_exec_state;
    60e2:	10 91 23 0c 	lds	r17, 0x0C23	; 0x800c23 <sys_rt_exec_state>
          // Homing failure condition: Reset issued during cycle.
          if (rt_exec & EXEC_RESET) { system_set_exec_alarm(EXEC_ALARM_HOMING_FAIL_RESET); }
    60e6:	14 ff       	sbrs	r17, 4
    60e8:	03 c0       	rjmp	.+6      	; 0x60f0 <limits_go_home+0x2a8>
    60ea:	86 e0       	ldi	r24, 0x06	; 6
    60ec:	0e 94 a4 3b 	call	0x7748	; 0x7748 <system_set_exec_alarm>
          // Homing failure condition: Safety door was opened.
          if (rt_exec & EXEC_SAFETY_DOOR) { system_set_exec_alarm(EXEC_ALARM_HOMING_FAIL_DOOR); }
    60f0:	15 ff       	sbrs	r17, 5
    60f2:	03 c0       	rjmp	.+6      	; 0x60fa <limits_go_home+0x2b2>
    60f4:	87 e0       	ldi	r24, 0x07	; 7
    60f6:	0e 94 a4 3b 	call	0x7748	; 0x7748 <system_set_exec_alarm>
          // Homing failure condition: Limit switch still engaged after pull-off motion
          if (!approach && (limits_get_state() & cycle_mask)) { system_set_exec_alarm(EXEC_ALARM_HOMING_FAIL_PULLOFF); }
    60fa:	f1 10       	cpse	r15, r1
    60fc:	06 c0       	rjmp	.+12     	; 0x610a <limits_go_home+0x2c2>
    60fe:	4a de       	rcall	.-876    	; 0x5d94 <limits_get_state>
    6100:	80 23       	and	r24, r16
    6102:	19 f0       	breq	.+6      	; 0x610a <limits_go_home+0x2c2>
    6104:	88 e0       	ldi	r24, 0x08	; 8
    6106:	0e 94 a4 3b 	call	0x7748	; 0x7748 <system_set_exec_alarm>
          // Homing failure condition: Limit switch not found during approach.
          if (approach && (rt_exec & EXEC_CYCLE_STOP)) { system_set_exec_alarm(EXEC_ALARM_HOMING_FAIL_APPROACH); }
    610a:	ff 20       	and	r15, r15
    610c:	29 f0       	breq	.+10     	; 0x6118 <limits_go_home+0x2d0>
    610e:	12 ff       	sbrs	r17, 2
    6110:	03 c0       	rjmp	.+6      	; 0x6118 <limits_go_home+0x2d0>
    6112:	89 e0       	ldi	r24, 0x09	; 9
    6114:	0e 94 a4 3b 	call	0x7748	; 0x7748 <system_set_exec_alarm>
          if (sys_rt_exec_alarm) {
    6118:	80 91 3d 0c 	lds	r24, 0x0C3D	; 0x800c3d <sys_rt_exec_alarm>
    611c:	88 23       	and	r24, r24
    611e:	29 f0       	breq	.+10     	; 0x612a <limits_go_home+0x2e2>
            mc_reset(); // Stop motors, if they are running.
    6120:	0e 94 ac 06 	call	0xd58	; 0xd58 <mc_reset>
            protocol_execute_realtime();
    6124:	0e 94 b2 17 	call	0x2f64	; 0x2f64 <protocol_execute_realtime>
            return;
    6128:	a9 c0       	rjmp	.+338    	; 0x627c <limits_go_home+0x434>
          } else {
            // Pull-off motion complete. Disable CYCLE_STOP from executing.
            system_clear_exec_state_flag(EXEC_CYCLE_STOP);
    612a:	84 e0       	ldi	r24, 0x04	; 4
    612c:	0e 94 9a 3b 	call	0x7734	; 0x7734 <system_clear_exec_state_flag>
            break;
    6130:	04 c0       	rjmp	.+8      	; 0x613a <limits_go_home+0x2f2>
          }
        }

      } while (STEP_MASK & axislock);
    6132:	91 2f       	mov	r25, r17
    6134:	9c 71       	andi	r25, 0x1C	; 28
    6136:	09 f0       	breq	.+2      	; 0x613a <limits_go_home+0x2f2>
    6138:	ae cf       	rjmp	.-164    	; 0x6096 <limits_go_home+0x24e>
      st_reset(); // Immediately force kill steppers and reset step segment buffer.
    613a:	0e 94 11 1b 	call	0x3622	; 0x3622 <st_reset>
      delay_ms(settings.homing_debounce_delay); // Delay to allow transient dynamics to dissipate.
    613e:	80 91 08 0f 	lds	r24, 0x0F08	; 0x800f08 <settings+0x4f>
    6142:	90 91 09 0f 	lds	r25, 0x0F09	; 0x800f09 <settings+0x50>
    6146:	f0 dc       	rcall	.-1568   	; 0x5b28 <delay_ms>

      // Reverse direction and reset homing rate for locate cycle(s).
      approach = !approach;
    6148:	81 e0       	ldi	r24, 0x01	; 1
    614a:	f8 26       	eor	r15, r24

      // After first cycle, homing enters locating phase. Shorten search to pull-off distance.
      if (approach) {
    614c:	c9 f0       	breq	.+50     	; 0x6180 <limits_go_home+0x338>
        max_travel = settings.homing_pulloff*HOMING_AXIS_LOCATE_SCALAR;
    614e:	60 91 0a 0f 	lds	r22, 0x0F0A	; 0x800f0a <settings+0x51>
    6152:	70 91 0b 0f 	lds	r23, 0x0F0B	; 0x800f0b <settings+0x52>
    6156:	80 91 0c 0f 	lds	r24, 0x0F0C	; 0x800f0c <settings+0x53>
    615a:	90 91 0d 0f 	lds	r25, 0x0F0D	; 0x800f0d <settings+0x54>
    615e:	20 e0       	ldi	r18, 0x00	; 0
    6160:	30 e0       	ldi	r19, 0x00	; 0
    6162:	40 ea       	ldi	r20, 0xA0	; 160
    6164:	50 e4       	ldi	r21, 0x40	; 64
    6166:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
    616a:	4b 01       	movw	r8, r22
    616c:	5c 01       	movw	r10, r24
        homing_rate = settings.homing_feed_rate;
    616e:	40 90 00 0f 	lds	r4, 0x0F00	; 0x800f00 <settings+0x47>
    6172:	50 90 01 0f 	lds	r5, 0x0F01	; 0x800f01 <settings+0x48>
    6176:	60 90 02 0f 	lds	r6, 0x0F02	; 0x800f02 <settings+0x49>
    617a:	70 90 03 0f 	lds	r7, 0x0F03	; 0x800f03 <settings+0x4a>
    617e:	10 c0       	rjmp	.+32     	; 0x61a0 <limits_go_home+0x358>
      } else {
        max_travel = settings.homing_pulloff;
    6180:	80 90 0a 0f 	lds	r8, 0x0F0A	; 0x800f0a <settings+0x51>
    6184:	90 90 0b 0f 	lds	r9, 0x0F0B	; 0x800f0b <settings+0x52>
    6188:	a0 90 0c 0f 	lds	r10, 0x0F0C	; 0x800f0c <settings+0x53>
    618c:	b0 90 0d 0f 	lds	r11, 0x0F0D	; 0x800f0d <settings+0x54>
        homing_rate = settings.homing_seek_rate;
    6190:	40 90 04 0f 	lds	r4, 0x0F04	; 0x800f04 <settings+0x4b>
    6194:	50 90 05 0f 	lds	r5, 0x0F05	; 0x800f05 <settings+0x4c>
    6198:	60 90 06 0f 	lds	r6, 0x0F06	; 0x800f06 <settings+0x4d>
    619c:	70 90 07 0f 	lds	r7, 0x0F07	; 0x800f07 <settings+0x4e>
      }
    } while (n_cycle-- > 0);
    61a0:	8f ef       	ldi	r24, 0xFF	; 255
    61a2:	8e 0d       	add	r24, r14
    61a4:	e1 10       	cpse	r14, r1
    61a6:	ca ce       	rjmp	.-620    	; 0x5f3c <limits_go_home+0xf4>
    61a8:	10 e0       	ldi	r17, 0x00	; 0
    61aa:	63 c0       	rjmp	.+198    	; 0x6272 <limits_go_home+0x42a>
  // triggering when hard limits are enabled or when more than one axes shares a limit pin.
  int32_t set_axis_position;
  // Set machine positions for homed limit switches. Don't update non-homed axes.
  for (idx=0; idx<N_AXIS; idx++) {
    // NOTE: settings.max_travel[] is stored as a negative value.
    if (cycle_mask & bit(idx)) {
    61ac:	e1 2e       	mov	r14, r17
    61ae:	f1 2c       	mov	r15, r1
    61b0:	80 2f       	mov	r24, r16
    61b2:	90 e0       	ldi	r25, 0x00	; 0
    61b4:	01 2e       	mov	r0, r17
    61b6:	02 c0       	rjmp	.+4      	; 0x61bc <limits_go_home+0x374>
    61b8:	95 95       	asr	r25
    61ba:	87 95       	ror	r24
    61bc:	0a 94       	dec	r0
    61be:	e2 f7       	brpl	.-8      	; 0x61b8 <limits_go_home+0x370>
    61c0:	80 ff       	sbrs	r24, 0
    61c2:	56 c0       	rjmp	.+172    	; 0x6270 <limits_go_home+0x428>
      #ifdef HOMING_FORCE_SET_ORIGIN
        set_axis_position = 0;
      #else
        if ( bit_istrue(settings.homing_dir_mask,bit(idx)) ) {
    61c4:	80 91 ff 0e 	lds	r24, 0x0EFF	; 0x800eff <settings+0x46>
    61c8:	90 e0       	ldi	r25, 0x00	; 0
    61ca:	01 2e       	mov	r0, r17
    61cc:	02 c0       	rjmp	.+4      	; 0x61d2 <limits_go_home+0x38a>
    61ce:	95 95       	asr	r25
    61d0:	87 95       	ror	r24
    61d2:	0a 94       	dec	r0
    61d4:	e2 f7       	brpl	.-8      	; 0x61ce <limits_go_home+0x386>
    61d6:	80 ff       	sbrs	r24, 0
    61d8:	26 c0       	rjmp	.+76     	; 0x6226 <limits_go_home+0x3de>
          set_axis_position = lround((settings.max_travel[idx]+settings.homing_pulloff)*settings.steps_per_mm[idx]);
    61da:	f7 01       	movw	r30, r14
    61dc:	39 96       	adiw	r30, 0x09	; 9
    61de:	ee 0f       	add	r30, r30
    61e0:	ff 1f       	adc	r31, r31
    61e2:	ee 0f       	add	r30, r30
    61e4:	ff 1f       	adc	r31, r31
    61e6:	e7 54       	subi	r30, 0x47	; 71
    61e8:	f1 4f       	sbci	r31, 0xF1	; 241
    61ea:	60 81       	ld	r22, Z
    61ec:	71 81       	ldd	r23, Z+1	; 0x01
    61ee:	82 81       	ldd	r24, Z+2	; 0x02
    61f0:	93 81       	ldd	r25, Z+3	; 0x03
    61f2:	20 91 0a 0f 	lds	r18, 0x0F0A	; 0x800f0a <settings+0x51>
    61f6:	30 91 0b 0f 	lds	r19, 0x0F0B	; 0x800f0b <settings+0x52>
    61fa:	40 91 0c 0f 	lds	r20, 0x0F0C	; 0x800f0c <settings+0x53>
    61fe:	50 91 0d 0f 	lds	r21, 0x0F0D	; 0x800f0d <settings+0x54>
    6202:	0e 94 35 3c 	call	0x786a	; 0x786a <__addsf3>
    6206:	f7 01       	movw	r30, r14
    6208:	ee 0f       	add	r30, r30
    620a:	ff 1f       	adc	r31, r31
    620c:	ee 0f       	add	r30, r30
    620e:	ff 1f       	adc	r31, r31
    6210:	e7 54       	subi	r30, 0x47	; 71
    6212:	f1 4f       	sbci	r31, 0xF1	; 241
    6214:	20 81       	ld	r18, Z
    6216:	31 81       	ldd	r19, Z+1	; 0x01
    6218:	42 81       	ldd	r20, Z+2	; 0x02
    621a:	53 81       	ldd	r21, Z+3	; 0x03
    621c:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
    6220:	0e 94 1c 3f 	call	0x7e38	; 0x7e38 <lround>
    6224:	1a c0       	rjmp	.+52     	; 0x625a <limits_go_home+0x412>
        } else {
          set_axis_position = lround(-settings.homing_pulloff*settings.steps_per_mm[idx]);
    6226:	80 91 0a 0f 	lds	r24, 0x0F0A	; 0x800f0a <settings+0x51>
    622a:	90 91 0b 0f 	lds	r25, 0x0F0B	; 0x800f0b <settings+0x52>
    622e:	a0 91 0c 0f 	lds	r26, 0x0F0C	; 0x800f0c <settings+0x53>
    6232:	b0 91 0d 0f 	lds	r27, 0x0F0D	; 0x800f0d <settings+0x54>
    6236:	bc 01       	movw	r22, r24
    6238:	cd 01       	movw	r24, r26
    623a:	90 58       	subi	r25, 0x80	; 128
    623c:	f7 01       	movw	r30, r14
    623e:	ee 0f       	add	r30, r30
    6240:	ff 1f       	adc	r31, r31
    6242:	ee 0f       	add	r30, r30
    6244:	ff 1f       	adc	r31, r31
    6246:	e7 54       	subi	r30, 0x47	; 71
    6248:	f1 4f       	sbci	r31, 0xF1	; 241
    624a:	20 81       	ld	r18, Z
    624c:	31 81       	ldd	r19, Z+1	; 0x01
    624e:	42 81       	ldd	r20, Z+2	; 0x02
    6250:	53 81       	ldd	r21, Z+3	; 0x03
    6252:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
    6256:	0e 94 1c 3f 	call	0x7e38	; 0x7e38 <lround>
          sys_position[B_MOTOR] = off_axis_position - set_axis_position;
        } else {
          sys_position[idx] = set_axis_position;
        }
      #else
        sys_position[idx] = set_axis_position;
    625a:	f7 01       	movw	r30, r14
    625c:	ee 0f       	add	r30, r30
    625e:	ff 1f       	adc	r31, r31
    6260:	ee 0f       	add	r30, r30
    6262:	ff 1f       	adc	r31, r31
    6264:	ef 5c       	subi	r30, 0xCF	; 207
    6266:	f3 4f       	sbci	r31, 0xF3	; 243
    6268:	60 83       	st	Z, r22
    626a:	71 83       	std	Z+1, r23	; 0x01
    626c:	82 83       	std	Z+2, r24	; 0x02
    626e:	93 83       	std	Z+3, r25	; 0x03
  // set up pull-off maneuver from axes limit switches that have been homed. This provides
  // some initial clearance off the switches and should also help prevent them from falsely
  // triggering when hard limits are enabled or when more than one axes shares a limit pin.
  int32_t set_axis_position;
  // Set machine positions for homed limit switches. Don't update non-homed axes.
  for (idx=0; idx<N_AXIS; idx++) {
    6270:	1f 5f       	subi	r17, 0xFF	; 255
    6272:	13 30       	cpi	r17, 0x03	; 3
    6274:	08 f4       	brcc	.+2      	; 0x6278 <limits_go_home+0x430>
    6276:	9a cf       	rjmp	.-204    	; 0x61ac <limits_go_home+0x364>
        sys_position[idx] = set_axis_position;
      #endif

    }
  }
  sys.step_control = STEP_CONTROL_NORMAL_OP; // Return step control to normal operation.
    6278:	10 92 15 0c 	sts	0x0C15, r1	; 0x800c15 <sys+0x4>
}
    627c:	a0 96       	adiw	r28, 0x20	; 32
    627e:	0f b6       	in	r0, 0x3f	; 63
    6280:	f8 94       	cli
    6282:	de bf       	out	0x3e, r29	; 62
    6284:	0f be       	out	0x3f, r0	; 63
    6286:	cd bf       	out	0x3d, r28	; 61
    6288:	df 91       	pop	r29
    628a:	cf 91       	pop	r28
    628c:	1f 91       	pop	r17
    628e:	0f 91       	pop	r16
    6290:	ff 90       	pop	r15
    6292:	ef 90       	pop	r14
    6294:	df 90       	pop	r13
    6296:	cf 90       	pop	r12
    6298:	bf 90       	pop	r11
    629a:	af 90       	pop	r10
    629c:	9f 90       	pop	r9
    629e:	8f 90       	pop	r8
    62a0:	7f 90       	pop	r7
    62a2:	6f 90       	pop	r6
    62a4:	5f 90       	pop	r5
    62a6:	4f 90       	pop	r4
    62a8:	08 95       	ret

000062aa <limits_soft_check>:
// Performs a soft limit check. Called from mc_line() only. Assumes the machine has been homed,
// the workspace volume is in all negative space, and the system is in normal operation.
// NOTE: Used by jogging to limit travel within soft-limit volume.
void limits_soft_check(float *target)
{
  if (system_check_travel_limits(target)) {
    62aa:	b5 d7       	rcall	.+3946   	; 0x7216 <system_check_travel_limits>
    62ac:	88 23       	and	r24, r24
    62ae:	c9 f0       	breq	.+50     	; 0x62e2 <limits_soft_check+0x38>
    sys.soft_limit = true;
    62b0:	e1 e1       	ldi	r30, 0x11	; 17
    62b2:	fc e0       	ldi	r31, 0x0C	; 12
    62b4:	81 e0       	ldi	r24, 0x01	; 1
    62b6:	83 83       	std	Z+3, r24	; 0x03
    // Force feed hold if cycle is active. All buffered blocks are guaranteed to be within
    // workspace volume so just come to a controlled stop so position is not lost. When complete
    // enter alarm mode.
    if (sys.state == STATE_CYCLE) {
    62b8:	80 81       	ld	r24, Z
    62ba:	88 30       	cpi	r24, 0x08	; 8
      system_set_exec_state_flag(EXEC_FEED_HOLD);
    62bc:	59 f4       	brne	.+22     	; 0x62d4 <limits_soft_check+0x2a>
    62be:	eb d7       	rcall	.+4054   	; 0x7296 <system_set_exec_state_flag>
      do {
        protocol_execute_realtime();
    62c0:	0e 94 b2 17 	call	0x2f64	; 0x2f64 <protocol_execute_realtime>
        if (sys.abort) { return; }
    62c4:	80 91 12 0c 	lds	r24, 0x0C12	; 0x800c12 <sys+0x1>
    62c8:	81 11       	cpse	r24, r1
    62ca:	0b c0       	rjmp	.+22     	; 0x62e2 <limits_soft_check+0x38>
      } while ( sys.state != STATE_IDLE );
    62cc:	80 91 11 0c 	lds	r24, 0x0C11	; 0x800c11 <sys>
    62d0:	81 11       	cpse	r24, r1
    62d2:	f6 cf       	rjmp	.-20     	; 0x62c0 <limits_soft_check+0x16>
    }
    mc_reset(); // Issue system reset and ensure spindle and coolant are shutdown.
    62d4:	0e 94 ac 06 	call	0xd58	; 0xd58 <mc_reset>
    system_set_exec_alarm(EXEC_ALARM_SOFT_LIMIT); // Indicate soft limit critical event
    62d8:	82 e0       	ldi	r24, 0x02	; 2
    62da:	0e 94 a4 3b 	call	0x7748	; 0x7748 <system_set_exec_alarm>
    protocol_execute_realtime(); // Execute to enter critical event loop and system abort
    62de:	0c 94 b2 17 	jmp	0x2f64	; 0x2f64 <protocol_execute_realtime>
    62e2:	08 95       	ret

000062e4 <printString>:
      n /= 2;
  }

  for (; i > 0; i--)
      serial_write('0' + buf[i - 1]);
}
    62e4:	cf 93       	push	r28
    62e6:	df 93       	push	r29
    62e8:	ec 01       	movw	r28, r24
    62ea:	03 c0       	rjmp	.+6      	; 0x62f2 <printString+0xe>
    62ec:	21 96       	adiw	r28, 0x01	; 1
    62ee:	0e 94 ef 13 	call	0x27de	; 0x27de <serial_write>
    62f2:	88 81       	ld	r24, Y
    62f4:	81 11       	cpse	r24, r1
    62f6:	fa cf       	rjmp	.-12     	; 0x62ec <printString+0x8>
    62f8:	df 91       	pop	r29
    62fa:	cf 91       	pop	r28
    62fc:	08 95       	ret

000062fe <printPgmString>:
    62fe:	cf 93       	push	r28
    6300:	df 93       	push	r29
    6302:	fc 01       	movw	r30, r24
    6304:	03 c0       	rjmp	.+6      	; 0x630c <printPgmString+0xe>
    6306:	0e 94 ef 13 	call	0x27de	; 0x27de <serial_write>
    630a:	fe 01       	movw	r30, r28
    630c:	ef 01       	movw	r28, r30
    630e:	21 96       	adiw	r28, 0x01	; 1
    6310:	84 91       	lpm	r24, Z
    6312:	81 11       	cpse	r24, r1
    6314:	f8 cf       	rjmp	.-16     	; 0x6306 <printPgmString+0x8>
    6316:	df 91       	pop	r29
    6318:	cf 91       	pop	r28
    631a:	08 95       	ret

0000631c <print_uint8_base10>:
    631c:	cf 93       	push	r28
    631e:	df 93       	push	r29
    6320:	84 36       	cpi	r24, 0x64	; 100
    6322:	90 f0       	brcs	.+36     	; 0x6348 <print_uint8_base10+0x2c>
    6324:	9d ec       	ldi	r25, 0xCD	; 205
    6326:	89 9f       	mul	r24, r25
    6328:	91 2d       	mov	r25, r1
    632a:	11 24       	eor	r1, r1
    632c:	96 95       	lsr	r25
    632e:	96 95       	lsr	r25
    6330:	96 95       	lsr	r25
    6332:	39 2f       	mov	r19, r25
    6334:	33 0f       	add	r19, r19
    6336:	23 2f       	mov	r18, r19
    6338:	22 0f       	add	r18, r18
    633a:	22 0f       	add	r18, r18
    633c:	23 0f       	add	r18, r19
    633e:	82 1b       	sub	r24, r18
    6340:	c0 e3       	ldi	r28, 0x30	; 48
    6342:	c8 0f       	add	r28, r24
    6344:	89 2f       	mov	r24, r25
    6346:	01 c0       	rjmp	.+2      	; 0x634a <print_uint8_base10+0x2e>
    6348:	c0 e0       	ldi	r28, 0x00	; 0
    634a:	8a 30       	cpi	r24, 0x0A	; 10
    634c:	90 f0       	brcs	.+36     	; 0x6372 <print_uint8_base10+0x56>
    634e:	9d ec       	ldi	r25, 0xCD	; 205
    6350:	89 9f       	mul	r24, r25
    6352:	91 2d       	mov	r25, r1
    6354:	11 24       	eor	r1, r1
    6356:	96 95       	lsr	r25
    6358:	96 95       	lsr	r25
    635a:	96 95       	lsr	r25
    635c:	39 2f       	mov	r19, r25
    635e:	33 0f       	add	r19, r19
    6360:	23 2f       	mov	r18, r19
    6362:	22 0f       	add	r18, r18
    6364:	22 0f       	add	r18, r18
    6366:	23 0f       	add	r18, r19
    6368:	82 1b       	sub	r24, r18
    636a:	d0 e3       	ldi	r29, 0x30	; 48
    636c:	d8 0f       	add	r29, r24
    636e:	89 2f       	mov	r24, r25
    6370:	01 c0       	rjmp	.+2      	; 0x6374 <print_uint8_base10+0x58>
    6372:	d0 e0       	ldi	r29, 0x00	; 0
    6374:	80 5d       	subi	r24, 0xD0	; 208
    6376:	0e 94 ef 13 	call	0x27de	; 0x27de <serial_write>
    637a:	dd 23       	and	r29, r29
    637c:	19 f0       	breq	.+6      	; 0x6384 <print_uint8_base10+0x68>
    637e:	8d 2f       	mov	r24, r29
    6380:	0e 94 ef 13 	call	0x27de	; 0x27de <serial_write>
    6384:	cc 23       	and	r28, r28
    6386:	19 f0       	breq	.+6      	; 0x638e <print_uint8_base10+0x72>
    6388:	8c 2f       	mov	r24, r28
    638a:	0e 94 ef 13 	call	0x27de	; 0x27de <serial_write>
    638e:	df 91       	pop	r29
    6390:	cf 91       	pop	r28
    6392:	08 95       	ret

00006394 <print_uint32_base10>:


void print_uint32_base10(uint32_t n)
{
    6394:	1f 93       	push	r17
    6396:	cf 93       	push	r28
    6398:	df 93       	push	r29
    639a:	cd b7       	in	r28, 0x3d	; 61
    639c:	de b7       	in	r29, 0x3e	; 62
    639e:	2a 97       	sbiw	r28, 0x0a	; 10
    63a0:	0f b6       	in	r0, 0x3f	; 63
    63a2:	f8 94       	cli
    63a4:	de bf       	out	0x3e, r29	; 62
    63a6:	0f be       	out	0x3f, r0	; 63
    63a8:	cd bf       	out	0x3d, r28	; 61
  if (n == 0) {
    63aa:	61 15       	cp	r22, r1
    63ac:	71 05       	cpc	r23, r1
    63ae:	81 05       	cpc	r24, r1
    63b0:	91 05       	cpc	r25, r1
    63b2:	b9 f4       	brne	.+46     	; 0x63e2 <print_uint32_base10+0x4e>
    serial_write('0');
    63b4:	80 e3       	ldi	r24, 0x30	; 48
    63b6:	0e 94 ef 13 	call	0x27de	; 0x27de <serial_write>
    63ba:	2a c0       	rjmp	.+84     	; 0x6410 <print_uint32_base10+0x7c>

  unsigned char buf[10];
  uint8_t i = 0;

  while (n > 0) {
    buf[i++] = n % 10;
    63bc:	2a e0       	ldi	r18, 0x0A	; 10
    63be:	30 e0       	ldi	r19, 0x00	; 0
    63c0:	40 e0       	ldi	r20, 0x00	; 0
    63c2:	50 e0       	ldi	r21, 0x00	; 0
    63c4:	0e 94 39 40 	call	0x8072	; 0x8072 <__udivmodsi4>
    63c8:	e1 e0       	ldi	r30, 0x01	; 1
    63ca:	f0 e0       	ldi	r31, 0x00	; 0
    63cc:	ec 0f       	add	r30, r28
    63ce:	fd 1f       	adc	r31, r29
    63d0:	e1 0f       	add	r30, r17
    63d2:	f1 1d       	adc	r31, r1
    63d4:	60 83       	st	Z, r22
    n /= 10;
    63d6:	62 2f       	mov	r22, r18
    63d8:	73 2f       	mov	r23, r19
    63da:	84 2f       	mov	r24, r20
    63dc:	95 2f       	mov	r25, r21

  unsigned char buf[10];
  uint8_t i = 0;

  while (n > 0) {
    buf[i++] = n % 10;
    63de:	1f 5f       	subi	r17, 0xFF	; 255
    63e0:	01 c0       	rjmp	.+2      	; 0x63e4 <print_uint32_base10+0x50>
    63e2:	10 e0       	ldi	r17, 0x00	; 0
  }

  unsigned char buf[10];
  uint8_t i = 0;

  while (n > 0) {
    63e4:	61 15       	cp	r22, r1
    63e6:	71 05       	cpc	r23, r1
    63e8:	81 05       	cpc	r24, r1
    63ea:	91 05       	cpc	r25, r1
    63ec:	39 f7       	brne	.-50     	; 0x63bc <print_uint32_base10+0x28>
    63ee:	0e c0       	rjmp	.+28     	; 0x640c <print_uint32_base10+0x78>
    buf[i++] = n % 10;
    n /= 10;
  }

  for (; i > 0; i--)
    serial_write('0' + buf[i-1]);
    63f0:	e1 2f       	mov	r30, r17
    63f2:	f0 e0       	ldi	r31, 0x00	; 0
    63f4:	31 97       	sbiw	r30, 0x01	; 1
    63f6:	81 e0       	ldi	r24, 0x01	; 1
    63f8:	90 e0       	ldi	r25, 0x00	; 0
    63fa:	8c 0f       	add	r24, r28
    63fc:	9d 1f       	adc	r25, r29
    63fe:	e8 0f       	add	r30, r24
    6400:	f9 1f       	adc	r31, r25
    6402:	80 81       	ld	r24, Z
    6404:	80 5d       	subi	r24, 0xD0	; 208
    6406:	0e 94 ef 13 	call	0x27de	; 0x27de <serial_write>
  while (n > 0) {
    buf[i++] = n % 10;
    n /= 10;
  }

  for (; i > 0; i--)
    640a:	11 50       	subi	r17, 0x01	; 1
    640c:	11 11       	cpse	r17, r1
    640e:	f0 cf       	rjmp	.-32     	; 0x63f0 <print_uint32_base10+0x5c>
    serial_write('0' + buf[i-1]);
}
    6410:	2a 96       	adiw	r28, 0x0a	; 10
    6412:	0f b6       	in	r0, 0x3f	; 63
    6414:	f8 94       	cli
    6416:	de bf       	out	0x3e, r29	; 62
    6418:	0f be       	out	0x3f, r0	; 63
    641a:	cd bf       	out	0x3d, r28	; 61
    641c:	df 91       	pop	r29
    641e:	cf 91       	pop	r28
    6420:	1f 91       	pop	r17
    6422:	08 95       	ret

00006424 <printInteger>:


void printInteger(long n)
{
    6424:	cf 92       	push	r12
    6426:	df 92       	push	r13
    6428:	ef 92       	push	r14
    642a:	ff 92       	push	r15
    642c:	6b 01       	movw	r12, r22
    642e:	7c 01       	movw	r14, r24
  if (n < 0) {
    6430:	99 23       	and	r25, r25
    6432:	64 f4       	brge	.+24     	; 0x644c <printInteger+0x28>
    serial_write('-');
    6434:	8d e2       	ldi	r24, 0x2D	; 45
    6436:	0e 94 ef 13 	call	0x27de	; 0x27de <serial_write>
    print_uint32_base10(-n);
    643a:	66 27       	eor	r22, r22
    643c:	77 27       	eor	r23, r23
    643e:	cb 01       	movw	r24, r22
    6440:	6c 19       	sub	r22, r12
    6442:	7d 09       	sbc	r23, r13
    6444:	8e 09       	sbc	r24, r14
    6446:	9f 09       	sbc	r25, r15
    6448:	a5 df       	rcall	.-182    	; 0x6394 <print_uint32_base10>
    644a:	01 c0       	rjmp	.+2      	; 0x644e <printInteger+0x2a>
  } else {
    print_uint32_base10(n);
    644c:	a3 df       	rcall	.-186    	; 0x6394 <print_uint32_base10>
    644e:	ff 90       	pop	r15
  }
}
    6450:	ef 90       	pop	r14
    6452:	df 90       	pop	r13
    6454:	cf 90       	pop	r12
    6456:	08 95       	ret

00006458 <printFloat>:
    6458:	cf 92       	push	r12
// more digits than a float. Number of decimal places, which are tracked by a counter,
// may be set by the user. The integer is then efficiently converted to a string.
// NOTE: AVR '%' and '/' integer operations are very efficient. Bitshifting speed-up
// techniques are actually just slightly slower. Found this out the hard way.
void printFloat(float n, uint8_t decimal_places)
{
    645a:	df 92       	push	r13
    645c:	ef 92       	push	r14
    645e:	ff 92       	push	r15
    6460:	0f 93       	push	r16
    6462:	1f 93       	push	r17
    6464:	cf 93       	push	r28
    6466:	df 93       	push	r29
    6468:	cd b7       	in	r28, 0x3d	; 61
    646a:	de b7       	in	r29, 0x3e	; 62
    646c:	2d 97       	sbiw	r28, 0x0d	; 13
    646e:	0f b6       	in	r0, 0x3f	; 63
    6470:	f8 94       	cli
    6472:	de bf       	out	0x3e, r29	; 62
    6474:	0f be       	out	0x3f, r0	; 63
    6476:	cd bf       	out	0x3d, r28	; 61
    6478:	6b 01       	movw	r12, r22
    647a:	7c 01       	movw	r14, r24
    647c:	04 2f       	mov	r16, r20
  if (n < 0) {
    647e:	20 e0       	ldi	r18, 0x00	; 0
    6480:	30 e0       	ldi	r19, 0x00	; 0
    6482:	a9 01       	movw	r20, r18
    6484:	0e 94 0e 3d 	call	0x7a1c	; 0x7a1c <__cmpsf2>
    6488:	88 23       	and	r24, r24
    648a:	3c f4       	brge	.+14     	; 0x649a <printFloat+0x42>
    serial_write('-');
    648c:	8d e2       	ldi	r24, 0x2D	; 45
    648e:	0e 94 ef 13 	call	0x27de	; 0x27de <serial_write>
    n = -n;
    6492:	f7 fa       	bst	r15, 7
    6494:	f0 94       	com	r15
    6496:	f7 f8       	bld	r15, 7
    6498:	f0 94       	com	r15
  }

  uint8_t decimals = decimal_places;
    649a:	10 2f       	mov	r17, r16
  while (decimals >= 2) { // Quickly convert values expected to be E0 to E-4.
    649c:	0b c0       	rjmp	.+22     	; 0x64b4 <printFloat+0x5c>
    n *= 100;
    649e:	20 e0       	ldi	r18, 0x00	; 0
    64a0:	30 e0       	ldi	r19, 0x00	; 0
    64a2:	48 ec       	ldi	r20, 0xC8	; 200
    64a4:	52 e4       	ldi	r21, 0x42	; 66
    64a6:	c7 01       	movw	r24, r14
    64a8:	b6 01       	movw	r22, r12
    64aa:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
    64ae:	6b 01       	movw	r12, r22
    64b0:	7c 01       	movw	r14, r24
    decimals -= 2;
    64b2:	12 50       	subi	r17, 0x02	; 2
    serial_write('-');
    n = -n;
  }

  uint8_t decimals = decimal_places;
  while (decimals >= 2) { // Quickly convert values expected to be E0 to E-4.
    64b4:	12 30       	cpi	r17, 0x02	; 2
    64b6:	98 f7       	brcc	.-26     	; 0x649e <printFloat+0x46>
    n *= 100;
    decimals -= 2;
  }
  if (decimals) { n *= 10; }
    64b8:	11 23       	and	r17, r17
    64ba:	51 f0       	breq	.+20     	; 0x64d0 <printFloat+0x78>
    64bc:	20 e0       	ldi	r18, 0x00	; 0
    64be:	30 e0       	ldi	r19, 0x00	; 0
    64c0:	40 e2       	ldi	r20, 0x20	; 32
    64c2:	51 e4       	ldi	r21, 0x41	; 65
    64c4:	c7 01       	movw	r24, r14
    64c6:	b6 01       	movw	r22, r12
    64c8:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
    64cc:	6b 01       	movw	r12, r22
    64ce:	7c 01       	movw	r14, r24
  n += 0.5; // Add rounding factor. Ensures carryover through entire value.
    64d0:	20 e0       	ldi	r18, 0x00	; 0
    64d2:	30 e0       	ldi	r19, 0x00	; 0
    64d4:	40 e0       	ldi	r20, 0x00	; 0
    64d6:	5f e3       	ldi	r21, 0x3F	; 63
    64d8:	c7 01       	movw	r24, r14
    64da:	b6 01       	movw	r22, r12
    64dc:	0e 94 35 3c 	call	0x786a	; 0x786a <__addsf3>

  // Generate digits backwards and store in string.
  unsigned char buf[13];
  uint8_t i = 0;
  uint32_t a = (long)n;
    64e0:	0e 94 7d 3d 	call	0x7afa	; 0x7afa <__fixsfsi>
  if (decimals) { n *= 10; }
  n += 0.5; // Add rounding factor. Ensures carryover through entire value.

  // Generate digits backwards and store in string.
  unsigned char buf[13];
  uint8_t i = 0;
    64e4:	10 e0       	ldi	r17, 0x00	; 0
  uint32_t a = (long)n;
  while(a > 0) {
    64e6:	13 c0       	rjmp	.+38     	; 0x650e <printFloat+0xb6>
    buf[i++] = (a % 10) + '0'; // Get digit
    64e8:	2a e0       	ldi	r18, 0x0A	; 10
    64ea:	30 e0       	ldi	r19, 0x00	; 0
    64ec:	40 e0       	ldi	r20, 0x00	; 0
    64ee:	50 e0       	ldi	r21, 0x00	; 0
    64f0:	0e 94 39 40 	call	0x8072	; 0x8072 <__udivmodsi4>
    64f4:	e1 e0       	ldi	r30, 0x01	; 1
    64f6:	f0 e0       	ldi	r31, 0x00	; 0
    64f8:	ec 0f       	add	r30, r28
    64fa:	fd 1f       	adc	r31, r29
    64fc:	e1 0f       	add	r30, r17
    64fe:	f1 1d       	adc	r31, r1
    6500:	60 5d       	subi	r22, 0xD0	; 208
    6502:	60 83       	st	Z, r22
    a /= 10;
    6504:	62 2f       	mov	r22, r18
    6506:	73 2f       	mov	r23, r19
    6508:	84 2f       	mov	r24, r20
    650a:	95 2f       	mov	r25, r21
  // Generate digits backwards and store in string.
  unsigned char buf[13];
  uint8_t i = 0;
  uint32_t a = (long)n;
  while(a > 0) {
    buf[i++] = (a % 10) + '0'; // Get digit
    650c:	1f 5f       	subi	r17, 0xFF	; 255

  // Generate digits backwards and store in string.
  unsigned char buf[13];
  uint8_t i = 0;
  uint32_t a = (long)n;
  while(a > 0) {
    650e:	61 15       	cp	r22, r1
    6510:	71 05       	cpc	r23, r1
    6512:	81 05       	cpc	r24, r1
    6514:	91 05       	cpc	r25, r1
    6516:	41 f7       	brne	.-48     	; 0x64e8 <printFloat+0x90>
    6518:	09 c0       	rjmp	.+18     	; 0x652c <printFloat+0xd4>
    buf[i++] = (a % 10) + '0'; // Get digit
    a /= 10;
  }
  while (i < decimal_places) {
     buf[i++] = '0'; // Fill in zeros to decimal point for (n < 1)
    651a:	e1 e0       	ldi	r30, 0x01	; 1
    651c:	f0 e0       	ldi	r31, 0x00	; 0
    651e:	ec 0f       	add	r30, r28
    6520:	fd 1f       	adc	r31, r29
    6522:	e1 0f       	add	r30, r17
    6524:	f1 1d       	adc	r31, r1
    6526:	80 e3       	ldi	r24, 0x30	; 48
    6528:	80 83       	st	Z, r24
    652a:	1f 5f       	subi	r17, 0xFF	; 255
  uint32_t a = (long)n;
  while(a > 0) {
    buf[i++] = (a % 10) + '0'; // Get digit
    a /= 10;
  }
  while (i < decimal_places) {
    652c:	10 17       	cp	r17, r16
    652e:	a8 f3       	brcs	.-22     	; 0x651a <printFloat+0xc2>
     buf[i++] = '0'; // Fill in zeros to decimal point for (n < 1)
  }
  if (i == decimal_places) { // Fill in leading zero, if needed.
    6530:	10 13       	cpse	r17, r16
    6532:	1c c0       	rjmp	.+56     	; 0x656c <printFloat+0x114>
    buf[i++] = '0';
    6534:	e1 e0       	ldi	r30, 0x01	; 1
    6536:	f0 e0       	ldi	r31, 0x00	; 0
    6538:	ec 0f       	add	r30, r28
    653a:	fd 1f       	adc	r31, r29
    653c:	e1 0f       	add	r30, r17
    653e:	f1 1d       	adc	r31, r1
    6540:	80 e3       	ldi	r24, 0x30	; 48
    6542:	80 83       	st	Z, r24
    6544:	1f 5f       	subi	r17, 0xFF	; 255
    6546:	12 c0       	rjmp	.+36     	; 0x656c <printFloat+0x114>
  }

  // Print the generated string.
  for (; i > 0; i--) {
    if (i == decimal_places) { serial_write('.'); } // Insert decimal point in right place.
    6548:	10 13       	cpse	r17, r16
    654a:	03 c0       	rjmp	.+6      	; 0x6552 <printFloat+0xfa>
    654c:	8e e2       	ldi	r24, 0x2E	; 46
    654e:	0e 94 ef 13 	call	0x27de	; 0x27de <serial_write>
    serial_write(buf[i-1]);
    6552:	e1 2f       	mov	r30, r17
    6554:	f0 e0       	ldi	r31, 0x00	; 0
    6556:	31 97       	sbiw	r30, 0x01	; 1
    6558:	81 e0       	ldi	r24, 0x01	; 1
    655a:	90 e0       	ldi	r25, 0x00	; 0
    655c:	8c 0f       	add	r24, r28
    655e:	9d 1f       	adc	r25, r29
    6560:	e8 0f       	add	r30, r24
    6562:	f9 1f       	adc	r31, r25
    6564:	80 81       	ld	r24, Z
    6566:	0e 94 ef 13 	call	0x27de	; 0x27de <serial_write>
  if (i == decimal_places) { // Fill in leading zero, if needed.
    buf[i++] = '0';
  }

  // Print the generated string.
  for (; i > 0; i--) {
    656a:	11 50       	subi	r17, 0x01	; 1
    656c:	11 11       	cpse	r17, r1
    656e:	ec cf       	rjmp	.-40     	; 0x6548 <printFloat+0xf0>
    if (i == decimal_places) { serial_write('.'); } // Insert decimal point in right place.
    serial_write(buf[i-1]);
  }
}
    6570:	2d 96       	adiw	r28, 0x0d	; 13
    6572:	0f b6       	in	r0, 0x3f	; 63
    6574:	f8 94       	cli
    6576:	de bf       	out	0x3e, r29	; 62
    6578:	0f be       	out	0x3f, r0	; 63
    657a:	cd bf       	out	0x3d, r28	; 61
    657c:	df 91       	pop	r29
    657e:	cf 91       	pop	r28
    6580:	1f 91       	pop	r17
    6582:	0f 91       	pop	r16
    6584:	ff 90       	pop	r15
    6586:	ef 90       	pop	r14
    6588:	df 90       	pop	r13
    658a:	cf 90       	pop	r12
    658c:	08 95       	ret

0000658e <printFloat_CoordValue>:
// Floating value printing handlers for special variables types used in Grbl and are defined
// in the config.h.
//  - CoordValue: Handles all position or coordinate values in inches or mm reporting.
//  - RateValue: Handles feed rate and current velocity in inches or mm reporting.
void printFloat_CoordValue(float n) {
  if (bit_istrue(settings.flags,BITFLAG_REPORT_INCHES)) {
    658e:	20 91 fe 0e 	lds	r18, 0x0EFE	; 0x800efe <settings+0x45>
    6592:	20 ff       	sbrs	r18, 0
    6594:	09 c0       	rjmp	.+18     	; 0x65a8 <printFloat_CoordValue+0x1a>
    printFloat(n*INCH_PER_MM,N_DECIMAL_COORDVALUE_INCH);
    6596:	2b e8       	ldi	r18, 0x8B	; 139
    6598:	32 e4       	ldi	r19, 0x42	; 66
    659a:	41 e2       	ldi	r20, 0x21	; 33
    659c:	5d e3       	ldi	r21, 0x3D	; 61
    659e:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
    65a2:	44 e0       	ldi	r20, 0x04	; 4
    65a4:	59 cf       	rjmp	.-334    	; 0x6458 <printFloat>
    65a6:	08 95       	ret
  } else {
    printFloat(n,N_DECIMAL_COORDVALUE_MM);
    65a8:	43 e0       	ldi	r20, 0x03	; 3
    65aa:	56 cf       	rjmp	.-340    	; 0x6458 <printFloat>
    65ac:	08 95       	ret

000065ae <printFloat_RateValue>:
  }
}

void printFloat_RateValue(float n) {
  if (bit_istrue(settings.flags,BITFLAG_REPORT_INCHES)) {
    65ae:	20 91 fe 0e 	lds	r18, 0x0EFE	; 0x800efe <settings+0x45>
    65b2:	20 ff       	sbrs	r18, 0
    65b4:	09 c0       	rjmp	.+18     	; 0x65c8 <printFloat_RateValue+0x1a>
    printFloat(n*INCH_PER_MM,N_DECIMAL_RATEVALUE_INCH);
    65b6:	2b e8       	ldi	r18, 0x8B	; 139
    65b8:	32 e4       	ldi	r19, 0x42	; 66
    65ba:	41 e2       	ldi	r20, 0x21	; 33
    65bc:	5d e3       	ldi	r21, 0x3D	; 61
    65be:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <__mulsf3>
    65c2:	41 e0       	ldi	r20, 0x01	; 1
    65c4:	49 cf       	rjmp	.-366    	; 0x6458 <printFloat>
    65c6:	08 95       	ret
  } else {
    printFloat(n,N_DECIMAL_RATEVALUE_MM);
    65c8:	40 e0       	ldi	r20, 0x00	; 0
    65ca:	46 cf       	rjmp	.-372    	; 0x6458 <printFloat>
    65cc:	08 95       	ret

000065ce <probe_configure_invert_mask>:
// Called by probe_init() and the mc_probe() routines. Sets up the probe pin invert mask to
// appropriately set the pin logic according to setting for normal-high/normal-low operation
// and the probing cycle modes for toward-workpiece/away-from-workpiece.
void probe_configure_invert_mask(uint8_t is_probe_away)
{
  probe_invert_mask = 0; // Initialize as zero.
    65ce:	10 92 0e 0f 	sts	0x0F0E, r1	; 0x800f0e <probe_invert_mask>
  if (bit_isfalse(settings.flags,BITFLAG_INVERT_PROBE_PIN)) { probe_invert_mask ^= PROBE_MASK; }
    65d2:	90 91 fe 0e 	lds	r25, 0x0EFE	; 0x800efe <settings+0x45>
    65d6:	99 23       	and	r25, r25
    65d8:	1c f0       	brlt	.+6      	; 0x65e0 <probe_configure_invert_mask+0x12>
    65da:	90 e8       	ldi	r25, 0x80	; 128
    65dc:	90 93 0e 0f 	sts	0x0F0E, r25	; 0x800f0e <probe_invert_mask>
  if (is_probe_away) { probe_invert_mask ^= PROBE_MASK; }
    65e0:	88 23       	and	r24, r24
    65e2:	29 f0       	breq	.+10     	; 0x65ee <probe_configure_invert_mask+0x20>
    65e4:	80 91 0e 0f 	lds	r24, 0x0F0E	; 0x800f0e <probe_invert_mask>
    65e8:	80 58       	subi	r24, 0x80	; 128
    65ea:	80 93 0e 0f 	sts	0x0F0E, r24	; 0x800f0e <probe_invert_mask>
    65ee:	08 95       	ret

000065f0 <probe_init>:


// Probe pin initialization routine.
void probe_init()
{
  PROBE_DDR &= ~(PROBE_MASK); // Configure as input pins
    65f0:	e7 e0       	ldi	r30, 0x07	; 7
    65f2:	f1 e0       	ldi	r31, 0x01	; 1
    65f4:	80 81       	ld	r24, Z
    65f6:	8f 77       	andi	r24, 0x7F	; 127
    65f8:	80 83       	st	Z, r24
  #ifdef DISABLE_PROBE_PIN_PULL_UP
    PROBE_PORT &= ~(PROBE_MASK); // Normal low operation. Requires external pull-down.
  #else
    PROBE_PORT |= PROBE_MASK;    // Enable internal pull-up resistors. Normal high operation.
    65fa:	e8 e0       	ldi	r30, 0x08	; 8
    65fc:	f1 e0       	ldi	r31, 0x01	; 1
    65fe:	80 81       	ld	r24, Z
    6600:	80 68       	ori	r24, 0x80	; 128
    6602:	80 83       	st	Z, r24
  #endif
  probe_configure_invert_mask(false); // Initialize invert mask.
    6604:	80 e0       	ldi	r24, 0x00	; 0
    6606:	e3 cf       	rjmp	.-58     	; 0x65ce <probe_configure_invert_mask>
    6608:	08 95       	ret

0000660a <probe_get_state>:
  if (is_probe_away) { probe_invert_mask ^= PROBE_MASK; }
}


// Returns the probe pin state. Triggered = true. Called by gcode parser and probe state monitor.
uint8_t probe_get_state() { return((PROBE_PIN & PROBE_MASK) ^ probe_invert_mask); }
    660a:	80 91 06 01 	lds	r24, 0x0106	; 0x800106 <__TEXT_REGION_LENGTH__+0x7c0106>
    660e:	80 78       	andi	r24, 0x80	; 128
    6610:	90 91 0e 0f 	lds	r25, 0x0F0E	; 0x800f0e <probe_invert_mask>
    6614:	89 27       	eor	r24, r25
    6616:	08 95       	ret

00006618 <probe_state_monitor>:
// Monitors probe pin state and records the system position when detected. Called by the
// stepper ISR per ISR tick.
// NOTE: This function must be extremely efficient as to not bog down the stepper ISR.
void probe_state_monitor()
{
  if (probe_get_state()) {
    6618:	f8 df       	rcall	.-16     	; 0x660a <probe_get_state>
    661a:	88 23       	and	r24, r24
    661c:	81 f0       	breq	.+32     	; 0x663e <probe_state_monitor+0x26>
    sys_probe_state = PROBE_OFF;
    661e:	10 92 24 0c 	sts	0x0C24, r1	; 0x800c24 <sys_probe_state>
    memcpy(sys_probe_position, sys_position, sizeof(sys_position));
    6622:	8c e0       	ldi	r24, 0x0C	; 12
    6624:	e1 e3       	ldi	r30, 0x31	; 49
    6626:	fc e0       	ldi	r31, 0x0C	; 12
    6628:	a5 e2       	ldi	r26, 0x25	; 37
    662a:	bc e0       	ldi	r27, 0x0C	; 12
    662c:	01 90       	ld	r0, Z+
    662e:	0d 92       	st	X+, r0
    6630:	8a 95       	dec	r24
    6632:	e1 f7       	brne	.-8      	; 0x662c <probe_state_monitor+0x14>
    bit_true(sys_rt_exec_state, EXEC_MOTION_CANCEL);
    6634:	80 91 23 0c 	lds	r24, 0x0C23	; 0x800c23 <sys_rt_exec_state>
    6638:	80 64       	ori	r24, 0x40	; 64
    663a:	80 93 23 0c 	sts	0x0C23, r24	; 0x800c23 <sys_rt_exec_state>
    663e:	08 95       	ret

00006640 <report_util_line_feed>:
// and has been sent into protocol_execute_line() routine to be executed by Grbl.
void report_echo_line_received(char *line)
{
  printPgmString(PSTR("[echo: ")); printString(line);
  report_util_feedback_line_feed();
}
    6640:	81 e0       	ldi	r24, 0x01	; 1
    6642:	95 e0       	ldi	r25, 0x05	; 5
    6644:	5c ce       	rjmp	.-840    	; 0x62fe <printPgmString>
    6646:	08 95       	ret

00006648 <report_util_feedback_line_feed>:
    6648:	8d e5       	ldi	r24, 0x5D	; 93
    664a:	0e 94 ef 13 	call	0x27de	; 0x27de <serial_write>
    664e:	f8 cf       	rjmp	.-16     	; 0x6640 <report_util_line_feed>
    6650:	08 95       	ret

00006652 <report_util_gcode_modes_G>:
    6652:	85 ec       	ldi	r24, 0xC5	; 197
    6654:	93 e0       	ldi	r25, 0x03	; 3
    6656:	53 ce       	rjmp	.-858    	; 0x62fe <printPgmString>
    6658:	08 95       	ret

0000665a <report_util_gcode_modes_M>:
    665a:	82 ec       	ldi	r24, 0xC2	; 194
    665c:	93 e0       	ldi	r25, 0x03	; 3
    665e:	4f ce       	rjmp	.-866    	; 0x62fe <printPgmString>
    6660:	08 95       	ret

00006662 <report_util_axis_values>:
    6662:	0f 93       	push	r16
    6664:	1f 93       	push	r17
    6666:	cf 93       	push	r28
    6668:	8c 01       	movw	r16, r24
    666a:	c0 e0       	ldi	r28, 0x00	; 0
    666c:	13 c0       	rjmp	.+38     	; 0x6694 <report_util_axis_values+0x32>
    666e:	ec 2f       	mov	r30, r28
    6670:	f0 e0       	ldi	r31, 0x00	; 0
    6672:	ee 0f       	add	r30, r30
    6674:	ff 1f       	adc	r31, r31
    6676:	ee 0f       	add	r30, r30
    6678:	ff 1f       	adc	r31, r31
    667a:	e0 0f       	add	r30, r16
    667c:	f1 1f       	adc	r31, r17
    667e:	60 81       	ld	r22, Z
    6680:	71 81       	ldd	r23, Z+1	; 0x01
    6682:	82 81       	ldd	r24, Z+2	; 0x02
    6684:	93 81       	ldd	r25, Z+3	; 0x03
    6686:	83 df       	rcall	.-250    	; 0x658e <printFloat_CoordValue>
    6688:	c2 30       	cpi	r28, 0x02	; 2
    668a:	18 f4       	brcc	.+6      	; 0x6692 <report_util_axis_values+0x30>
    668c:	8c e2       	ldi	r24, 0x2C	; 44
    668e:	0e 94 ef 13 	call	0x27de	; 0x27de <serial_write>
    6692:	cf 5f       	subi	r28, 0xFF	; 255
    6694:	c3 30       	cpi	r28, 0x03	; 3
    6696:	58 f3       	brcs	.-42     	; 0x666e <report_util_axis_values+0xc>
    6698:	cf 91       	pop	r28
    669a:	1f 91       	pop	r17
    669c:	0f 91       	pop	r16
    669e:	08 95       	ret

000066a0 <report_util_setting_prefix>:
    66a0:	cf 93       	push	r28
    66a2:	c8 2f       	mov	r28, r24
    66a4:	84 e2       	ldi	r24, 0x24	; 36
    66a6:	0e 94 ef 13 	call	0x27de	; 0x27de <serial_write>
    66aa:	8c 2f       	mov	r24, r28
    66ac:	37 de       	rcall	.-914    	; 0x631c <print_uint8_base10>
    66ae:	8d e3       	ldi	r24, 0x3D	; 61
    66b0:	0e 94 ef 13 	call	0x27de	; 0x27de <serial_write>
    66b4:	cf 91       	pop	r28
    66b6:	08 95       	ret

000066b8 <report_util_uint8_setting>:
    66b8:	cf 93       	push	r28
    66ba:	c6 2f       	mov	r28, r22
    66bc:	f1 df       	rcall	.-30     	; 0x66a0 <report_util_setting_prefix>
    66be:	8c 2f       	mov	r24, r28
    66c0:	2d de       	rcall	.-934    	; 0x631c <print_uint8_base10>
    66c2:	be df       	rcall	.-132    	; 0x6640 <report_util_line_feed>
    66c4:	cf 91       	pop	r28
    66c6:	08 95       	ret

000066c8 <report_util_float_setting>:
    66c8:	cf 92       	push	r12
    66ca:	df 92       	push	r13
    66cc:	ef 92       	push	r14
    66ce:	ff 92       	push	r15
    66d0:	cf 93       	push	r28
    66d2:	6a 01       	movw	r12, r20
    66d4:	7b 01       	movw	r14, r22
    66d6:	c2 2f       	mov	r28, r18
    66d8:	e3 df       	rcall	.-58     	; 0x66a0 <report_util_setting_prefix>
    66da:	4c 2f       	mov	r20, r28
    66dc:	c7 01       	movw	r24, r14
    66de:	b6 01       	movw	r22, r12
    66e0:	bb de       	rcall	.-650    	; 0x6458 <printFloat>
    66e2:	ae df       	rcall	.-164    	; 0x6640 <report_util_line_feed>
    66e4:	cf 91       	pop	r28
    66e6:	ff 90       	pop	r15
    66e8:	ef 90       	pop	r14
    66ea:	df 90       	pop	r13
    66ec:	cf 90       	pop	r12
    66ee:	08 95       	ret

000066f0 <report_status_message>:
    66f0:	cf 93       	push	r28
    66f2:	c8 2f       	mov	r28, r24
    66f4:	81 11       	cpse	r24, r1
    66f6:	04 c0       	rjmp	.+8      	; 0x6700 <report_status_message+0x10>
    66f8:	8b e0       	ldi	r24, 0x0B	; 11
    66fa:	95 e0       	ldi	r25, 0x05	; 5
    66fc:	00 de       	rcall	.-1024   	; 0x62fe <printPgmString>
    66fe:	06 c0       	rjmp	.+12     	; 0x670c <report_status_message+0x1c>
    6700:	84 e0       	ldi	r24, 0x04	; 4
    6702:	95 e0       	ldi	r25, 0x05	; 5
    6704:	fc dd       	rcall	.-1032   	; 0x62fe <printPgmString>
    6706:	8c 2f       	mov	r24, r28
    6708:	09 de       	rcall	.-1006   	; 0x631c <print_uint8_base10>
    670a:	9a df       	rcall	.-204    	; 0x6640 <report_util_line_feed>
    670c:	cf 91       	pop	r28
    670e:	08 95       	ret

00006710 <report_alarm_message>:
    6710:	cf 93       	push	r28
    6712:	c8 2f       	mov	r28, r24
    6714:	8a ef       	ldi	r24, 0xFA	; 250
    6716:	94 e0       	ldi	r25, 0x04	; 4
    6718:	f2 dd       	rcall	.-1052   	; 0x62fe <printPgmString>
    671a:	8c 2f       	mov	r24, r28
    671c:	ff dd       	rcall	.-1026   	; 0x631c <print_uint8_base10>
    671e:	90 df       	rcall	.-224    	; 0x6640 <report_util_line_feed>
    6720:	84 ef       	ldi	r24, 0xF4	; 244
    6722:	91 e0       	ldi	r25, 0x01	; 1
    6724:	01 da       	rcall	.-3070   	; 0x5b28 <delay_ms>
    6726:	cf 91       	pop	r28
    6728:	08 95       	ret

0000672a <report_feedback_message>:
    672a:	cf 93       	push	r28
    672c:	c8 2f       	mov	r28, r24
    672e:	84 ef       	ldi	r24, 0xF4	; 244
    6730:	94 e0       	ldi	r25, 0x04	; 4
    6732:	e5 dd       	rcall	.-1078   	; 0x62fe <printPgmString>
    6734:	8c 2f       	mov	r24, r28
    6736:	90 e0       	ldi	r25, 0x00	; 0
    6738:	fc 01       	movw	r30, r24
    673a:	31 97       	sbiw	r30, 0x01	; 1
    673c:	eb 30       	cpi	r30, 0x0B	; 11
    673e:	f1 05       	cpc	r31, r1
    6740:	88 f5       	brcc	.+98     	; 0x67a4 <report_feedback_message+0x7a>
    6742:	88 27       	eor	r24, r24
    6744:	ec 5b       	subi	r30, 0xBC	; 188
    6746:	fe 4f       	sbci	r31, 0xFE	; 254
    6748:	8f 4f       	sbci	r24, 0xFF	; 255
    674a:	0c 94 5b 40 	jmp	0x80b6	; 0x80b6 <__tablejump2__>
    674e:	82 ee       	ldi	r24, 0xE2	; 226
    6750:	94 e0       	ldi	r25, 0x04	; 4
    6752:	d5 dd       	rcall	.-1110   	; 0x62fe <printPgmString>
    6754:	27 c0       	rjmp	.+78     	; 0x67a4 <report_feedback_message+0x7a>
    6756:	8e ec       	ldi	r24, 0xCE	; 206
    6758:	94 e0       	ldi	r25, 0x04	; 4
    675a:	d1 dd       	rcall	.-1118   	; 0x62fe <printPgmString>
    675c:	23 c0       	rjmp	.+70     	; 0x67a4 <report_feedback_message+0x7a>
    675e:	8c eb       	ldi	r24, 0xBC	; 188
    6760:	94 e0       	ldi	r25, 0x04	; 4
    6762:	cd dd       	rcall	.-1126   	; 0x62fe <printPgmString>
    6764:	1f c0       	rjmp	.+62     	; 0x67a4 <report_feedback_message+0x7a>
    6766:	84 eb       	ldi	r24, 0xB4	; 180
    6768:	94 e0       	ldi	r25, 0x04	; 4
    676a:	c9 dd       	rcall	.-1134   	; 0x62fe <printPgmString>
    676c:	1b c0       	rjmp	.+54     	; 0x67a4 <report_feedback_message+0x7a>
    676e:	8b ea       	ldi	r24, 0xAB	; 171
    6770:	94 e0       	ldi	r25, 0x04	; 4
    6772:	c5 dd       	rcall	.-1142   	; 0x62fe <printPgmString>
    6774:	17 c0       	rjmp	.+46     	; 0x67a4 <report_feedback_message+0x7a>
    6776:	80 ea       	ldi	r24, 0xA0	; 160
    6778:	94 e0       	ldi	r25, 0x04	; 4
    677a:	c1 dd       	rcall	.-1150   	; 0x62fe <printPgmString>
    677c:	13 c0       	rjmp	.+38     	; 0x67a4 <report_feedback_message+0x7a>
    677e:	83 e9       	ldi	r24, 0x93	; 147
    6780:	94 e0       	ldi	r25, 0x04	; 4
    6782:	bd dd       	rcall	.-1158   	; 0x62fe <printPgmString>
    6784:	0f c0       	rjmp	.+30     	; 0x67a4 <report_feedback_message+0x7a>
    6786:	8b e8       	ldi	r24, 0x8B	; 139
    6788:	94 e0       	ldi	r25, 0x04	; 4
    678a:	b9 dd       	rcall	.-1166   	; 0x62fe <printPgmString>
    678c:	0b c0       	rjmp	.+22     	; 0x67a4 <report_feedback_message+0x7a>
    678e:	88 e7       	ldi	r24, 0x78	; 120
    6790:	94 e0       	ldi	r25, 0x04	; 4
    6792:	b5 dd       	rcall	.-1174   	; 0x62fe <printPgmString>
    6794:	07 c0       	rjmp	.+14     	; 0x67a4 <report_feedback_message+0x7a>
    6796:	86 e6       	ldi	r24, 0x66	; 102
    6798:	94 e0       	ldi	r25, 0x04	; 4
    679a:	b1 dd       	rcall	.-1182   	; 0x62fe <printPgmString>
    679c:	03 c0       	rjmp	.+6      	; 0x67a4 <report_feedback_message+0x7a>
    679e:	8d e5       	ldi	r24, 0x5D	; 93
    67a0:	94 e0       	ldi	r25, 0x04	; 4
    67a2:	ad dd       	rcall	.-1190   	; 0x62fe <printPgmString>
    67a4:	51 df       	rcall	.-350    	; 0x6648 <report_util_feedback_line_feed>
    67a6:	cf 91       	pop	r28
    67a8:	08 95       	ret

000067aa <report_init_message>:
    67aa:	80 e4       	ldi	r24, 0x40	; 64
    67ac:	94 e0       	ldi	r25, 0x04	; 4
    67ae:	a7 cd       	rjmp	.-1202   	; 0x62fe <printPgmString>
    67b0:	08 95       	ret

000067b2 <report_grbl_help>:
    67b2:	86 ef       	ldi	r24, 0xF6	; 246
    67b4:	93 e0       	ldi	r25, 0x03	; 3
    67b6:	a3 cd       	rjmp	.-1210   	; 0x62fe <printPgmString>
    67b8:	08 95       	ret

000067ba <report_grbl_settings>:
    67ba:	0f 93       	push	r16
    67bc:	1f 93       	push	r17
    67be:	cf 93       	push	r28
    67c0:	df 93       	push	r29
    67c2:	09 eb       	ldi	r16, 0xB9	; 185
    67c4:	1e e0       	ldi	r17, 0x0E	; 14
    67c6:	f8 01       	movw	r30, r16
    67c8:	60 a9       	ldd	r22, Z+48	; 0x30
    67ca:	70 e0       	ldi	r23, 0x00	; 0
    67cc:	80 e0       	ldi	r24, 0x00	; 0
    67ce:	74 df       	rcall	.-280    	; 0x66b8 <report_util_uint8_setting>
    67d0:	f8 01       	movw	r30, r16
    67d2:	63 a9       	ldd	r22, Z+51	; 0x33
    67d4:	70 e0       	ldi	r23, 0x00	; 0
    67d6:	81 e0       	ldi	r24, 0x01	; 1
    67d8:	6f df       	rcall	.-290    	; 0x66b8 <report_util_uint8_setting>
    67da:	f8 01       	movw	r30, r16
    67dc:	61 a9       	ldd	r22, Z+49	; 0x31
    67de:	70 e0       	ldi	r23, 0x00	; 0
    67e0:	82 e0       	ldi	r24, 0x02	; 2
    67e2:	6a df       	rcall	.-300    	; 0x66b8 <report_util_uint8_setting>
    67e4:	f8 01       	movw	r30, r16
    67e6:	62 a9       	ldd	r22, Z+50	; 0x32
    67e8:	70 e0       	ldi	r23, 0x00	; 0
    67ea:	83 e0       	ldi	r24, 0x03	; 3
    67ec:	65 df       	rcall	.-310    	; 0x66b8 <report_util_uint8_setting>
    67ee:	ce ef       	ldi	r28, 0xFE	; 254
    67f0:	de e0       	ldi	r29, 0x0E	; 14
    67f2:	68 81       	ld	r22, Y
    67f4:	62 fb       	bst	r22, 2
    67f6:	66 27       	eor	r22, r22
    67f8:	60 f9       	bld	r22, 0
    67fa:	70 e0       	ldi	r23, 0x00	; 0
    67fc:	84 e0       	ldi	r24, 0x04	; 4
    67fe:	5c df       	rcall	.-328    	; 0x66b8 <report_util_uint8_setting>
    6800:	68 81       	ld	r22, Y
    6802:	66 fb       	bst	r22, 6
    6804:	66 27       	eor	r22, r22
    6806:	60 f9       	bld	r22, 0
    6808:	70 e0       	ldi	r23, 0x00	; 0
    680a:	85 e0       	ldi	r24, 0x05	; 5
    680c:	55 df       	rcall	.-342    	; 0x66b8 <report_util_uint8_setting>
    680e:	88 81       	ld	r24, Y
    6810:	08 2e       	mov	r0, r24
    6812:	00 0c       	add	r0, r0
    6814:	99 0b       	sbc	r25, r25
    6816:	69 2f       	mov	r22, r25
    6818:	66 1f       	adc	r22, r22
    681a:	66 27       	eor	r22, r22
    681c:	66 1f       	adc	r22, r22
    681e:	70 e0       	ldi	r23, 0x00	; 0
    6820:	86 e0       	ldi	r24, 0x06	; 6
    6822:	4a df       	rcall	.-364    	; 0x66b8 <report_util_uint8_setting>
    6824:	f8 01       	movw	r30, r16
    6826:	64 a9       	ldd	r22, Z+52	; 0x34
    6828:	70 e0       	ldi	r23, 0x00	; 0
    682a:	8a e0       	ldi	r24, 0x0A	; 10
    682c:	45 df       	rcall	.-374    	; 0x66b8 <report_util_uint8_setting>
    682e:	f8 01       	movw	r30, r16
    6830:	45 a9       	ldd	r20, Z+53	; 0x35
    6832:	56 a9       	ldd	r21, Z+54	; 0x36
    6834:	67 a9       	ldd	r22, Z+55	; 0x37
    6836:	70 ad       	ldd	r23, Z+56	; 0x38
    6838:	23 e0       	ldi	r18, 0x03	; 3
    683a:	8b e0       	ldi	r24, 0x0B	; 11
    683c:	45 df       	rcall	.-374    	; 0x66c8 <report_util_float_setting>
    683e:	f8 01       	movw	r30, r16
    6840:	41 ad       	ldd	r20, Z+57	; 0x39
    6842:	52 ad       	ldd	r21, Z+58	; 0x3a
    6844:	63 ad       	ldd	r22, Z+59	; 0x3b
    6846:	74 ad       	ldd	r23, Z+60	; 0x3c
    6848:	23 e0       	ldi	r18, 0x03	; 3
    684a:	8c e0       	ldi	r24, 0x0C	; 12
    684c:	3d df       	rcall	.-390    	; 0x66c8 <report_util_float_setting>
    684e:	68 81       	ld	r22, Y
    6850:	61 70       	andi	r22, 0x01	; 1
    6852:	70 e0       	ldi	r23, 0x00	; 0
    6854:	8d e0       	ldi	r24, 0x0D	; 13
    6856:	30 df       	rcall	.-416    	; 0x66b8 <report_util_uint8_setting>
    6858:	68 81       	ld	r22, Y
    685a:	65 fb       	bst	r22, 5
    685c:	66 27       	eor	r22, r22
    685e:	60 f9       	bld	r22, 0
    6860:	70 e0       	ldi	r23, 0x00	; 0
    6862:	84 e1       	ldi	r24, 0x14	; 20
    6864:	29 df       	rcall	.-430    	; 0x66b8 <report_util_uint8_setting>
    6866:	68 81       	ld	r22, Y
    6868:	63 fb       	bst	r22, 3
    686a:	66 27       	eor	r22, r22
    686c:	60 f9       	bld	r22, 0
    686e:	70 e0       	ldi	r23, 0x00	; 0
    6870:	85 e1       	ldi	r24, 0x15	; 21
    6872:	22 df       	rcall	.-444    	; 0x66b8 <report_util_uint8_setting>
    6874:	68 81       	ld	r22, Y
    6876:	62 95       	swap	r22
    6878:	61 70       	andi	r22, 0x01	; 1
    687a:	70 e0       	ldi	r23, 0x00	; 0
    687c:	86 e1       	ldi	r24, 0x16	; 22
    687e:	1c df       	rcall	.-456    	; 0x66b8 <report_util_uint8_setting>
    6880:	60 91 ff 0e 	lds	r22, 0x0EFF	; 0x800eff <settings+0x46>
    6884:	70 e0       	ldi	r23, 0x00	; 0
    6886:	87 e1       	ldi	r24, 0x17	; 23
    6888:	17 df       	rcall	.-466    	; 0x66b8 <report_util_uint8_setting>
    688a:	40 91 00 0f 	lds	r20, 0x0F00	; 0x800f00 <settings+0x47>
    688e:	50 91 01 0f 	lds	r21, 0x0F01	; 0x800f01 <settings+0x48>
    6892:	60 91 02 0f 	lds	r22, 0x0F02	; 0x800f02 <settings+0x49>
    6896:	70 91 03 0f 	lds	r23, 0x0F03	; 0x800f03 <settings+0x4a>
    689a:	23 e0       	ldi	r18, 0x03	; 3
    689c:	88 e1       	ldi	r24, 0x18	; 24
    689e:	14 df       	rcall	.-472    	; 0x66c8 <report_util_float_setting>
    68a0:	40 91 04 0f 	lds	r20, 0x0F04	; 0x800f04 <settings+0x4b>
    68a4:	50 91 05 0f 	lds	r21, 0x0F05	; 0x800f05 <settings+0x4c>
    68a8:	60 91 06 0f 	lds	r22, 0x0F06	; 0x800f06 <settings+0x4d>
    68ac:	70 91 07 0f 	lds	r23, 0x0F07	; 0x800f07 <settings+0x4e>
    68b0:	23 e0       	ldi	r18, 0x03	; 3
    68b2:	89 e1       	ldi	r24, 0x19	; 25
    68b4:	09 df       	rcall	.-494    	; 0x66c8 <report_util_float_setting>
    68b6:	60 91 08 0f 	lds	r22, 0x0F08	; 0x800f08 <settings+0x4f>
    68ba:	70 91 09 0f 	lds	r23, 0x0F09	; 0x800f09 <settings+0x50>
    68be:	8a e1       	ldi	r24, 0x1A	; 26
    68c0:	fb de       	rcall	.-522    	; 0x66b8 <report_util_uint8_setting>
    68c2:	40 91 0a 0f 	lds	r20, 0x0F0A	; 0x800f0a <settings+0x51>
    68c6:	50 91 0b 0f 	lds	r21, 0x0F0B	; 0x800f0b <settings+0x52>
    68ca:	60 91 0c 0f 	lds	r22, 0x0F0C	; 0x800f0c <settings+0x53>
    68ce:	70 91 0d 0f 	lds	r23, 0x0F0D	; 0x800f0d <settings+0x54>
    68d2:	23 e0       	ldi	r18, 0x03	; 3
    68d4:	8b e1       	ldi	r24, 0x1B	; 27
    68d6:	f8 de       	rcall	.-528    	; 0x66c8 <report_util_float_setting>
    68d8:	40 91 f6 0e 	lds	r20, 0x0EF6	; 0x800ef6 <settings+0x3d>
    68dc:	50 91 f7 0e 	lds	r21, 0x0EF7	; 0x800ef7 <settings+0x3e>
    68e0:	60 91 f8 0e 	lds	r22, 0x0EF8	; 0x800ef8 <settings+0x3f>
    68e4:	70 91 f9 0e 	lds	r23, 0x0EF9	; 0x800ef9 <settings+0x40>
    68e8:	20 e0       	ldi	r18, 0x00	; 0
    68ea:	8e e1       	ldi	r24, 0x1E	; 30
    68ec:	ed de       	rcall	.-550    	; 0x66c8 <report_util_float_setting>
    68ee:	40 91 fa 0e 	lds	r20, 0x0EFA	; 0x800efa <settings+0x41>
    68f2:	50 91 fb 0e 	lds	r21, 0x0EFB	; 0x800efb <settings+0x42>
    68f6:	60 91 fc 0e 	lds	r22, 0x0EFC	; 0x800efc <settings+0x43>
    68fa:	70 91 fd 0e 	lds	r23, 0x0EFD	; 0x800efd <settings+0x44>
    68fe:	20 e0       	ldi	r18, 0x00	; 0
    6900:	8f e1       	ldi	r24, 0x1F	; 31
    6902:	e2 de       	rcall	.-572    	; 0x66c8 <report_util_float_setting>
    6904:	68 81       	ld	r22, Y
    6906:	66 95       	lsr	r22
    6908:	61 70       	andi	r22, 0x01	; 1
    690a:	70 e0       	ldi	r23, 0x00	; 0
    690c:	80 e2       	ldi	r24, 0x20	; 32
    690e:	d4 de       	rcall	.-600    	; 0x66b8 <report_util_uint8_setting>
    6910:	14 e6       	ldi	r17, 0x64	; 100
    6912:	d0 e0       	ldi	r29, 0x00	; 0
    6914:	60 c0       	rjmp	.+192    	; 0x69d6 <report_grbl_settings+0x21c>
    6916:	d1 30       	cpi	r29, 0x01	; 1
    6918:	c1 f0       	breq	.+48     	; 0x694a <report_grbl_settings+0x190>
    691a:	30 f0       	brcs	.+12     	; 0x6928 <report_grbl_settings+0x16e>
    691c:	d2 30       	cpi	r29, 0x02	; 2
    691e:	39 f1       	breq	.+78     	; 0x696e <report_grbl_settings+0x1b4>
    6920:	d3 30       	cpi	r29, 0x03	; 3
    6922:	09 f4       	brne	.+2      	; 0x6926 <report_grbl_settings+0x16c>
    6924:	3e c0       	rjmp	.+124    	; 0x69a2 <report_grbl_settings+0x1e8>
    6926:	4f c0       	rjmp	.+158    	; 0x69c6 <report_grbl_settings+0x20c>
    6928:	ec 2f       	mov	r30, r28
    692a:	f0 e0       	ldi	r31, 0x00	; 0
    692c:	ee 0f       	add	r30, r30
    692e:	ff 1f       	adc	r31, r31
    6930:	ee 0f       	add	r30, r30
    6932:	ff 1f       	adc	r31, r31
    6934:	e7 54       	subi	r30, 0x47	; 71
    6936:	f1 4f       	sbci	r31, 0xF1	; 241
    6938:	40 81       	ld	r20, Z
    693a:	51 81       	ldd	r21, Z+1	; 0x01
    693c:	62 81       	ldd	r22, Z+2	; 0x02
    693e:	73 81       	ldd	r23, Z+3	; 0x03
    6940:	23 e0       	ldi	r18, 0x03	; 3
    6942:	8c 2f       	mov	r24, r28
    6944:	81 0f       	add	r24, r17
    6946:	c0 de       	rcall	.-640    	; 0x66c8 <report_util_float_setting>
    6948:	3e c0       	rjmp	.+124    	; 0x69c6 <report_grbl_settings+0x20c>
    694a:	ec 2f       	mov	r30, r28
    694c:	f0 e0       	ldi	r31, 0x00	; 0
    694e:	33 96       	adiw	r30, 0x03	; 3
    6950:	ee 0f       	add	r30, r30
    6952:	ff 1f       	adc	r31, r31
    6954:	ee 0f       	add	r30, r30
    6956:	ff 1f       	adc	r31, r31
    6958:	e7 54       	subi	r30, 0x47	; 71
    695a:	f1 4f       	sbci	r31, 0xF1	; 241
    695c:	40 81       	ld	r20, Z
    695e:	51 81       	ldd	r21, Z+1	; 0x01
    6960:	62 81       	ldd	r22, Z+2	; 0x02
    6962:	73 81       	ldd	r23, Z+3	; 0x03
    6964:	23 e0       	ldi	r18, 0x03	; 3
    6966:	8c 2f       	mov	r24, r28
    6968:	81 0f       	add	r24, r17
    696a:	ae de       	rcall	.-676    	; 0x66c8 <report_util_float_setting>
    696c:	2c c0       	rjmp	.+88     	; 0x69c6 <report_grbl_settings+0x20c>
    696e:	ec 2f       	mov	r30, r28
    6970:	f0 e0       	ldi	r31, 0x00	; 0
    6972:	36 96       	adiw	r30, 0x06	; 6
    6974:	ee 0f       	add	r30, r30
    6976:	ff 1f       	adc	r31, r31
    6978:	ee 0f       	add	r30, r30
    697a:	ff 1f       	adc	r31, r31
    697c:	e7 54       	subi	r30, 0x47	; 71
    697e:	f1 4f       	sbci	r31, 0xF1	; 241
    6980:	60 81       	ld	r22, Z
    6982:	71 81       	ldd	r23, Z+1	; 0x01
    6984:	82 81       	ldd	r24, Z+2	; 0x02
    6986:	93 81       	ldd	r25, Z+3	; 0x03
    6988:	20 e0       	ldi	r18, 0x00	; 0
    698a:	30 e0       	ldi	r19, 0x00	; 0
    698c:	41 e6       	ldi	r20, 0x61	; 97
    698e:	55 e4       	ldi	r21, 0x45	; 69
    6990:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <__divsf3>
    6994:	ab 01       	movw	r20, r22
    6996:	bc 01       	movw	r22, r24
    6998:	23 e0       	ldi	r18, 0x03	; 3
    699a:	8c 2f       	mov	r24, r28
    699c:	81 0f       	add	r24, r17
    699e:	94 de       	rcall	.-728    	; 0x66c8 <report_util_float_setting>
    69a0:	12 c0       	rjmp	.+36     	; 0x69c6 <report_grbl_settings+0x20c>
    69a2:	ec 2f       	mov	r30, r28
    69a4:	f0 e0       	ldi	r31, 0x00	; 0
    69a6:	39 96       	adiw	r30, 0x09	; 9
    69a8:	ee 0f       	add	r30, r30
    69aa:	ff 1f       	adc	r31, r31
    69ac:	ee 0f       	add	r30, r30
    69ae:	ff 1f       	adc	r31, r31
    69b0:	e7 54       	subi	r30, 0x47	; 71
    69b2:	f1 4f       	sbci	r31, 0xF1	; 241
    69b4:	40 81       	ld	r20, Z
    69b6:	51 81       	ldd	r21, Z+1	; 0x01
    69b8:	62 81       	ldd	r22, Z+2	; 0x02
    69ba:	73 81       	ldd	r23, Z+3	; 0x03
    69bc:	70 58       	subi	r23, 0x80	; 128
    69be:	23 e0       	ldi	r18, 0x03	; 3
    69c0:	8c 2f       	mov	r24, r28
    69c2:	81 0f       	add	r24, r17
    69c4:	81 de       	rcall	.-766    	; 0x66c8 <report_util_float_setting>
    69c6:	cf 5f       	subi	r28, 0xFF	; 255
    69c8:	01 c0       	rjmp	.+2      	; 0x69cc <report_grbl_settings+0x212>
    69ca:	c0 e0       	ldi	r28, 0x00	; 0
    69cc:	c3 30       	cpi	r28, 0x03	; 3
    69ce:	08 f4       	brcc	.+2      	; 0x69d2 <report_grbl_settings+0x218>
    69d0:	a2 cf       	rjmp	.-188    	; 0x6916 <report_grbl_settings+0x15c>
    69d2:	16 5f       	subi	r17, 0xF6	; 246
    69d4:	df 5f       	subi	r29, 0xFF	; 255
    69d6:	d4 30       	cpi	r29, 0x04	; 4
    69d8:	c0 f3       	brcs	.-16     	; 0x69ca <report_grbl_settings+0x210>
    69da:	df 91       	pop	r29
    69dc:	cf 91       	pop	r28
    69de:	1f 91       	pop	r17
    69e0:	0f 91       	pop	r16
    69e2:	08 95       	ret

000069e4 <report_probe_parameters>:
    69e4:	cf 93       	push	r28
    69e6:	df 93       	push	r29
    69e8:	cd b7       	in	r28, 0x3d	; 61
    69ea:	de b7       	in	r29, 0x3e	; 62
    69ec:	2c 97       	sbiw	r28, 0x0c	; 12
    69ee:	0f b6       	in	r0, 0x3f	; 63
    69f0:	f8 94       	cli
    69f2:	de bf       	out	0x3e, r29	; 62
    69f4:	0f be       	out	0x3f, r0	; 63
    69f6:	cd bf       	out	0x3d, r28	; 61
    69f8:	80 ef       	ldi	r24, 0xF0	; 240
    69fa:	93 e0       	ldi	r25, 0x03	; 3
    69fc:	80 dc       	rcall	.-1792   	; 0x62fe <printPgmString>
    69fe:	65 e2       	ldi	r22, 0x25	; 37
    6a00:	7c e0       	ldi	r23, 0x0C	; 12
    6a02:	ce 01       	movw	r24, r28
    6a04:	01 96       	adiw	r24, 0x01	; 1
    6a06:	e2 d3       	rcall	.+1988   	; 0x71cc <system_convert_array_steps_to_mpos>
    6a08:	ce 01       	movw	r24, r28
    6a0a:	01 96       	adiw	r24, 0x01	; 1
    6a0c:	2a de       	rcall	.-940    	; 0x6662 <report_util_axis_values>
    6a0e:	8a e3       	ldi	r24, 0x3A	; 58
    6a10:	0e 94 ef 13 	call	0x27de	; 0x27de <serial_write>
    6a14:	80 91 16 0c 	lds	r24, 0x0C16	; 0x800c16 <sys+0x5>
    6a18:	81 dc       	rcall	.-1790   	; 0x631c <print_uint8_base10>
    6a1a:	16 de       	rcall	.-980    	; 0x6648 <report_util_feedback_line_feed>
    6a1c:	2c 96       	adiw	r28, 0x0c	; 12
    6a1e:	0f b6       	in	r0, 0x3f	; 63
    6a20:	f8 94       	cli
    6a22:	de bf       	out	0x3e, r29	; 62
    6a24:	0f be       	out	0x3f, r0	; 63
    6a26:	cd bf       	out	0x3d, r28	; 61
    6a28:	df 91       	pop	r29
    6a2a:	cf 91       	pop	r28
    6a2c:	08 95       	ret

00006a2e <report_ngc_parameters>:
    6a2e:	1f 93       	push	r17
    6a30:	cf 93       	push	r28
    6a32:	df 93       	push	r29
    6a34:	cd b7       	in	r28, 0x3d	; 61
    6a36:	de b7       	in	r29, 0x3e	; 62
    6a38:	2c 97       	sbiw	r28, 0x0c	; 12
    6a3a:	0f b6       	in	r0, 0x3f	; 63
    6a3c:	f8 94       	cli
    6a3e:	de bf       	out	0x3e, r29	; 62
    6a40:	0f be       	out	0x3f, r0	; 63
    6a42:	cd bf       	out	0x3d, r28	; 61
    6a44:	10 e0       	ldi	r17, 0x00	; 0
    6a46:	26 c0       	rjmp	.+76     	; 0x6a94 <report_ngc_parameters+0x66>
    6a48:	be 01       	movw	r22, r28
    6a4a:	6f 5f       	subi	r22, 0xFF	; 255
    6a4c:	7f 4f       	sbci	r23, 0xFF	; 255
    6a4e:	81 2f       	mov	r24, r17
    6a50:	0e 94 18 25 	call	0x4a30	; 0x4a30 <settings_read_coord_data>
    6a54:	81 11       	cpse	r24, r1
    6a56:	03 c0       	rjmp	.+6      	; 0x6a5e <report_ngc_parameters+0x30>
    6a58:	87 e0       	ldi	r24, 0x07	; 7
    6a5a:	4a de       	rcall	.-876    	; 0x66f0 <report_status_message>
    6a5c:	32 c0       	rjmp	.+100    	; 0x6ac2 <report_ngc_parameters+0x94>
    6a5e:	8d ee       	ldi	r24, 0xED	; 237
    6a60:	93 e0       	ldi	r25, 0x03	; 3
    6a62:	4d dc       	rcall	.-1894   	; 0x62fe <printPgmString>
    6a64:	16 30       	cpi	r17, 0x06	; 6
    6a66:	19 f0       	breq	.+6      	; 0x6a6e <report_ngc_parameters+0x40>
    6a68:	17 30       	cpi	r17, 0x07	; 7
    6a6a:	29 f0       	breq	.+10     	; 0x6a76 <report_ngc_parameters+0x48>
    6a6c:	08 c0       	rjmp	.+16     	; 0x6a7e <report_ngc_parameters+0x50>
    6a6e:	8a ee       	ldi	r24, 0xEA	; 234
    6a70:	93 e0       	ldi	r25, 0x03	; 3
    6a72:	45 dc       	rcall	.-1910   	; 0x62fe <printPgmString>
    6a74:	07 c0       	rjmp	.+14     	; 0x6a84 <report_ngc_parameters+0x56>
    6a76:	87 ee       	ldi	r24, 0xE7	; 231
    6a78:	93 e0       	ldi	r25, 0x03	; 3
    6a7a:	41 dc       	rcall	.-1918   	; 0x62fe <printPgmString>
    6a7c:	03 c0       	rjmp	.+6      	; 0x6a84 <report_ngc_parameters+0x56>
    6a7e:	86 e3       	ldi	r24, 0x36	; 54
    6a80:	81 0f       	add	r24, r17
    6a82:	4c dc       	rcall	.-1896   	; 0x631c <print_uint8_base10>
    6a84:	8a e3       	ldi	r24, 0x3A	; 58
    6a86:	0e 94 ef 13 	call	0x27de	; 0x27de <serial_write>
    6a8a:	ce 01       	movw	r24, r28
    6a8c:	01 96       	adiw	r24, 0x01	; 1
    6a8e:	e9 dd       	rcall	.-1070   	; 0x6662 <report_util_axis_values>
    6a90:	db dd       	rcall	.-1098   	; 0x6648 <report_util_feedback_line_feed>
    6a92:	1f 5f       	subi	r17, 0xFF	; 255
    6a94:	18 30       	cpi	r17, 0x08	; 8
    6a96:	c0 f2       	brcs	.-80     	; 0x6a48 <report_ngc_parameters+0x1a>
    6a98:	81 ee       	ldi	r24, 0xE1	; 225
    6a9a:	93 e0       	ldi	r25, 0x03	; 3
    6a9c:	30 dc       	rcall	.-1952   	; 0x62fe <printPgmString>
    6a9e:	8f e6       	ldi	r24, 0x6F	; 111
    6aa0:	9c e0       	ldi	r25, 0x0C	; 12
    6aa2:	df dd       	rcall	.-1090   	; 0x6662 <report_util_axis_values>
    6aa4:	d1 dd       	rcall	.-1118   	; 0x6648 <report_util_feedback_line_feed>
    6aa6:	8b ed       	ldi	r24, 0xDB	; 219
    6aa8:	93 e0       	ldi	r25, 0x03	; 3
    6aaa:	29 dc       	rcall	.-1966   	; 0x62fe <printPgmString>
    6aac:	60 91 7b 0c 	lds	r22, 0x0C7B	; 0x800c7b <gc_state+0x3c>
    6ab0:	70 91 7c 0c 	lds	r23, 0x0C7C	; 0x800c7c <gc_state+0x3d>
    6ab4:	80 91 7d 0c 	lds	r24, 0x0C7D	; 0x800c7d <gc_state+0x3e>
    6ab8:	90 91 7e 0c 	lds	r25, 0x0C7E	; 0x800c7e <gc_state+0x3f>
    6abc:	68 dd       	rcall	.-1328   	; 0x658e <printFloat_CoordValue>
    6abe:	c4 dd       	rcall	.-1144   	; 0x6648 <report_util_feedback_line_feed>
    6ac0:	91 df       	rcall	.-222    	; 0x69e4 <report_probe_parameters>
    6ac2:	2c 96       	adiw	r28, 0x0c	; 12
    6ac4:	0f b6       	in	r0, 0x3f	; 63
    6ac6:	f8 94       	cli
    6ac8:	de bf       	out	0x3e, r29	; 62
    6aca:	0f be       	out	0x3f, r0	; 63
    6acc:	cd bf       	out	0x3d, r28	; 61
    6ace:	df 91       	pop	r29
    6ad0:	cf 91       	pop	r28
    6ad2:	1f 91       	pop	r17
    6ad4:	08 95       	ret

00006ad6 <report_gcode_modes>:
    6ad6:	cf 93       	push	r28
    6ad8:	df 93       	push	r29
    6ada:	85 ed       	ldi	r24, 0xD5	; 213
    6adc:	93 e0       	ldi	r25, 0x03	; 3
    6ade:	0f dc       	rcall	.-2018   	; 0x62fe <printPgmString>
    6ae0:	80 91 3f 0c 	lds	r24, 0x0C3F	; 0x800c3f <gc_state>
    6ae4:	8c 38       	cpi	r24, 0x8C	; 140
    6ae6:	40 f0       	brcs	.+16     	; 0x6af8 <report_gcode_modes+0x22>
    6ae8:	81 ed       	ldi	r24, 0xD1	; 209
    6aea:	93 e0       	ldi	r25, 0x03	; 3
    6aec:	08 dc       	rcall	.-2032   	; 0x62fe <printPgmString>
    6aee:	80 91 3f 0c 	lds	r24, 0x0C3F	; 0x800c3f <gc_state>
    6af2:	8a 58       	subi	r24, 0x8A	; 138
    6af4:	13 dc       	rcall	.-2010   	; 0x631c <print_uint8_base10>
    6af6:	01 c0       	rjmp	.+2      	; 0x6afa <report_gcode_modes+0x24>
    6af8:	11 dc       	rcall	.-2014   	; 0x631c <print_uint8_base10>
    6afa:	ab dd       	rcall	.-1194   	; 0x6652 <report_util_gcode_modes_G>
    6afc:	cf e3       	ldi	r28, 0x3F	; 63
    6afe:	dc e0       	ldi	r29, 0x0C	; 12
    6b00:	8e 81       	ldd	r24, Y+6	; 0x06
    6b02:	8a 5c       	subi	r24, 0xCA	; 202
    6b04:	0b dc       	rcall	.-2026   	; 0x631c <print_uint8_base10>
    6b06:	a5 dd       	rcall	.-1206   	; 0x6652 <report_util_gcode_modes_G>
    6b08:	8c 81       	ldd	r24, Y+4	; 0x04
    6b0a:	8f 5e       	subi	r24, 0xEF	; 239
    6b0c:	07 dc       	rcall	.-2034   	; 0x631c <print_uint8_base10>
    6b0e:	a1 dd       	rcall	.-1214   	; 0x6652 <report_util_gcode_modes_G>
    6b10:	9a 81       	ldd	r25, Y+2	; 0x02
    6b12:	85 e1       	ldi	r24, 0x15	; 21
    6b14:	89 1b       	sub	r24, r25
    6b16:	02 dc       	rcall	.-2044   	; 0x631c <print_uint8_base10>
    6b18:	9c dd       	rcall	.-1224   	; 0x6652 <report_util_gcode_modes_G>
    6b1a:	8b 81       	ldd	r24, Y+3	; 0x03
    6b1c:	86 5a       	subi	r24, 0xA6	; 166
    6b1e:	fe db       	rcall	.-2052   	; 0x631c <print_uint8_base10>
    6b20:	98 dd       	rcall	.-1232   	; 0x6652 <report_util_gcode_modes_G>
    6b22:	99 81       	ldd	r25, Y+1	; 0x01
    6b24:	8e e5       	ldi	r24, 0x5E	; 94
    6b26:	89 1b       	sub	r24, r25
    6b28:	f9 db       	rcall	.-2062   	; 0x631c <print_uint8_base10>
    6b2a:	8f 81       	ldd	r24, Y+7	; 0x07
    6b2c:	88 23       	and	r24, r24
    6b2e:	79 f0       	breq	.+30     	; 0x6b4e <report_gcode_modes+0x78>
    6b30:	94 dd       	rcall	.-1240   	; 0x665a <report_util_gcode_modes_M>
    6b32:	80 91 46 0c 	lds	r24, 0x0C46	; 0x800c46 <gc_state+0x7>
    6b36:	83 30       	cpi	r24, 0x03	; 3
    6b38:	29 f0       	breq	.+10     	; 0x6b44 <report_gcode_modes+0x6e>
    6b3a:	8e 31       	cpi	r24, 0x1E	; 30
    6b3c:	39 f0       	breq	.+14     	; 0x6b4c <report_gcode_modes+0x76>
    6b3e:	82 30       	cpi	r24, 0x02	; 2
    6b40:	31 f4       	brne	.+12     	; 0x6b4e <report_gcode_modes+0x78>
    6b42:	04 c0       	rjmp	.+8      	; 0x6b4c <report_gcode_modes+0x76>
    6b44:	80 e3       	ldi	r24, 0x30	; 48
    6b46:	0e 94 ef 13 	call	0x27de	; 0x27de <serial_write>
    6b4a:	01 c0       	rjmp	.+2      	; 0x6b4e <report_gcode_modes+0x78>
    6b4c:	e7 db       	rcall	.-2098   	; 0x631c <print_uint8_base10>
    6b4e:	85 dd       	rcall	.-1270   	; 0x665a <report_util_gcode_modes_M>
    6b50:	80 91 48 0c 	lds	r24, 0x0C48	; 0x800c48 <gc_state+0x9>
    6b54:	80 31       	cpi	r24, 0x10	; 16
    6b56:	29 f0       	breq	.+10     	; 0x6b62 <report_gcode_modes+0x8c>
    6b58:	80 32       	cpi	r24, 0x20	; 32
    6b5a:	39 f0       	breq	.+14     	; 0x6b6a <report_gcode_modes+0x94>
    6b5c:	81 11       	cpse	r24, r1
    6b5e:	0c c0       	rjmp	.+24     	; 0x6b78 <report_gcode_modes+0xa2>
    6b60:	08 c0       	rjmp	.+16     	; 0x6b72 <report_gcode_modes+0x9c>
    6b62:	83 e3       	ldi	r24, 0x33	; 51
    6b64:	0e 94 ef 13 	call	0x27de	; 0x27de <serial_write>
    6b68:	07 c0       	rjmp	.+14     	; 0x6b78 <report_gcode_modes+0xa2>
    6b6a:	84 e3       	ldi	r24, 0x34	; 52
    6b6c:	0e 94 ef 13 	call	0x27de	; 0x27de <serial_write>
    6b70:	03 c0       	rjmp	.+6      	; 0x6b78 <report_gcode_modes+0xa2>
    6b72:	85 e3       	ldi	r24, 0x35	; 53
    6b74:	0e 94 ef 13 	call	0x27de	; 0x27de <serial_write>
    6b78:	70 dd       	rcall	.-1312   	; 0x665a <report_util_gcode_modes_M>
    6b7a:	80 91 47 0c 	lds	r24, 0x0C47	; 0x800c47 <gc_state+0x8>
    6b7e:	88 23       	and	r24, r24
    6b80:	61 f0       	breq	.+24     	; 0x6b9a <report_gcode_modes+0xc4>
    6b82:	1c f4       	brge	.+6      	; 0x6b8a <report_gcode_modes+0xb4>
    6b84:	87 e3       	ldi	r24, 0x37	; 55
    6b86:	0e 94 ef 13 	call	0x27de	; 0x27de <serial_write>
    6b8a:	80 91 47 0c 	lds	r24, 0x0C47	; 0x800c47 <gc_state+0x8>
    6b8e:	86 ff       	sbrs	r24, 6
    6b90:	07 c0       	rjmp	.+14     	; 0x6ba0 <report_gcode_modes+0xca>
    6b92:	88 e3       	ldi	r24, 0x38	; 56
    6b94:	0e 94 ef 13 	call	0x27de	; 0x27de <serial_write>
    6b98:	03 c0       	rjmp	.+6      	; 0x6ba0 <report_gcode_modes+0xca>
    6b9a:	89 e3       	ldi	r24, 0x39	; 57
    6b9c:	0e 94 ef 13 	call	0x27de	; 0x27de <serial_write>
    6ba0:	8e ec       	ldi	r24, 0xCE	; 206
    6ba2:	93 e0       	ldi	r25, 0x03	; 3
    6ba4:	ac db       	rcall	.-2216   	; 0x62fe <printPgmString>
    6ba6:	cf e3       	ldi	r28, 0x3F	; 63
    6ba8:	dc e0       	ldi	r29, 0x0C	; 12
    6baa:	8b 89       	ldd	r24, Y+19	; 0x13
    6bac:	b7 db       	rcall	.-2194   	; 0x631c <print_uint8_base10>
    6bae:	8b ec       	ldi	r24, 0xCB	; 203
    6bb0:	93 e0       	ldi	r25, 0x03	; 3
    6bb2:	a5 db       	rcall	.-2230   	; 0x62fe <printPgmString>
    6bb4:	6f 85       	ldd	r22, Y+15	; 0x0f
    6bb6:	78 89       	ldd	r23, Y+16	; 0x10
    6bb8:	89 89       	ldd	r24, Y+17	; 0x11
    6bba:	9a 89       	ldd	r25, Y+18	; 0x12
    6bbc:	f8 dc       	rcall	.-1552   	; 0x65ae <printFloat_RateValue>
    6bbe:	88 ec       	ldi	r24, 0xC8	; 200
    6bc0:	93 e0       	ldi	r25, 0x03	; 3
    6bc2:	9d db       	rcall	.-2246   	; 0x62fe <printPgmString>
    6bc4:	6b 85       	ldd	r22, Y+11	; 0x0b
    6bc6:	7c 85       	ldd	r23, Y+12	; 0x0c
    6bc8:	8d 85       	ldd	r24, Y+13	; 0x0d
    6bca:	9e 85       	ldd	r25, Y+14	; 0x0e
    6bcc:	40 e0       	ldi	r20, 0x00	; 0
    6bce:	44 dc       	rcall	.-1912   	; 0x6458 <printFloat>
    6bd0:	3b dd       	rcall	.-1418   	; 0x6648 <report_util_feedback_line_feed>
    6bd2:	df 91       	pop	r29
    6bd4:	cf 91       	pop	r28
    6bd6:	08 95       	ret

00006bd8 <report_startup_line>:
    6bd8:	1f 93       	push	r17
    6bda:	cf 93       	push	r28
    6bdc:	df 93       	push	r29
    6bde:	18 2f       	mov	r17, r24
    6be0:	eb 01       	movw	r28, r22
    6be2:	8f eb       	ldi	r24, 0xBF	; 191
    6be4:	93 e0       	ldi	r25, 0x03	; 3
    6be6:	8b db       	rcall	.-2282   	; 0x62fe <printPgmString>
    6be8:	81 2f       	mov	r24, r17
    6bea:	98 db       	rcall	.-2256   	; 0x631c <print_uint8_base10>
    6bec:	8d e3       	ldi	r24, 0x3D	; 61
    6bee:	0e 94 ef 13 	call	0x27de	; 0x27de <serial_write>
    6bf2:	ce 01       	movw	r24, r28
    6bf4:	77 db       	rcall	.-2322   	; 0x62e4 <printString>
    6bf6:	24 dd       	rcall	.-1464   	; 0x6640 <report_util_line_feed>
    6bf8:	df 91       	pop	r29
    6bfa:	cf 91       	pop	r28
    6bfc:	1f 91       	pop	r17
    6bfe:	08 95       	ret

00006c00 <report_execute_startup_message>:
    6c00:	0f 93       	push	r16
    6c02:	1f 93       	push	r17
    6c04:	cf 93       	push	r28
    6c06:	8c 01       	movw	r16, r24
    6c08:	c6 2f       	mov	r28, r22
    6c0a:	8e e3       	ldi	r24, 0x3E	; 62
    6c0c:	0e 94 ef 13 	call	0x27de	; 0x27de <serial_write>
    6c10:	c8 01       	movw	r24, r16
    6c12:	68 db       	rcall	.-2352   	; 0x62e4 <printString>
    6c14:	8a e3       	ldi	r24, 0x3A	; 58
    6c16:	0e 94 ef 13 	call	0x27de	; 0x27de <serial_write>
    6c1a:	8c 2f       	mov	r24, r28
    6c1c:	69 dd       	rcall	.-1326   	; 0x66f0 <report_status_message>
    6c1e:	cf 91       	pop	r28
    6c20:	1f 91       	pop	r17
    6c22:	0f 91       	pop	r16
    6c24:	08 95       	ret

00006c26 <report_build_info>:
    6c26:	cf 93       	push	r28
    6c28:	df 93       	push	r29
    6c2a:	ec 01       	movw	r28, r24
    6c2c:	86 ea       	ldi	r24, 0xA6	; 166
    6c2e:	93 e0       	ldi	r25, 0x03	; 3
    6c30:	66 db       	rcall	.-2356   	; 0x62fe <printPgmString>
    6c32:	ce 01       	movw	r24, r28
    6c34:	57 db       	rcall	.-2386   	; 0x62e4 <printString>
    6c36:	08 dd       	rcall	.-1520   	; 0x6648 <report_util_feedback_line_feed>
    6c38:	80 ea       	ldi	r24, 0xA0	; 160
    6c3a:	93 e0       	ldi	r25, 0x03	; 3
    6c3c:	60 db       	rcall	.-2368   	; 0x62fe <printPgmString>
    6c3e:	86 e5       	ldi	r24, 0x56	; 86
    6c40:	0e 94 ef 13 	call	0x27de	; 0x27de <serial_write>
    6c44:	8e e4       	ldi	r24, 0x4E	; 78
    6c46:	0e 94 ef 13 	call	0x27de	; 0x27de <serial_write>
    6c4a:	8d e4       	ldi	r24, 0x4D	; 77
    6c4c:	0e 94 ef 13 	call	0x27de	; 0x27de <serial_write>
    6c50:	8b e2       	ldi	r24, 0x2B	; 43
    6c52:	0e 94 ef 13 	call	0x27de	; 0x27de <serial_write>
    6c56:	8c e2       	ldi	r24, 0x2C	; 44
    6c58:	0e 94 ef 13 	call	0x27de	; 0x27de <serial_write>
    6c5c:	83 e2       	ldi	r24, 0x23	; 35
    6c5e:	5e db       	rcall	.-2372   	; 0x631c <print_uint8_base10>
    6c60:	8c e2       	ldi	r24, 0x2C	; 44
    6c62:	0e 94 ef 13 	call	0x27de	; 0x27de <serial_write>
    6c66:	8f ef       	ldi	r24, 0xFF	; 255
    6c68:	59 db       	rcall	.-2382   	; 0x631c <print_uint8_base10>
    6c6a:	ee dc       	rcall	.-1572   	; 0x6648 <report_util_feedback_line_feed>
    6c6c:	df 91       	pop	r29
    6c6e:	cf 91       	pop	r28
    6c70:	08 95       	ret

00006c72 <report_realtime_status>:
 // and the actual location of the CNC machine. Users may change the following function to their
 // specific needs, but the desired real-time data report must be as short as possible. This is
 // requires as it minimizes the computational overhead and allows grbl to keep running smoothly,
 // especially during g-code programs with fast, short line segments and high frequency reports (5-20Hz).
void report_realtime_status()
{
    6c72:	8f 92       	push	r8
    6c74:	9f 92       	push	r9
    6c76:	cf 92       	push	r12
    6c78:	df 92       	push	r13
    6c7a:	ef 92       	push	r14
    6c7c:	ff 92       	push	r15
    6c7e:	0f 93       	push	r16
    6c80:	1f 93       	push	r17
    6c82:	cf 93       	push	r28
    6c84:	df 93       	push	r29
    6c86:	cd b7       	in	r28, 0x3d	; 61
    6c88:	de b7       	in	r29, 0x3e	; 62
    6c8a:	a4 97       	sbiw	r28, 0x24	; 36
    6c8c:	0f b6       	in	r0, 0x3f	; 63
    6c8e:	f8 94       	cli
    6c90:	de bf       	out	0x3e, r29	; 62
    6c92:	0f be       	out	0x3f, r0	; 63
    6c94:	cd bf       	out	0x3d, r28	; 61
  uint8_t idx;
  int32_t current_position[N_AXIS]; // Copy current state of the system position variable
  memcpy(current_position,sys_position,sizeof(sys_position));
    6c96:	8c e0       	ldi	r24, 0x0C	; 12
    6c98:	e1 e3       	ldi	r30, 0x31	; 49
    6c9a:	fc e0       	ldi	r31, 0x0C	; 12
    6c9c:	de 01       	movw	r26, r28
    6c9e:	11 96       	adiw	r26, 0x01	; 1
    6ca0:	01 90       	ld	r0, Z+
    6ca2:	0d 92       	st	X+, r0
    6ca4:	8a 95       	dec	r24
    6ca6:	e1 f7       	brne	.-8      	; 0x6ca0 <report_realtime_status+0x2e>
  float print_position[N_AXIS];
  system_convert_array_steps_to_mpos(print_position,current_position);
    6ca8:	be 01       	movw	r22, r28
    6caa:	6f 5f       	subi	r22, 0xFF	; 255
    6cac:	7f 4f       	sbci	r23, 0xFF	; 255
    6cae:	ce 01       	movw	r24, r28
    6cb0:	0d 96       	adiw	r24, 0x0d	; 13
    6cb2:	8c d2       	rcall	.+1304   	; 0x71cc <system_convert_array_steps_to_mpos>

  // Report current machine state and sub-states
  serial_write('<');
    6cb4:	8c e3       	ldi	r24, 0x3C	; 60
    6cb6:	0e 94 ef 13 	call	0x27de	; 0x27de <serial_write>
  switch (sys.state) {
    6cba:	80 91 11 0c 	lds	r24, 0x0C11	; 0x800c11 <sys>
    6cbe:	88 30       	cpi	r24, 0x08	; 8
    6cc0:	c9 f0       	breq	.+50     	; 0x6cf4 <report_realtime_status+0x82>
    6cc2:	40 f4       	brcc	.+16     	; 0x6cd4 <report_realtime_status+0x62>
    6cc4:	81 30       	cpi	r24, 0x01	; 1
    6cc6:	a9 f1       	breq	.+106    	; 0x6d32 <report_realtime_status+0xc0>
    6cc8:	88 f0       	brcs	.+34     	; 0x6cec <report_realtime_status+0x7a>
    6cca:	82 30       	cpi	r24, 0x02	; 2
    6ccc:	b1 f1       	breq	.+108    	; 0x6d3a <report_realtime_status+0xc8>
    6cce:	84 30       	cpi	r24, 0x04	; 4
    6cd0:	61 f1       	breq	.+88     	; 0x6d2a <report_realtime_status+0xb8>
    6cd2:	55 c0       	rjmp	.+170    	; 0x6d7e <report_realtime_status+0x10c>
    6cd4:	80 32       	cpi	r24, 0x20	; 32
    6cd6:	29 f1       	breq	.+74     	; 0x6d22 <report_realtime_status+0xb0>
    6cd8:	18 f4       	brcc	.+6      	; 0x6ce0 <report_realtime_status+0x6e>
    6cda:	80 31       	cpi	r24, 0x10	; 16
    6cdc:	79 f0       	breq	.+30     	; 0x6cfc <report_realtime_status+0x8a>
    6cde:	4f c0       	rjmp	.+158    	; 0x6d7e <report_realtime_status+0x10c>
    6ce0:	80 34       	cpi	r24, 0x40	; 64
    6ce2:	79 f1       	breq	.+94     	; 0x6d42 <report_realtime_status+0xd0>
    6ce4:	80 38       	cpi	r24, 0x80	; 128
    6ce6:	09 f4       	brne	.+2      	; 0x6cea <report_realtime_status+0x78>
    6ce8:	47 c0       	rjmp	.+142    	; 0x6d78 <report_realtime_status+0x106>
    6cea:	49 c0       	rjmp	.+146    	; 0x6d7e <report_realtime_status+0x10c>
    case STATE_IDLE: printPgmString(PSTR("Idle")); break;
    6cec:	8b e9       	ldi	r24, 0x9B	; 155
    6cee:	93 e0       	ldi	r25, 0x03	; 3
    6cf0:	06 db       	rcall	.-2548   	; 0x62fe <printPgmString>
    6cf2:	45 c0       	rjmp	.+138    	; 0x6d7e <report_realtime_status+0x10c>
    case STATE_CYCLE: printPgmString(PSTR("Run")); break;
    6cf4:	87 e9       	ldi	r24, 0x97	; 151
    6cf6:	93 e0       	ldi	r25, 0x03	; 3
    6cf8:	02 db       	rcall	.-2556   	; 0x62fe <printPgmString>
    6cfa:	41 c0       	rjmp	.+130    	; 0x6d7e <report_realtime_status+0x10c>
    case STATE_HOLD:
      if (!(sys.suspend & SUSPEND_JOG_CANCEL)) {
    6cfc:	80 91 13 0c 	lds	r24, 0x0C13	; 0x800c13 <sys+0x2>
    6d00:	88 23       	and	r24, r24
        printPgmString(PSTR("Hold:"));
    6d02:	7c f0       	brlt	.+30     	; 0x6d22 <report_realtime_status+0xb0>
    6d04:	81 e9       	ldi	r24, 0x91	; 145
    6d06:	93 e0       	ldi	r25, 0x03	; 3
    6d08:	fa da       	rcall	.-2572   	; 0x62fe <printPgmString>
        if (sys.suspend & SUSPEND_HOLD_COMPLETE) { serial_write('0'); } // Ready to resume
    6d0a:	80 91 13 0c 	lds	r24, 0x0C13	; 0x800c13 <sys+0x2>
    6d0e:	80 ff       	sbrs	r24, 0
    6d10:	04 c0       	rjmp	.+8      	; 0x6d1a <report_realtime_status+0xa8>
    6d12:	80 e3       	ldi	r24, 0x30	; 48
    6d14:	0e 94 ef 13 	call	0x27de	; 0x27de <serial_write>
    6d18:	32 c0       	rjmp	.+100    	; 0x6d7e <report_realtime_status+0x10c>
        else { serial_write('1'); } // Actively holding
    6d1a:	81 e3       	ldi	r24, 0x31	; 49
    6d1c:	0e 94 ef 13 	call	0x27de	; 0x27de <serial_write>
        break;
      } // Continues to print jog state during jog cancel.
    case STATE_JOG: printPgmString(PSTR("Jog")); break;
    6d20:	2e c0       	rjmp	.+92     	; 0x6d7e <report_realtime_status+0x10c>
    6d22:	8d e8       	ldi	r24, 0x8D	; 141
    6d24:	93 e0       	ldi	r25, 0x03	; 3
    6d26:	eb da       	rcall	.-2602   	; 0x62fe <printPgmString>
    case STATE_HOMING: printPgmString(PSTR("Home")); break;
    6d28:	2a c0       	rjmp	.+84     	; 0x6d7e <report_realtime_status+0x10c>
    6d2a:	88 e8       	ldi	r24, 0x88	; 136
    6d2c:	93 e0       	ldi	r25, 0x03	; 3
    6d2e:	e7 da       	rcall	.-2610   	; 0x62fe <printPgmString>
    case STATE_ALARM: printPgmString(PSTR("Alarm")); break;
    6d30:	26 c0       	rjmp	.+76     	; 0x6d7e <report_realtime_status+0x10c>
    6d32:	82 e8       	ldi	r24, 0x82	; 130
    6d34:	93 e0       	ldi	r25, 0x03	; 3
    6d36:	e3 da       	rcall	.-2618   	; 0x62fe <printPgmString>
    case STATE_CHECK_MODE: printPgmString(PSTR("Check")); break;
    6d38:	22 c0       	rjmp	.+68     	; 0x6d7e <report_realtime_status+0x10c>
    6d3a:	8c e7       	ldi	r24, 0x7C	; 124
    6d3c:	93 e0       	ldi	r25, 0x03	; 3
    6d3e:	df da       	rcall	.-2626   	; 0x62fe <printPgmString>
    6d40:	1e c0       	rjmp	.+60     	; 0x6d7e <report_realtime_status+0x10c>
    case STATE_SAFETY_DOOR:
      printPgmString(PSTR("Door:"));
    6d42:	86 e7       	ldi	r24, 0x76	; 118
    6d44:	93 e0       	ldi	r25, 0x03	; 3
    6d46:	db da       	rcall	.-2634   	; 0x62fe <printPgmString>
    6d48:	80 91 13 0c 	lds	r24, 0x0C13	; 0x800c13 <sys+0x2>
      if (sys.suspend & SUSPEND_INITIATE_RESTORE) {
    6d4c:	83 ff       	sbrs	r24, 3
    6d4e:	04 c0       	rjmp	.+8      	; 0x6d58 <report_realtime_status+0xe6>
    6d50:	83 e3       	ldi	r24, 0x33	; 51
        serial_write('3'); // Restoring
    6d52:	0e 94 ef 13 	call	0x27de	; 0x27de <serial_write>
    6d56:	13 c0       	rjmp	.+38     	; 0x6d7e <report_realtime_status+0x10c>
    6d58:	82 ff       	sbrs	r24, 2
      } else {
        if (sys.suspend & SUSPEND_RETRACT_COMPLETE) {
    6d5a:	0a c0       	rjmp	.+20     	; 0x6d70 <report_realtime_status+0xfe>
    6d5c:	85 ff       	sbrs	r24, 5
          if (sys.suspend & SUSPEND_SAFETY_DOOR_AJAR) {
    6d5e:	04 c0       	rjmp	.+8      	; 0x6d68 <report_realtime_status+0xf6>
    6d60:	81 e3       	ldi	r24, 0x31	; 49
            serial_write('1'); // Door ajar
    6d62:	0e 94 ef 13 	call	0x27de	; 0x27de <serial_write>
    6d66:	0b c0       	rjmp	.+22     	; 0x6d7e <report_realtime_status+0x10c>
    6d68:	80 e3       	ldi	r24, 0x30	; 48
          } else {
            serial_write('0');
    6d6a:	0e 94 ef 13 	call	0x27de	; 0x27de <serial_write>
    6d6e:	07 c0       	rjmp	.+14     	; 0x6d7e <report_realtime_status+0x10c>
          } // Door closed and ready to resume
        } else {
          serial_write('2'); // Retracting
    6d70:	82 e3       	ldi	r24, 0x32	; 50
    6d72:	0e 94 ef 13 	call	0x27de	; 0x27de <serial_write>
    6d76:	03 c0       	rjmp	.+6      	; 0x6d7e <report_realtime_status+0x10c>
        }
      }
      break;
    case STATE_SLEEP: printPgmString(PSTR("Sleep")); break;
    6d78:	80 e7       	ldi	r24, 0x70	; 112
    6d7a:	93 e0       	ldi	r25, 0x03	; 3
    6d7c:	c0 da       	rcall	.-2688   	; 0x62fe <printPgmString>
    6d7e:	80 91 ed 0e 	lds	r24, 0x0EED	; 0x800eed <settings+0x34>
  }

  float wco[N_AXIS];
  if (bit_isfalse(settings.status_report_mask,BITFLAG_RT_STATUS_POSITION_TYPE) ||
    6d82:	28 2f       	mov	r18, r24
    6d84:	21 70       	andi	r18, 0x01	; 1
    6d86:	e2 2e       	mov	r14, r18
    6d88:	80 ff       	sbrs	r24, 0
    6d8a:	6a c0       	rjmp	.+212    	; 0x6e60 <report_realtime_status+0x1ee>
    6d8c:	80 91 1d 0c 	lds	r24, 0x0C1D	; 0x800c1d <sys+0xc>
      (sys.report_wco_counter == 0) ) {
    6d90:	88 23       	and	r24, r24
      break;
    case STATE_SLEEP: printPgmString(PSTR("Sleep")); break;
  }

  float wco[N_AXIS];
  if (bit_isfalse(settings.status_report_mask,BITFLAG_RT_STATUS_POSITION_TYPE) ||
    6d92:	09 f4       	brne	.+2      	; 0x6d96 <report_realtime_status+0x124>
    6d94:	67 c0       	rjmp	.+206    	; 0x6e64 <report_realtime_status+0x1f2>
    6d96:	6b c0       	rjmp	.+214    	; 0x6e6e <report_realtime_status+0x1fc>
    6d98:	0f 2d       	mov	r16, r15
      (sys.report_wco_counter == 0) ) {
    for (idx=0; idx< N_AXIS; idx++) {
      // Apply work coordinate offsets and tool length offset to current position.
      wco[idx] = gc_state.coord_system[idx]+gc_state.coord_offset[idx];
    6d9a:	10 e0       	ldi	r17, 0x00	; 0
    6d9c:	f8 01       	movw	r30, r16
    6d9e:	39 96       	adiw	r30, 0x09	; 9
    6da0:	ee 0f       	add	r30, r30
    6da2:	ff 1f       	adc	r31, r31
    6da4:	ee 0f       	add	r30, r30
    6da6:	ff 1f       	adc	r31, r31
    6da8:	e1 5c       	subi	r30, 0xC1	; 193
    6daa:	f3 4f       	sbci	r31, 0xF3	; 243
    6dac:	60 81       	ld	r22, Z
    6dae:	71 81       	ldd	r23, Z+1	; 0x01
    6db0:	82 81       	ldd	r24, Z+2	; 0x02
    6db2:	93 81       	ldd	r25, Z+3	; 0x03
    6db4:	f8 01       	movw	r30, r16
    6db6:	3c 96       	adiw	r30, 0x0c	; 12
    6db8:	ee 0f       	add	r30, r30
    6dba:	ff 1f       	adc	r31, r31
    6dbc:	ee 0f       	add	r30, r30
    6dbe:	ff 1f       	adc	r31, r31
    6dc0:	e1 5c       	subi	r30, 0xC1	; 193
    6dc2:	f3 4f       	sbci	r31, 0xF3	; 243
    6dc4:	20 81       	ld	r18, Z
    6dc6:	31 81       	ldd	r19, Z+1	; 0x01
    6dc8:	42 81       	ldd	r20, Z+2	; 0x02
    6dca:	53 81       	ldd	r21, Z+3	; 0x03
    6dcc:	4e d5       	rcall	.+2716   	; 0x786a <__addsf3>
    6dce:	f8 01       	movw	r30, r16
    6dd0:	ee 0f       	add	r30, r30
    6dd2:	ff 1f       	adc	r31, r31
    6dd4:	ee 0f       	add	r30, r30
    6dd6:	ff 1f       	adc	r31, r31
    6dd8:	21 e0       	ldi	r18, 0x01	; 1
    6dda:	30 e0       	ldi	r19, 0x00	; 0
    6ddc:	2c 0f       	add	r18, r28
    6dde:	3d 1f       	adc	r19, r29
    6de0:	e2 0f       	add	r30, r18
    6de2:	f3 1f       	adc	r31, r19
    6de4:	60 8f       	std	Z+24, r22	; 0x18
    6de6:	71 8f       	std	Z+25, r23	; 0x19
    6de8:	82 8f       	std	Z+26, r24	; 0x1a
    6dea:	93 8f       	std	Z+27, r25	; 0x1b
    6dec:	32 e0       	ldi	r19, 0x02	; 2
      if (idx == TOOL_LENGTH_OFFSET_AXIS) { wco[idx] += gc_state.tool_length_offset; }
    6dee:	f3 12       	cpse	r15, r19
    6df0:	1a c0       	rjmp	.+52     	; 0x6e26 <report_realtime_status+0x1b4>
    6df2:	20 91 7b 0c 	lds	r18, 0x0C7B	; 0x800c7b <gc_state+0x3c>
    6df6:	30 91 7c 0c 	lds	r19, 0x0C7C	; 0x800c7c <gc_state+0x3d>
    6dfa:	40 91 7d 0c 	lds	r20, 0x0C7D	; 0x800c7d <gc_state+0x3e>
    6dfe:	50 91 7e 0c 	lds	r21, 0x0C7E	; 0x800c7e <gc_state+0x3f>
    6e02:	f8 01       	movw	r30, r16
    6e04:	ee 0f       	add	r30, r30
    6e06:	ff 1f       	adc	r31, r31
    6e08:	ee 0f       	add	r30, r30
    6e0a:	ff 1f       	adc	r31, r31
    6e0c:	88 24       	eor	r8, r8
    6e0e:	83 94       	inc	r8
    6e10:	91 2c       	mov	r9, r1
    6e12:	8c 0e       	add	r8, r28
    6e14:	9d 1e       	adc	r9, r29
    6e16:	8e 0e       	add	r8, r30
    6e18:	9f 1e       	adc	r9, r31
    6e1a:	27 d5       	rcall	.+2638   	; 0x786a <__addsf3>
    6e1c:	f4 01       	movw	r30, r8
    6e1e:	60 8f       	std	Z+24, r22	; 0x18
    6e20:	71 8f       	std	Z+25, r23	; 0x19
    6e22:	82 8f       	std	Z+26, r24	; 0x1a
    6e24:	93 8f       	std	Z+27, r25	; 0x1b
    6e26:	e1 10       	cpse	r14, r1
      if (bit_isfalse(settings.status_report_mask,BITFLAG_RT_STATUS_POSITION_TYPE)) {
    6e28:	19 c0       	rjmp	.+50     	; 0x6e5c <report_realtime_status+0x1ea>
    6e2a:	00 0f       	add	r16, r16
        print_position[idx] -= wco[idx];
    6e2c:	11 1f       	adc	r17, r17
    6e2e:	00 0f       	add	r16, r16
    6e30:	11 1f       	adc	r17, r17
    6e32:	21 e0       	ldi	r18, 0x01	; 1
    6e34:	30 e0       	ldi	r19, 0x00	; 0
    6e36:	2c 0f       	add	r18, r28
    6e38:	3d 1f       	adc	r19, r29
    6e3a:	02 0f       	add	r16, r18
    6e3c:	13 1f       	adc	r17, r19
    6e3e:	f8 01       	movw	r30, r16
    6e40:	20 8d       	ldd	r18, Z+24	; 0x18
    6e42:	31 8d       	ldd	r19, Z+25	; 0x19
    6e44:	42 8d       	ldd	r20, Z+26	; 0x1a
    6e46:	53 8d       	ldd	r21, Z+27	; 0x1b
    6e48:	64 85       	ldd	r22, Z+12	; 0x0c
    6e4a:	75 85       	ldd	r23, Z+13	; 0x0d
    6e4c:	86 85       	ldd	r24, Z+14	; 0x0e
    6e4e:	97 85       	ldd	r25, Z+15	; 0x0f
    6e50:	0b d5       	rcall	.+2582   	; 0x7868 <__subsf3>
    6e52:	f8 01       	movw	r30, r16
    6e54:	64 87       	std	Z+12, r22	; 0x0c
    6e56:	75 87       	std	Z+13, r23	; 0x0d
    6e58:	86 87       	std	Z+14, r24	; 0x0e
    6e5a:	97 87       	std	Z+15, r25	; 0x0f
    6e5c:	f3 94       	inc	r15
  }

  float wco[N_AXIS];
  if (bit_isfalse(settings.status_report_mask,BITFLAG_RT_STATUS_POSITION_TYPE) ||
      (sys.report_wco_counter == 0) ) {
    for (idx=0; idx< N_AXIS; idx++) {
    6e5e:	03 c0       	rjmp	.+6      	; 0x6e66 <report_realtime_status+0x1f4>
    6e60:	f1 2c       	mov	r15, r1
    6e62:	01 c0       	rjmp	.+2      	; 0x6e66 <report_realtime_status+0x1f4>
    6e64:	f1 2c       	mov	r15, r1
    6e66:	f2 e0       	ldi	r31, 0x02	; 2
    6e68:	ff 15       	cp	r31, r15
    6e6a:	08 f0       	brcs	.+2      	; 0x6e6e <report_realtime_status+0x1fc>
      }
    }
  }

  // Report machine position
  if (bit_istrue(settings.status_report_mask,BITFLAG_RT_STATUS_POSITION_TYPE)) {
    6e6c:	95 cf       	rjmp	.-214    	; 0x6d98 <report_realtime_status+0x126>
    6e6e:	ee 20       	and	r14, r14
    printPgmString(PSTR("|MPos:"));
    6e70:	21 f0       	breq	.+8      	; 0x6e7a <report_realtime_status+0x208>
    6e72:	89 e6       	ldi	r24, 0x69	; 105
    6e74:	93 e0       	ldi	r25, 0x03	; 3
    6e76:	43 da       	rcall	.-2938   	; 0x62fe <printPgmString>
  } else {
    printPgmString(PSTR("|WPos:"));
    6e78:	03 c0       	rjmp	.+6      	; 0x6e80 <report_realtime_status+0x20e>
    6e7a:	82 e6       	ldi	r24, 0x62	; 98
    6e7c:	93 e0       	ldi	r25, 0x03	; 3
  }
  report_util_axis_values(print_position);
    6e7e:	3f da       	rcall	.-2946   	; 0x62fe <printPgmString>
    6e80:	ce 01       	movw	r24, r28
    6e82:	0d 96       	adiw	r24, 0x0d	; 13

  // Returns planner and serial read buffer states.
  #ifdef REPORT_FIELD_BUFFER_STATE
    if (bit_istrue(settings.status_report_mask,BITFLAG_RT_STATUS_BUFFER_STATE)) {
    6e84:	ee db       	rcall	.-2084   	; 0x6662 <report_util_axis_values>
    6e86:	80 91 ed 0e 	lds	r24, 0x0EED	; 0x800eed <settings+0x34>
    6e8a:	81 ff       	sbrs	r24, 1
      printPgmString(PSTR("|Bf:"));
    6e8c:	0c c0       	rjmp	.+24     	; 0x6ea6 <report_realtime_status+0x234>
    6e8e:	8d e5       	ldi	r24, 0x5D	; 93
    6e90:	93 e0       	ldi	r25, 0x03	; 3
    6e92:	35 da       	rcall	.-2966   	; 0x62fe <printPgmString>
      print_uint8_base10(plan_get_block_buffer_available());
    6e94:	0e 94 89 2c 	call	0x5912	; 0x5912 <plan_get_block_buffer_available>
    6e98:	41 da       	rcall	.-2942   	; 0x631c <print_uint8_base10>
    6e9a:	8c e2       	ldi	r24, 0x2C	; 44
      serial_write(',');
    6e9c:	0e 94 ef 13 	call	0x27de	; 0x27de <serial_write>
    6ea0:	0e 94 d2 13 	call	0x27a4	; 0x27a4 <serial_get_rx_buffer_available>
      print_uint8_base10(serial_get_rx_buffer_available());
    6ea4:	3b da       	rcall	.-2954   	; 0x631c <print_uint8_base10>
    6ea6:	0e 94 c3 28 	call	0x5186	; 0x5186 <plan_get_current_block>
  #endif

  #ifdef REPORT_FIELD_LINE_NUMBERS
    // Report current line number
    plan_block_t * cur_block = plan_get_current_block();
    if (cur_block != NULL) {
    6eaa:	00 97       	sbiw	r24, 0x00	; 0
      uint32_t ln = cur_block->line_number;
    6eac:	81 f0       	breq	.+32     	; 0x6ece <report_realtime_status+0x25c>
    6eae:	fc 01       	movw	r30, r24
    6eb0:	c2 88       	ldd	r12, Z+18	; 0x12
    6eb2:	d3 88       	ldd	r13, Z+19	; 0x13
      if (ln > 0) {
    6eb4:	e4 88       	ldd	r14, Z+20	; 0x14
    6eb6:	f5 88       	ldd	r15, Z+21	; 0x15
    6eb8:	c1 14       	cp	r12, r1
    6eba:	d1 04       	cpc	r13, r1
    6ebc:	e1 04       	cpc	r14, r1
        printPgmString(PSTR("|Ln:"));
    6ebe:	f1 04       	cpc	r15, r1
    6ec0:	31 f0       	breq	.+12     	; 0x6ece <report_realtime_status+0x25c>
    6ec2:	88 e5       	ldi	r24, 0x58	; 88
    6ec4:	93 e0       	ldi	r25, 0x03	; 3
        printInteger(ln);
    6ec6:	1b da       	rcall	.-3018   	; 0x62fe <printPgmString>
    6ec8:	c7 01       	movw	r24, r14
    6eca:	b6 01       	movw	r22, r12
    }
  #endif

  // Report realtime feed speed
  #ifdef REPORT_FIELD_CURRENT_FEED_SPEED
    printPgmString(PSTR("|FS:"));
    6ecc:	ab da       	rcall	.-2730   	; 0x6424 <printInteger>
    6ece:	83 e5       	ldi	r24, 0x53	; 83
    6ed0:	93 e0       	ldi	r25, 0x03	; 3
    printFloat_RateValue(st_get_realtime_rate());
    6ed2:	15 da       	rcall	.-3030   	; 0x62fe <printPgmString>
    6ed4:	0e 94 af 23 	call	0x475e	; 0x475e <st_get_realtime_rate>
    6ed8:	6a db       	rcall	.-2348   	; 0x65ae <printFloat_RateValue>
    serial_write(',');
    6eda:	8c e2       	ldi	r24, 0x2C	; 44
    6edc:	0e 94 ef 13 	call	0x27de	; 0x27de <serial_write>
    printFloat(sys.spindle_speed,N_DECIMAL_RPMVALUE);
    6ee0:	60 91 1e 0c 	lds	r22, 0x0C1E	; 0x800c1e <sys+0xd>
    6ee4:	70 91 1f 0c 	lds	r23, 0x0C1F	; 0x800c1f <sys+0xe>
    6ee8:	80 91 20 0c 	lds	r24, 0x0C20	; 0x800c20 <sys+0xf>
    6eec:	90 91 21 0c 	lds	r25, 0x0C21	; 0x800c21 <sys+0x10>
    6ef0:	40 e0       	ldi	r20, 0x00	; 0
    6ef2:	b2 da       	rcall	.-2716   	; 0x6458 <printFloat>
  #endif

  #ifdef REPORT_FIELD_PIN_STATE
    uint8_t lim_pin_state = limits_get_state();
    6ef4:	0e 94 ca 2e 	call	0x5d94	; 0x5d94 <limits_get_state>
    6ef8:	08 2f       	mov	r16, r24
    uint8_t ctrl_pin_state = system_control_get_state();
    6efa:	ca d0       	rcall	.+404    	; 0x7090 <system_control_get_state>
    6efc:	18 2f       	mov	r17, r24
    6efe:	85 db       	rcall	.-2294   	; 0x660a <probe_get_state>
    uint8_t prb_pin_state = probe_get_state();
    6f00:	f8 2e       	mov	r15, r24
    6f02:	80 2f       	mov	r24, r16
    6f04:	81 2b       	or	r24, r17
    if (lim_pin_state | ctrl_pin_state | prb_pin_state) {
    6f06:	8f 29       	or	r24, r15
    6f08:	79 f1       	breq	.+94     	; 0x6f68 <report_realtime_status+0x2f6>
    6f0a:	8e e4       	ldi	r24, 0x4E	; 78
    6f0c:	93 e0       	ldi	r25, 0x03	; 3
      printPgmString(PSTR("|Pn:"));
    6f0e:	f7 d9       	rcall	.-3090   	; 0x62fe <printPgmString>
    6f10:	ff 20       	and	r15, r15
    6f12:	19 f0       	breq	.+6      	; 0x6f1a <report_realtime_status+0x2a8>
    6f14:	80 e5       	ldi	r24, 0x50	; 80
      if (prb_pin_state) { serial_write('P'); }
    6f16:	0e 94 ef 13 	call	0x27de	; 0x27de <serial_write>
    6f1a:	00 23       	and	r16, r16
    6f1c:	79 f0       	breq	.+30     	; 0x6f3c <report_realtime_status+0x2ca>
    6f1e:	00 ff       	sbrs	r16, 0
      if (lim_pin_state) {
    6f20:	03 c0       	rjmp	.+6      	; 0x6f28 <report_realtime_status+0x2b6>
    6f22:	88 e5       	ldi	r24, 0x58	; 88
        if (bit_istrue(lim_pin_state,bit(X_AXIS))) { serial_write('X'); }
    6f24:	0e 94 ef 13 	call	0x27de	; 0x27de <serial_write>
    6f28:	01 ff       	sbrs	r16, 1
    6f2a:	03 c0       	rjmp	.+6      	; 0x6f32 <report_realtime_status+0x2c0>
    6f2c:	89 e5       	ldi	r24, 0x59	; 89
        if (bit_istrue(lim_pin_state,bit(Y_AXIS))) { serial_write('Y'); }
    6f2e:	0e 94 ef 13 	call	0x27de	; 0x27de <serial_write>
    6f32:	02 ff       	sbrs	r16, 2
    6f34:	03 c0       	rjmp	.+6      	; 0x6f3c <report_realtime_status+0x2ca>
    6f36:	8a e5       	ldi	r24, 0x5A	; 90
        if (bit_istrue(lim_pin_state,bit(Z_AXIS))) { serial_write('Z'); }
    6f38:	0e 94 ef 13 	call	0x27de	; 0x27de <serial_write>
    6f3c:	11 23       	and	r17, r17
    6f3e:	a1 f0       	breq	.+40     	; 0x6f68 <report_realtime_status+0x2f6>
    6f40:	10 ff       	sbrs	r17, 0
      }
      if (ctrl_pin_state) {
    6f42:	03 c0       	rjmp	.+6      	; 0x6f4a <report_realtime_status+0x2d8>
    6f44:	84 e4       	ldi	r24, 0x44	; 68
        if (bit_istrue(ctrl_pin_state,CONTROL_PIN_INDEX_SAFETY_DOOR)) { serial_write('D'); }
    6f46:	0e 94 ef 13 	call	0x27de	; 0x27de <serial_write>
    6f4a:	11 ff       	sbrs	r17, 1
    6f4c:	03 c0       	rjmp	.+6      	; 0x6f54 <report_realtime_status+0x2e2>
    6f4e:	82 e5       	ldi	r24, 0x52	; 82
        if (bit_istrue(ctrl_pin_state,CONTROL_PIN_INDEX_RESET)) { serial_write('R'); }
    6f50:	0e 94 ef 13 	call	0x27de	; 0x27de <serial_write>
    6f54:	12 ff       	sbrs	r17, 2
    6f56:	03 c0       	rjmp	.+6      	; 0x6f5e <report_realtime_status+0x2ec>
    6f58:	88 e4       	ldi	r24, 0x48	; 72
        if (bit_istrue(ctrl_pin_state,CONTROL_PIN_INDEX_FEED_HOLD)) { serial_write('H'); }
    6f5a:	0e 94 ef 13 	call	0x27de	; 0x27de <serial_write>
    6f5e:	13 ff       	sbrs	r17, 3
    6f60:	03 c0       	rjmp	.+6      	; 0x6f68 <report_realtime_status+0x2f6>
    6f62:	83 e5       	ldi	r24, 0x53	; 83
        if (bit_istrue(ctrl_pin_state,CONTROL_PIN_INDEX_CYCLE_START)) { serial_write('S'); }
    6f64:	0e 94 ef 13 	call	0x27de	; 0x27de <serial_write>
    6f68:	80 91 1d 0c 	lds	r24, 0x0C1D	; 0x800c1d <sys+0xc>
    6f6c:	88 23       	and	r24, r24
      }
    }
  #endif

  #ifdef REPORT_FIELD_WORK_COORD_OFFSET
    if (sys.report_wco_counter > 0) { sys.report_wco_counter--; }
    6f6e:	21 f0       	breq	.+8      	; 0x6f78 <report_realtime_status+0x306>
    6f70:	81 50       	subi	r24, 0x01	; 1
    6f72:	80 93 1d 0c 	sts	0x0C1D, r24	; 0x800c1d <sys+0xc>
    6f76:	18 c0       	rjmp	.+48     	; 0x6fa8 <report_realtime_status+0x336>
    6f78:	80 91 11 0c 	lds	r24, 0x0C11	; 0x800c11 <sys>
    else {
      if (sys.state & (STATE_HOMING | STATE_CYCLE | STATE_HOLD | STATE_JOG | STATE_SAFETY_DOOR)) {
    6f7c:	8c 77       	andi	r24, 0x7C	; 124
    6f7e:	21 f0       	breq	.+8      	; 0x6f88 <report_realtime_status+0x316>
    6f80:	8d e1       	ldi	r24, 0x1D	; 29
        sys.report_wco_counter = (REPORT_WCO_REFRESH_BUSY_COUNT-1); // Reset counter for slow refresh
    6f82:	80 93 1d 0c 	sts	0x0C1D, r24	; 0x800c1d <sys+0xc>
    6f86:	03 c0       	rjmp	.+6      	; 0x6f8e <report_realtime_status+0x31c>
    6f88:	89 e0       	ldi	r24, 0x09	; 9
      } else { sys.report_wco_counter = (REPORT_WCO_REFRESH_IDLE_COUNT-1); }
    6f8a:	80 93 1d 0c 	sts	0x0C1D, r24	; 0x800c1d <sys+0xc>
    6f8e:	80 91 1c 0c 	lds	r24, 0x0C1C	; 0x800c1c <sys+0xb>
      if (sys.report_ovr_counter == 0) { sys.report_ovr_counter = 1; } // Set override on next report.
    6f92:	81 11       	cpse	r24, r1
    6f94:	03 c0       	rjmp	.+6      	; 0x6f9c <report_realtime_status+0x32a>
    6f96:	81 e0       	ldi	r24, 0x01	; 1
    6f98:	80 93 1c 0c 	sts	0x0C1C, r24	; 0x800c1c <sys+0xb>
    6f9c:	88 e4       	ldi	r24, 0x48	; 72
      printPgmString(PSTR("|WCO:"));
    6f9e:	93 e0       	ldi	r25, 0x03	; 3
    6fa0:	ae d9       	rcall	.-3236   	; 0x62fe <printPgmString>
    6fa2:	ce 01       	movw	r24, r28
      report_util_axis_values(wco);
    6fa4:	49 96       	adiw	r24, 0x19	; 25
    6fa6:	5d db       	rcall	.-2374   	; 0x6662 <report_util_axis_values>
    6fa8:	80 91 1c 0c 	lds	r24, 0x0C1C	; 0x800c1c <sys+0xb>
    }
  #endif

  #ifdef REPORT_FIELD_OVERRIDES
    if (sys.report_ovr_counter > 0) { sys.report_ovr_counter--; }
    6fac:	88 23       	and	r24, r24
    6fae:	21 f0       	breq	.+8      	; 0x6fb8 <report_realtime_status+0x346>
    6fb0:	81 50       	subi	r24, 0x01	; 1
    6fb2:	80 93 1c 0c 	sts	0x0C1C, r24	; 0x800c1c <sys+0xb>
    6fb6:	41 c0       	rjmp	.+130    	; 0x703a <report_realtime_status+0x3c8>
    else {
      if (sys.state & (STATE_HOMING | STATE_CYCLE | STATE_HOLD | STATE_JOG | STATE_SAFETY_DOOR)) {
    6fb8:	80 91 11 0c 	lds	r24, 0x0C11	; 0x800c11 <sys>
    6fbc:	8c 77       	andi	r24, 0x7C	; 124
        sys.report_ovr_counter = (REPORT_OVR_REFRESH_BUSY_COUNT-1); // Reset counter for slow refresh
    6fbe:	21 f0       	breq	.+8      	; 0x6fc8 <report_realtime_status+0x356>
    6fc0:	83 e1       	ldi	r24, 0x13	; 19
    6fc2:	80 93 1c 0c 	sts	0x0C1C, r24	; 0x800c1c <sys+0xb>
      } else { sys.report_ovr_counter = (REPORT_OVR_REFRESH_IDLE_COUNT-1); }
    6fc6:	03 c0       	rjmp	.+6      	; 0x6fce <report_realtime_status+0x35c>
    6fc8:	89 e0       	ldi	r24, 0x09	; 9
    6fca:	80 93 1c 0c 	sts	0x0C1C, r24	; 0x800c1c <sys+0xb>
      printPgmString(PSTR("|Ov:"));
    6fce:	83 e4       	ldi	r24, 0x43	; 67
    6fd0:	93 e0       	ldi	r25, 0x03	; 3
      print_uint8_base10(sys.f_override);
    6fd2:	95 d9       	rcall	.-3286   	; 0x62fe <printPgmString>
    6fd4:	01 e1       	ldi	r16, 0x11	; 17
    6fd6:	1c e0       	ldi	r17, 0x0C	; 12
    6fd8:	f8 01       	movw	r30, r16
    6fda:	87 81       	ldd	r24, Z+7	; 0x07
    6fdc:	9f d9       	rcall	.-3266   	; 0x631c <print_uint8_base10>
      serial_write(',');
    6fde:	8c e2       	ldi	r24, 0x2C	; 44
    6fe0:	0e 94 ef 13 	call	0x27de	; 0x27de <serial_write>
      print_uint8_base10(sys.r_override);
    6fe4:	f8 01       	movw	r30, r16
    6fe6:	80 85       	ldd	r24, Z+8	; 0x08
    6fe8:	99 d9       	rcall	.-3278   	; 0x631c <print_uint8_base10>
    6fea:	8c e2       	ldi	r24, 0x2C	; 44
      serial_write(',');
    6fec:	0e 94 ef 13 	call	0x27de	; 0x27de <serial_write>
    6ff0:	f8 01       	movw	r30, r16
      print_uint8_base10(sys.spindle_speed_ovr);
    6ff2:	81 85       	ldd	r24, Z+9	; 0x09
    6ff4:	93 d9       	rcall	.-3290   	; 0x631c <print_uint8_base10>
    6ff6:	0e 94 35 12 	call	0x246a	; 0x246a <spindle_get_state>

      uint8_t sp_state = spindle_get_state();
    6ffa:	08 2f       	mov	r16, r24
    6ffc:	0e 94 87 13 	call	0x270e	; 0x270e <coolant_get_state>
      uint8_t cl_state = coolant_get_state();
    7000:	18 2f       	mov	r17, r24
    7002:	01 11       	cpse	r16, r1
    7004:	02 c0       	rjmp	.+4      	; 0x700a <report_realtime_status+0x398>
      if (sp_state || cl_state) {
    7006:	88 23       	and	r24, r24
    7008:	c1 f0       	breq	.+48     	; 0x703a <report_realtime_status+0x3c8>
    700a:	8f e3       	ldi	r24, 0x3F	; 63
        printPgmString(PSTR("|A:"));
    700c:	93 e0       	ldi	r25, 0x03	; 3
    700e:	77 d9       	rcall	.-3346   	; 0x62fe <printPgmString>
    7010:	00 23       	and	r16, r16
    7012:	49 f0       	breq	.+18     	; 0x7026 <report_realtime_status+0x3b4>
        if (sp_state) { // != SPINDLE_STATE_DISABLE
    7014:	01 30       	cpi	r16, 0x01	; 1
    7016:	21 f4       	brne	.+8      	; 0x7020 <report_realtime_status+0x3ae>
          if (sp_state == SPINDLE_STATE_CW) { serial_write('S'); } // CW
    7018:	83 e5       	ldi	r24, 0x53	; 83
    701a:	0e 94 ef 13 	call	0x27de	; 0x27de <serial_write>
    701e:	03 c0       	rjmp	.+6      	; 0x7026 <report_realtime_status+0x3b4>
    7020:	83 e4       	ldi	r24, 0x43	; 67
    7022:	0e 94 ef 13 	call	0x27de	; 0x27de <serial_write>
          else { serial_write('C'); } // CCW
    7026:	16 ff       	sbrs	r17, 6
    7028:	03 c0       	rjmp	.+6      	; 0x7030 <report_realtime_status+0x3be>
        }
        if (cl_state & COOLANT_STATE_FLOOD) { serial_write('F'); }
    702a:	86 e4       	ldi	r24, 0x46	; 70
    702c:	0e 94 ef 13 	call	0x27de	; 0x27de <serial_write>
    7030:	11 23       	and	r17, r17
    7032:	1c f4       	brge	.+6      	; 0x703a <report_realtime_status+0x3c8>
        if (cl_state & COOLANT_STATE_MIST) { serial_write('M'); }
    7034:	8d e4       	ldi	r24, 0x4D	; 77
    7036:	0e 94 ef 13 	call	0x27de	; 0x27de <serial_write>
    703a:	8e e3       	ldi	r24, 0x3E	; 62
    703c:	0e 94 ef 13 	call	0x27de	; 0x27de <serial_write>
      }  
    }
  #endif

  serial_write('>');
    7040:	ff da       	rcall	.-2562   	; 0x6640 <report_util_line_feed>
    7042:	a4 96       	adiw	r28, 0x24	; 36
  report_util_line_feed();
    7044:	0f b6       	in	r0, 0x3f	; 63
    7046:	f8 94       	cli
}
    7048:	de bf       	out	0x3e, r29	; 62
    704a:	0f be       	out	0x3f, r0	; 63
    704c:	cd bf       	out	0x3d, r28	; 61
    704e:	df 91       	pop	r29
    7050:	cf 91       	pop	r28
    7052:	1f 91       	pop	r17
    7054:	0f 91       	pop	r16
    7056:	ff 90       	pop	r15
    7058:	ef 90       	pop	r14
    705a:	df 90       	pop	r13
    705c:	cf 90       	pop	r12
    705e:	9f 90       	pop	r9
    7060:	8f 90       	pop	r8
    7062:	08 95       	ret

00007064 <report_realtime_debug>:
    7064:	08 95       	ret

00007066 <system_init>:
#include "grbl.h"


void system_init()
{
  CONTROL_DDR &= ~(CONTROL_MASK); // Configure as input pins
    7066:	e7 e0       	ldi	r30, 0x07	; 7
    7068:	f1 e0       	ldi	r31, 0x01	; 1
    706a:	80 81       	ld	r24, Z
    706c:	80 7f       	andi	r24, 0xF0	; 240
    706e:	80 83       	st	Z, r24
  #ifdef DISABLE_CONTROL_PIN_PULL_UP
    CONTROL_PORT &= ~(CONTROL_MASK); // Normal low operation. Requires external pull-down.
  #else
    CONTROL_PORT |= CONTROL_MASK;   // Enable internal pull-up resistors. Normal high operation.
    7070:	e8 e0       	ldi	r30, 0x08	; 8
    7072:	f1 e0       	ldi	r31, 0x01	; 1
    7074:	80 81       	ld	r24, Z
    7076:	8f 60       	ori	r24, 0x0F	; 15
    7078:	80 83       	st	Z, r24
  #endif
  CONTROL_PCMSK |= CONTROL_MASK;  // Enable specific pins of the Pin Change Interrupt
    707a:	ed e6       	ldi	r30, 0x6D	; 109
    707c:	f0 e0       	ldi	r31, 0x00	; 0
    707e:	80 81       	ld	r24, Z
    7080:	8f 60       	ori	r24, 0x0F	; 15
    7082:	80 83       	st	Z, r24
  PCICR |= (1 << CONTROL_INT);   // Enable Pin Change Interrupt
    7084:	e8 e6       	ldi	r30, 0x68	; 104
    7086:	f0 e0       	ldi	r31, 0x00	; 0
    7088:	80 81       	ld	r24, Z
    708a:	84 60       	ori	r24, 0x04	; 4
    708c:	80 83       	st	Z, r24
    708e:	08 95       	ret

00007090 <system_control_get_state>:
// triggered is 1 and not triggered is 0. Invert mask is applied. Bitfield organization is
// defined by the CONTROL_PIN_INDEX in the header file.
uint8_t system_control_get_state()
{
  uint8_t control_state = 0;
  uint8_t pin = (CONTROL_PIN & CONTROL_MASK);
    7090:	90 91 06 01 	lds	r25, 0x0106	; 0x800106 <__TEXT_REGION_LENGTH__+0x7c0106>
    7094:	89 2f       	mov	r24, r25
    7096:	8f 70       	andi	r24, 0x0F	; 15
  #ifdef INVERT_CONTROL_PIN_MASK
    pin ^= INVERT_CONTROL_PIN_MASK;
  #endif
  if (pin) {
    7098:	69 f0       	breq	.+26     	; 0x70b4 <system_control_get_state+0x24>
    if (bit_isfalse(pin,(1<<CONTROL_SAFETY_DOOR_BIT))) { control_state |= CONTROL_PIN_INDEX_SAFETY_DOOR; }
    709a:	93 ff       	sbrs	r25, 3
    709c:	02 c0       	rjmp	.+4      	; 0x70a2 <system_control_get_state+0x12>
// Returns control pin state as a uint8 bitfield. Each bit indicates the input pin state, where
// triggered is 1 and not triggered is 0. Invert mask is applied. Bitfield organization is
// defined by the CONTROL_PIN_INDEX in the header file.
uint8_t system_control_get_state()
{
  uint8_t control_state = 0;
    709e:	80 e0       	ldi	r24, 0x00	; 0
    70a0:	01 c0       	rjmp	.+2      	; 0x70a4 <system_control_get_state+0x14>
  uint8_t pin = (CONTROL_PIN & CONTROL_MASK);
  #ifdef INVERT_CONTROL_PIN_MASK
    pin ^= INVERT_CONTROL_PIN_MASK;
  #endif
  if (pin) {
    if (bit_isfalse(pin,(1<<CONTROL_SAFETY_DOOR_BIT))) { control_state |= CONTROL_PIN_INDEX_SAFETY_DOOR; }
    70a2:	81 e0       	ldi	r24, 0x01	; 1
    if (bit_isfalse(pin,(1<<CONTROL_RESET_BIT))) { control_state |= CONTROL_PIN_INDEX_RESET; }
    70a4:	90 ff       	sbrs	r25, 0
    70a6:	82 60       	ori	r24, 0x02	; 2
    if (bit_isfalse(pin,(1<<CONTROL_FEED_HOLD_BIT))) { control_state |= CONTROL_PIN_INDEX_FEED_HOLD; }
    70a8:	91 ff       	sbrs	r25, 1
    70aa:	84 60       	ori	r24, 0x04	; 4
    if (bit_isfalse(pin,(1<<CONTROL_CYCLE_START_BIT))) { control_state |= CONTROL_PIN_INDEX_CYCLE_START; }
    70ac:	92 fd       	sbrc	r25, 2
    70ae:	03 c0       	rjmp	.+6      	; 0x70b6 <system_control_get_state+0x26>
    70b0:	88 60       	ori	r24, 0x08	; 8
    70b2:	08 95       	ret
// Returns control pin state as a uint8 bitfield. Each bit indicates the input pin state, where
// triggered is 1 and not triggered is 0. Invert mask is applied. Bitfield organization is
// defined by the CONTROL_PIN_INDEX in the header file.
uint8_t system_control_get_state()
{
  uint8_t control_state = 0;
    70b4:	80 e0       	ldi	r24, 0x00	; 0
    if (bit_isfalse(pin,(1<<CONTROL_RESET_BIT))) { control_state |= CONTROL_PIN_INDEX_RESET; }
    if (bit_isfalse(pin,(1<<CONTROL_FEED_HOLD_BIT))) { control_state |= CONTROL_PIN_INDEX_FEED_HOLD; }
    if (bit_isfalse(pin,(1<<CONTROL_CYCLE_START_BIT))) { control_state |= CONTROL_PIN_INDEX_CYCLE_START; }
  }
  return(control_state);
}
    70b6:	08 95       	ret

000070b8 <__vector_11>:
// Pin change interrupt for pin-out commands, i.e. cycle start, feed hold, and reset. Sets
// only the realtime command execute variable to have the main program execute these when
// its ready. This works exactly like the character-based realtime commands when picked off
// directly from the incoming serial data stream.
ISR(CONTROL_INT_vect)
{
    70b8:	1f 92       	push	r1
    70ba:	0f 92       	push	r0
    70bc:	0f b6       	in	r0, 0x3f	; 63
    70be:	0f 92       	push	r0
    70c0:	11 24       	eor	r1, r1
    70c2:	0b b6       	in	r0, 0x3b	; 59
    70c4:	0f 92       	push	r0
    70c6:	2f 93       	push	r18
    70c8:	3f 93       	push	r19
    70ca:	4f 93       	push	r20
    70cc:	5f 93       	push	r21
    70ce:	6f 93       	push	r22
    70d0:	7f 93       	push	r23
    70d2:	8f 93       	push	r24
    70d4:	9f 93       	push	r25
    70d6:	af 93       	push	r26
    70d8:	bf 93       	push	r27
    70da:	ef 93       	push	r30
    70dc:	ff 93       	push	r31
  uint8_t pin = system_control_get_state();
    70de:	d8 df       	rcall	.-80     	; 0x7090 <system_control_get_state>
  if (pin) {
    70e0:	88 23       	and	r24, r24
    70e2:	e1 f0       	breq	.+56     	; 0x711c <__vector_11+0x64>
    if (bit_istrue(pin,CONTROL_PIN_INDEX_RESET)) {
    70e4:	81 ff       	sbrs	r24, 1
    70e6:	03 c0       	rjmp	.+6      	; 0x70ee <__vector_11+0x36>
      mc_reset();
    70e8:	0e 94 ac 06 	call	0xd58	; 0xd58 <mc_reset>
    70ec:	17 c0       	rjmp	.+46     	; 0x711c <__vector_11+0x64>
    } else if (bit_istrue(pin,CONTROL_PIN_INDEX_CYCLE_START)) {
    70ee:	83 ff       	sbrs	r24, 3
    70f0:	06 c0       	rjmp	.+12     	; 0x70fe <__vector_11+0x46>
      bit_true(sys_rt_exec_state, EXEC_CYCLE_START);
    70f2:	80 91 23 0c 	lds	r24, 0x0C23	; 0x800c23 <sys_rt_exec_state>
    70f6:	82 60       	ori	r24, 0x02	; 2
    70f8:	80 93 23 0c 	sts	0x0C23, r24	; 0x800c23 <sys_rt_exec_state>
    70fc:	0f c0       	rjmp	.+30     	; 0x711c <__vector_11+0x64>
    } else if (bit_istrue(pin,CONTROL_PIN_INDEX_FEED_HOLD)) {
    70fe:	82 ff       	sbrs	r24, 2
    7100:	06 c0       	rjmp	.+12     	; 0x710e <__vector_11+0x56>
      bit_true(sys_rt_exec_state, EXEC_FEED_HOLD); 
    7102:	80 91 23 0c 	lds	r24, 0x0C23	; 0x800c23 <sys_rt_exec_state>
    7106:	88 60       	ori	r24, 0x08	; 8
    7108:	80 93 23 0c 	sts	0x0C23, r24	; 0x800c23 <sys_rt_exec_state>
    710c:	07 c0       	rjmp	.+14     	; 0x711c <__vector_11+0x64>
    } else if (bit_istrue(pin,CONTROL_PIN_INDEX_SAFETY_DOOR)) {
    710e:	80 ff       	sbrs	r24, 0
    7110:	05 c0       	rjmp	.+10     	; 0x711c <__vector_11+0x64>
      bit_true(sys_rt_exec_state, EXEC_SAFETY_DOOR);
    7112:	80 91 23 0c 	lds	r24, 0x0C23	; 0x800c23 <sys_rt_exec_state>
    7116:	80 62       	ori	r24, 0x20	; 32
    7118:	80 93 23 0c 	sts	0x0C23, r24	; 0x800c23 <sys_rt_exec_state>
    } 
  }
}
    711c:	ff 91       	pop	r31
    711e:	ef 91       	pop	r30
    7120:	bf 91       	pop	r27
    7122:	af 91       	pop	r26
    7124:	9f 91       	pop	r25
    7126:	8f 91       	pop	r24
    7128:	7f 91       	pop	r23
    712a:	6f 91       	pop	r22
    712c:	5f 91       	pop	r21
    712e:	4f 91       	pop	r20
    7130:	3f 91       	pop	r19
    7132:	2f 91       	pop	r18
    7134:	0f 90       	pop	r0
    7136:	0b be       	out	0x3b, r0	; 59
    7138:	0f 90       	pop	r0
    713a:	0f be       	out	0x3f, r0	; 63
    713c:	0f 90       	pop	r0
    713e:	1f 90       	pop	r1
    7140:	18 95       	reti

00007142 <system_check_safety_door_ajar>:


// Returns if safety door is ajar(T) or closed(F), based on pin state.
uint8_t system_check_safety_door_ajar()
{
    return(system_control_get_state() & CONTROL_PIN_INDEX_SAFETY_DOOR);
    7142:	a6 df       	rcall	.-180    	; 0x7090 <system_control_get_state>
}
    7144:	81 70       	andi	r24, 0x01	; 1
    7146:	08 95       	ret

00007148 <system_execute_startup>:


// Executes user startup script, if stored.
void system_execute_startup(char *line)
{
    7148:	0f 93       	push	r16
    714a:	1f 93       	push	r17
    714c:	cf 93       	push	r28
    714e:	8c 01       	movw	r16, r24
  uint8_t n;
  for (n=0; n < N_STARTUP_LINE; n++) {
    7150:	c0 e0       	ldi	r28, 0x00	; 0
    7152:	17 c0       	rjmp	.+46     	; 0x7182 <system_execute_startup+0x3a>
    if (!(settings_read_startup_line(n, line))) {
    7154:	b8 01       	movw	r22, r16
    7156:	8c 2f       	mov	r24, r28
    7158:	0e 94 e7 24 	call	0x49ce	; 0x49ce <settings_read_startup_line>
    715c:	81 11       	cpse	r24, r1
    715e:	06 c0       	rjmp	.+12     	; 0x716c <system_execute_startup+0x24>
      line[0] = 0;
    7160:	f8 01       	movw	r30, r16
    7162:	10 82       	st	Z, r1
      report_execute_startup_message(line,STATUS_SETTING_READ_FAIL);
    7164:	67 e0       	ldi	r22, 0x07	; 7
    7166:	c8 01       	movw	r24, r16
    7168:	4b dd       	rcall	.-1386   	; 0x6c00 <report_execute_startup_message>
    716a:	0a c0       	rjmp	.+20     	; 0x7180 <system_execute_startup+0x38>
    } else {
      if (line[0] != 0) {
    716c:	f8 01       	movw	r30, r16
    716e:	80 81       	ld	r24, Z
    7170:	88 23       	and	r24, r24
    7172:	31 f0       	breq	.+12     	; 0x7180 <system_execute_startup+0x38>
        uint8_t status_code = gc_execute_line(line);
    7174:	c8 01       	movw	r24, r16
    7176:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <gc_execute_line>
        report_execute_startup_message(line,status_code);
    717a:	68 2f       	mov	r22, r24
    717c:	c8 01       	movw	r24, r16
    717e:	40 dd       	rcall	.-1408   	; 0x6c00 <report_execute_startup_message>

// Executes user startup script, if stored.
void system_execute_startup(char *line)
{
  uint8_t n;
  for (n=0; n < N_STARTUP_LINE; n++) {
    7180:	cf 5f       	subi	r28, 0xFF	; 255
    7182:	c2 30       	cpi	r28, 0x02	; 2
    7184:	38 f3       	brcs	.-50     	; 0x7154 <system_execute_startup+0xc>
        uint8_t status_code = gc_execute_line(line);
        report_execute_startup_message(line,status_code);
      }
    }
  }
}
    7186:	cf 91       	pop	r28
    7188:	1f 91       	pop	r17
    718a:	0f 91       	pop	r16
    718c:	08 95       	ret

0000718e <system_flag_wco_change>:


void system_flag_wco_change()
{
  #ifdef FORCE_BUFFER_SYNC_DURING_WCO_CHANGE
    protocol_buffer_synchronize();
    718e:	0e 94 5a 18 	call	0x30b4	; 0x30b4 <protocol_buffer_synchronize>
  #endif
  sys.report_wco_counter = 0;
    7192:	10 92 1d 0c 	sts	0x0C1D, r1	; 0x800c1d <sys+0xc>
    7196:	08 95       	ret

00007198 <system_convert_axis_steps_to_mpos>:

// Returns machine position of axis 'idx'. Must be sent a 'step' array.
// NOTE: If motor steps and machine position are not in the same coordinate frame, this function
//   serves as a central place to compute the transformation.
float system_convert_axis_steps_to_mpos(int32_t *steps, uint8_t idx)
{
    7198:	cf 93       	push	r28
    719a:	df 93       	push	r29
      pos = (float)system_convert_corexy_to_y_axis_steps(steps) / settings.steps_per_mm[idx];
    } else {
      pos = steps[idx]/settings.steps_per_mm[idx];
    }
  #else
    pos = steps[idx]/settings.steps_per_mm[idx];
    719c:	c6 2f       	mov	r28, r22
    719e:	d0 e0       	ldi	r29, 0x00	; 0
    71a0:	cc 0f       	add	r28, r28
    71a2:	dd 1f       	adc	r29, r29
    71a4:	cc 0f       	add	r28, r28
    71a6:	dd 1f       	adc	r29, r29
    71a8:	8c 0f       	add	r24, r28
    71aa:	9d 1f       	adc	r25, r29
    71ac:	fc 01       	movw	r30, r24
    71ae:	60 81       	ld	r22, Z
    71b0:	71 81       	ldd	r23, Z+1	; 0x01
    71b2:	82 81       	ldd	r24, Z+2	; 0x02
    71b4:	93 81       	ldd	r25, Z+3	; 0x03
    71b6:	d4 d4       	rcall	.+2472   	; 0x7b60 <__floatsisf>
    71b8:	c7 54       	subi	r28, 0x47	; 71
    71ba:	d1 4f       	sbci	r29, 0xF1	; 241
    71bc:	28 81       	ld	r18, Y
    71be:	39 81       	ldd	r19, Y+1	; 0x01
    71c0:	4a 81       	ldd	r20, Y+2	; 0x02
    71c2:	5b 81       	ldd	r21, Y+3	; 0x03
    71c4:	32 d4       	rcall	.+2148   	; 0x7a2a <__divsf3>
  #endif
  return(pos);
}
    71c6:	df 91       	pop	r29
    71c8:	cf 91       	pop	r28
    71ca:	08 95       	ret

000071cc <system_convert_array_steps_to_mpos>:


void system_convert_array_steps_to_mpos(float *position, int32_t *steps)
{
    71cc:	cf 92       	push	r12
    71ce:	df 92       	push	r13
    71d0:	ef 92       	push	r14
    71d2:	ff 92       	push	r15
    71d4:	1f 93       	push	r17
    71d6:	cf 93       	push	r28
    71d8:	df 93       	push	r29
    71da:	6c 01       	movw	r12, r24
    71dc:	7b 01       	movw	r14, r22
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {
    71de:	10 e0       	ldi	r17, 0x00	; 0
    71e0:	10 c0       	rjmp	.+32     	; 0x7202 <system_convert_array_steps_to_mpos+0x36>
    position[idx] = system_convert_axis_steps_to_mpos(steps, idx);
    71e2:	c1 2f       	mov	r28, r17
    71e4:	d0 e0       	ldi	r29, 0x00	; 0
    71e6:	cc 0f       	add	r28, r28
    71e8:	dd 1f       	adc	r29, r29
    71ea:	cc 0f       	add	r28, r28
    71ec:	dd 1f       	adc	r29, r29
    71ee:	cc 0d       	add	r28, r12
    71f0:	dd 1d       	adc	r29, r13
    71f2:	61 2f       	mov	r22, r17
    71f4:	c7 01       	movw	r24, r14
    71f6:	d0 df       	rcall	.-96     	; 0x7198 <system_convert_axis_steps_to_mpos>
    71f8:	68 83       	st	Y, r22
    71fa:	79 83       	std	Y+1, r23	; 0x01
    71fc:	8a 83       	std	Y+2, r24	; 0x02
    71fe:	9b 83       	std	Y+3, r25	; 0x03


void system_convert_array_steps_to_mpos(float *position, int32_t *steps)
{
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {
    7200:	1f 5f       	subi	r17, 0xFF	; 255
    7202:	13 30       	cpi	r17, 0x03	; 3
    7204:	70 f3       	brcs	.-36     	; 0x71e2 <system_convert_array_steps_to_mpos+0x16>
    position[idx] = system_convert_axis_steps_to_mpos(steps, idx);
  }
  return;
}
    7206:	df 91       	pop	r29
    7208:	cf 91       	pop	r28
    720a:	1f 91       	pop	r17
    720c:	ff 90       	pop	r15
    720e:	ef 90       	pop	r14
    7210:	df 90       	pop	r13
    7212:	cf 90       	pop	r12
    7214:	08 95       	ret

00007216 <system_check_travel_limits>:
#endif


// Checks and reports if target array exceeds machine travel limits.
uint8_t system_check_travel_limits(float *target)
{
    7216:	cf 92       	push	r12
    7218:	df 92       	push	r13
    721a:	ef 92       	push	r14
    721c:	ff 92       	push	r15
    721e:	1f 93       	push	r17
    7220:	cf 93       	push	r28
    7222:	df 93       	push	r29
    7224:	ec 01       	movw	r28, r24
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {
    7226:	10 e0       	ldi	r17, 0x00	; 0
    7228:	27 c0       	rjmp	.+78     	; 0x7278 <system_check_travel_limits+0x62>
      } else {
        if (target[idx] > 0 || target[idx] < settings.max_travel[idx]) { return(true); }
      }
    #else
      // NOTE: max_travel is stored as negative
      if (target[idx] > 0 || target[idx] < settings.max_travel[idx]) { return(true); }
    722a:	e1 2f       	mov	r30, r17
    722c:	f0 e0       	ldi	r31, 0x00	; 0
    722e:	ee 0f       	add	r30, r30
    7230:	ff 1f       	adc	r31, r31
    7232:	ee 0f       	add	r30, r30
    7234:	ff 1f       	adc	r31, r31
    7236:	ec 0f       	add	r30, r28
    7238:	fd 1f       	adc	r31, r29
    723a:	c0 80       	ld	r12, Z
    723c:	d1 80       	ldd	r13, Z+1	; 0x01
    723e:	e2 80       	ldd	r14, Z+2	; 0x02
    7240:	f3 80       	ldd	r15, Z+3	; 0x03
    7242:	20 e0       	ldi	r18, 0x00	; 0
    7244:	30 e0       	ldi	r19, 0x00	; 0
    7246:	a9 01       	movw	r20, r18
    7248:	c7 01       	movw	r24, r14
    724a:	b6 01       	movw	r22, r12
    724c:	ea d5       	rcall	.+3028   	; 0x7e22 <__gesf2>
    724e:	18 16       	cp	r1, r24
    7250:	bc f0       	brlt	.+46     	; 0x7280 <system_check_travel_limits+0x6a>
    7252:	e1 2f       	mov	r30, r17
    7254:	f0 e0       	ldi	r31, 0x00	; 0
    7256:	39 96       	adiw	r30, 0x09	; 9
    7258:	ee 0f       	add	r30, r30
    725a:	ff 1f       	adc	r31, r31
    725c:	ee 0f       	add	r30, r30
    725e:	ff 1f       	adc	r31, r31
    7260:	e7 54       	subi	r30, 0x47	; 71
    7262:	f1 4f       	sbci	r31, 0xF1	; 241
    7264:	20 81       	ld	r18, Z
    7266:	31 81       	ldd	r19, Z+1	; 0x01
    7268:	42 81       	ldd	r20, Z+2	; 0x02
    726a:	53 81       	ldd	r21, Z+3	; 0x03
    726c:	c7 01       	movw	r24, r14
    726e:	b6 01       	movw	r22, r12
    7270:	d5 d3       	rcall	.+1962   	; 0x7a1c <__cmpsf2>
    7272:	88 23       	and	r24, r24
    7274:	3c f0       	brlt	.+14     	; 0x7284 <system_check_travel_limits+0x6e>

// Checks and reports if target array exceeds machine travel limits.
uint8_t system_check_travel_limits(float *target)
{
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {
    7276:	1f 5f       	subi	r17, 0xFF	; 255
    7278:	13 30       	cpi	r17, 0x03	; 3
    727a:	b8 f2       	brcs	.-82     	; 0x722a <system_check_travel_limits+0x14>
    #else
      // NOTE: max_travel is stored as negative
      if (target[idx] > 0 || target[idx] < settings.max_travel[idx]) { return(true); }
    #endif
  }
  return(false);
    727c:	80 e0       	ldi	r24, 0x00	; 0
    727e:	03 c0       	rjmp	.+6      	; 0x7286 <system_check_travel_limits+0x70>
      } else {
        if (target[idx] > 0 || target[idx] < settings.max_travel[idx]) { return(true); }
      }
    #else
      // NOTE: max_travel is stored as negative
      if (target[idx] > 0 || target[idx] < settings.max_travel[idx]) { return(true); }
    7280:	81 e0       	ldi	r24, 0x01	; 1
    7282:	01 c0       	rjmp	.+2      	; 0x7286 <system_check_travel_limits+0x70>
    7284:	81 e0       	ldi	r24, 0x01	; 1
    #endif
  }
  return(false);
}
    7286:	df 91       	pop	r29
    7288:	cf 91       	pop	r28
    728a:	1f 91       	pop	r17
    728c:	ff 90       	pop	r15
    728e:	ef 90       	pop	r14
    7290:	df 90       	pop	r13
    7292:	cf 90       	pop	r12
    7294:	08 95       	ret

00007296 <system_set_exec_state_flag>:


// Special handlers for setting and clearing Grbl's real-time execution flags.
void system_set_exec_state_flag(uint8_t mask) {
  uint8_t sreg = SREG;
    7296:	9f b7       	in	r25, 0x3f	; 63
  cli();
    7298:	f8 94       	cli
  sys_rt_exec_state |= (mask);
    729a:	20 91 23 0c 	lds	r18, 0x0C23	; 0x800c23 <sys_rt_exec_state>
    729e:	82 2b       	or	r24, r18
    72a0:	80 93 23 0c 	sts	0x0C23, r24	; 0x800c23 <sys_rt_exec_state>
  SREG = sreg;
    72a4:	9f bf       	out	0x3f, r25	; 63
    72a6:	08 95       	ret

000072a8 <system_execute_line>:
// next line during a cycle, so for switches like block delete, the switch only effects
// the lines that are processed afterward, not necessarily real-time during a cycle,
// since there are motions already stored in the buffer. However, this 'lag' should not
// be an issue, since these commands are not typically used during a cycle.
uint8_t system_execute_line(char *line)
{
    72a8:	8f 92       	push	r8
    72aa:	9f 92       	push	r9
    72ac:	af 92       	push	r10
    72ae:	bf 92       	push	r11
    72b0:	cf 92       	push	r12
    72b2:	df 92       	push	r13
    72b4:	ef 92       	push	r14
    72b6:	ff 92       	push	r15
    72b8:	0f 93       	push	r16
    72ba:	1f 93       	push	r17
    72bc:	cf 93       	push	r28
    72be:	df 93       	push	r29
    72c0:	cd b7       	in	r28, 0x3d	; 61
    72c2:	de b7       	in	r29, 0x3e	; 62
    72c4:	29 97       	sbiw	r28, 0x09	; 9
    72c6:	0f b6       	in	r0, 0x3f	; 63
    72c8:	f8 94       	cli
    72ca:	de bf       	out	0x3e, r29	; 62
    72cc:	0f be       	out	0x3f, r0	; 63
    72ce:	cd bf       	out	0x3d, r28	; 61
    72d0:	8c 01       	movw	r16, r24
  uint8_t char_counter = 1;
    72d2:	81 e0       	ldi	r24, 0x01	; 1
    72d4:	89 83       	std	Y+1, r24	; 0x01
  uint8_t helper_var = 0; // Helper variable
  float parameter, value;
  switch( line[char_counter] ) {
    72d6:	f8 01       	movw	r30, r16
    72d8:	81 81       	ldd	r24, Z+1	; 0x01
    72da:	83 34       	cpi	r24, 0x43	; 67
    72dc:	19 f1       	breq	.+70     	; 0x7324 <system_execute_line+0x7c>
    72de:	30 f4       	brcc	.+12     	; 0x72ec <system_execute_line+0x44>
    72e0:	88 23       	and	r24, r24
    72e2:	61 f0       	breq	.+24     	; 0x72fc <system_execute_line+0x54>
    72e4:	84 32       	cpi	r24, 0x24	; 36
    72e6:	09 f0       	breq	.+2      	; 0x72ea <system_execute_line+0x42>
    72e8:	59 c0       	rjmp	.+178    	; 0x739c <system_execute_line+0xf4>
    72ea:	1c c0       	rjmp	.+56     	; 0x7324 <system_execute_line+0x7c>
    72ec:	8a 34       	cpi	r24, 0x4A	; 74
    72ee:	49 f0       	breq	.+18     	; 0x7302 <system_execute_line+0x5a>
    72f0:	88 35       	cpi	r24, 0x58	; 88
    72f2:	c1 f0       	breq	.+48     	; 0x7324 <system_execute_line+0x7c>
    72f4:	87 34       	cpi	r24, 0x47	; 71
    72f6:	09 f0       	breq	.+2      	; 0x72fa <system_execute_line+0x52>
    72f8:	51 c0       	rjmp	.+162    	; 0x739c <system_execute_line+0xf4>
    72fa:	14 c0       	rjmp	.+40     	; 0x7324 <system_execute_line+0x7c>
    case 0 : report_grbl_help(); break;
    72fc:	5a da       	rcall	.-2892   	; 0x67b2 <report_grbl_help>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    72fe:	f1 2c       	mov	r15, r1
{
  uint8_t char_counter = 1;
  uint8_t helper_var = 0; // Helper variable
  float parameter, value;
  switch( line[char_counter] ) {
    case 0 : report_grbl_help(); break;
    7300:	05 c2       	rjmp	.+1034   	; 0x770c <system_execute_line+0x464>
    case 'J' : // Jogging
      // Execute only if in IDLE or JOG states.
      if (sys.state != STATE_IDLE && sys.state != STATE_JOG) { return(STATUS_IDLE_ERROR); }
    7302:	80 91 11 0c 	lds	r24, 0x0C11	; 0x800c11 <sys>
    7306:	88 23       	and	r24, r24
    7308:	19 f0       	breq	.+6      	; 0x7310 <system_execute_line+0x68>
    730a:	80 32       	cpi	r24, 0x20	; 32
    730c:	09 f0       	breq	.+2      	; 0x7310 <system_execute_line+0x68>
    730e:	77 c1       	rjmp	.+750    	; 0x75fe <system_execute_line+0x356>
      if(line[2] != '=') { return(STATUS_INVALID_STATEMENT); }
    7310:	f8 01       	movw	r30, r16
    7312:	82 81       	ldd	r24, Z+2	; 0x02
    7314:	8d 33       	cpi	r24, 0x3D	; 61
    7316:	09 f0       	breq	.+2      	; 0x731a <system_execute_line+0x72>
    7318:	76 c1       	rjmp	.+748    	; 0x7606 <system_execute_line+0x35e>
      return(gc_execute_line(line)); // NOTE: $J= is ignored inside g-code parser and used to detect jog motions.
    731a:	c8 01       	movw	r24, r16
    731c:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <gc_execute_line>
    7320:	f8 2e       	mov	r15, r24
    7322:	f4 c1       	rjmp	.+1000   	; 0x770c <system_execute_line+0x464>
      break;
    case '$': case 'G': case 'C': case 'X':
      if ( line[2] != 0 ) { return(STATUS_INVALID_STATEMENT); }
    7324:	f8 01       	movw	r30, r16
    7326:	82 81       	ldd	r24, Z+2	; 0x02
    7328:	81 11       	cpse	r24, r1
    732a:	72 c1       	rjmp	.+740    	; 0x7610 <system_execute_line+0x368>
      switch( line[1] ) {
    732c:	81 81       	ldd	r24, Z+1	; 0x01
    732e:	83 34       	cpi	r24, 0x43	; 67
    7330:	a1 f0       	breq	.+40     	; 0x735a <system_execute_line+0xb2>
    7332:	18 f4       	brcc	.+6      	; 0x733a <system_execute_line+0x92>
    7334:	84 32       	cpi	r24, 0x24	; 36
    7336:	31 f0       	breq	.+12     	; 0x7344 <system_execute_line+0x9c>
    7338:	70 c1       	rjmp	.+736    	; 0x761a <system_execute_line+0x372>
    733a:	87 34       	cpi	r24, 0x47	; 71
    733c:	59 f0       	breq	.+22     	; 0x7354 <system_execute_line+0xac>
    733e:	88 35       	cpi	r24, 0x58	; 88
    7340:	f9 f0       	breq	.+62     	; 0x7380 <system_execute_line+0xd8>
    7342:	6b c1       	rjmp	.+726    	; 0x761a <system_execute_line+0x372>
        case '$' : // Prints Grbl settings
          if ( sys.state & (STATE_CYCLE | STATE_HOLD) ) { return(STATUS_IDLE_ERROR); } // Block during cycle. Takes too long to print.
    7344:	80 91 11 0c 	lds	r24, 0x0C11	; 0x800c11 <sys>
    7348:	88 71       	andi	r24, 0x18	; 24
    734a:	f8 2e       	mov	r15, r24
    734c:	09 f0       	breq	.+2      	; 0x7350 <system_execute_line+0xa8>
          else { report_grbl_settings(); }
    734e:	67 c1       	rjmp	.+718    	; 0x761e <system_execute_line+0x376>
          break;
    7350:	34 da       	rcall	.-2968   	; 0x67ba <report_grbl_settings>
        case 'G' : // Prints gcode parser state
          // TODO: Move this to realtime commands for GUIs to request this data during suspend-state.
          report_gcode_modes();
    7352:	dc c1       	rjmp	.+952    	; 0x770c <system_execute_line+0x464>
    7354:	c0 db       	rcall	.-2176   	; 0x6ad6 <report_gcode_modes>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    7356:	f1 2c       	mov	r15, r1
          else { report_grbl_settings(); }
          break;
        case 'G' : // Prints gcode parser state
          // TODO: Move this to realtime commands for GUIs to request this data during suspend-state.
          report_gcode_modes();
          break;
    7358:	d9 c1       	rjmp	.+946    	; 0x770c <system_execute_line+0x464>
        case 'C' : // Set check g-code mode [IDLE/CHECK]
          // Perform reset when toggling off. Check g-code mode should only work if Grbl
          // is idle and ready, regardless of alarm locks. This is mainly to keep things
          // simple and consistent.
          if ( sys.state == STATE_CHECK_MODE ) {
    735a:	f0 90 11 0c 	lds	r15, 0x0C11	; 0x800c11 <sys>
    735e:	f2 e0       	ldi	r31, 0x02	; 2
    7360:	ff 12       	cpse	r15, r31
    7362:	06 c0       	rjmp	.+12     	; 0x7370 <system_execute_line+0xc8>
            mc_reset();
    7364:	0e 94 ac 06 	call	0xd58	; 0xd58 <mc_reset>
            report_feedback_message(MESSAGE_DISABLED);
    7368:	85 e0       	ldi	r24, 0x05	; 5
    736a:	df d9       	rcall	.-3138   	; 0x672a <report_feedback_message>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    736c:	f1 2c       	mov	r15, r1
    736e:	ce c1       	rjmp	.+924    	; 0x770c <system_execute_line+0x464>
          // simple and consistent.
          if ( sys.state == STATE_CHECK_MODE ) {
            mc_reset();
            report_feedback_message(MESSAGE_DISABLED);
          } else {
            if (sys.state) { return(STATUS_IDLE_ERROR); } // Requires no alarm mode.
    7370:	f1 10       	cpse	r15, r1
    7372:	59 c1       	rjmp	.+690    	; 0x7626 <system_execute_line+0x37e>
            sys.state = STATE_CHECK_MODE;
    7374:	82 e0       	ldi	r24, 0x02	; 2
    7376:	80 93 11 0c 	sts	0x0C11, r24	; 0x800c11 <sys>
            report_feedback_message(MESSAGE_ENABLED);
    737a:	84 e0       	ldi	r24, 0x04	; 4
    737c:	d6 d9       	rcall	.-3156   	; 0x672a <report_feedback_message>
    737e:	c6 c1       	rjmp	.+908    	; 0x770c <system_execute_line+0x464>
          }
          break;
        case 'X' : // Disable alarm lock [ALARM]
          if (sys.state == STATE_ALARM) {
    7380:	80 91 11 0c 	lds	r24, 0x0C11	; 0x800c11 <sys>
    7384:	81 30       	cpi	r24, 0x01	; 1
    7386:	09 f0       	breq	.+2      	; 0x738a <system_execute_line+0xe2>
            // Block if safety door is ajar.
            if (system_check_safety_door_ajar()) { return(STATUS_CHECK_DOOR); }
    7388:	52 c1       	rjmp	.+676    	; 0x762e <system_execute_line+0x386>
    738a:	db de       	rcall	.-586    	; 0x7142 <system_check_safety_door_ajar>
    738c:	f8 2e       	mov	r15, r24
    738e:	81 11       	cpse	r24, r1
            report_feedback_message(MESSAGE_ALARM_UNLOCK);
    7390:	50 c1       	rjmp	.+672    	; 0x7632 <system_execute_line+0x38a>
    7392:	83 e0       	ldi	r24, 0x03	; 3
    7394:	ca d9       	rcall	.-3180   	; 0x672a <report_feedback_message>
            sys.state = STATE_IDLE;
    7396:	10 92 11 0c 	sts	0x0C11, r1	; 0x800c11 <sys>
    739a:	b8 c1       	rjmp	.+880    	; 0x770c <system_execute_line+0x464>
          break;
      }
      break;
    default :
      // Block any system command that requires the state as IDLE/ALARM. (i.e. EEPROM, homing)
      if ( !(sys.state == STATE_IDLE || sys.state == STATE_ALARM) ) { return(STATUS_IDLE_ERROR); }
    739c:	80 91 11 0c 	lds	r24, 0x0C11	; 0x800c11 <sys>
    73a0:	82 30       	cpi	r24, 0x02	; 2
    73a2:	08 f0       	brcs	.+2      	; 0x73a6 <system_execute_line+0xfe>
    73a4:	4b c1       	rjmp	.+662    	; 0x763c <system_execute_line+0x394>
      switch( line[1] ) {
    73a6:	f8 01       	movw	r30, r16
    73a8:	91 81       	ldd	r25, Z+1	; 0x01
    73aa:	99 34       	cpi	r25, 0x49	; 73
    73ac:	09 f4       	brne	.+2      	; 0x73b0 <system_execute_line+0x108>
    73ae:	46 c0       	rjmp	.+140    	; 0x743c <system_execute_line+0x194>
    73b0:	28 f4       	brcc	.+10     	; 0x73bc <system_execute_line+0x114>
    73b2:	93 32       	cpi	r25, 0x23	; 35
    73b4:	61 f0       	breq	.+24     	; 0x73ce <system_execute_line+0x126>
    73b6:	98 34       	cpi	r25, 0x48	; 72
    73b8:	89 f0       	breq	.+34     	; 0x73dc <system_execute_line+0x134>
    73ba:	b3 c0       	rjmp	.+358    	; 0x7522 <system_execute_line+0x27a>
    73bc:	92 35       	cpi	r25, 0x52	; 82
    73be:	09 f4       	brne	.+2      	; 0x73c2 <system_execute_line+0x11a>
    73c0:	66 c0       	rjmp	.+204    	; 0x748e <system_execute_line+0x1e6>
    73c2:	93 35       	cpi	r25, 0x53	; 83
    73c4:	59 f1       	breq	.+86     	; 0x741c <system_execute_line+0x174>
    73c6:	9e 34       	cpi	r25, 0x4E	; 78
    73c8:	09 f0       	breq	.+2      	; 0x73cc <system_execute_line+0x124>
    73ca:	ab c0       	rjmp	.+342    	; 0x7522 <system_execute_line+0x27a>
        case '#' : // Print Grbl NGC parameters
          if ( line[2] != 0 ) { return(STATUS_INVALID_STATEMENT); }
    73cc:	8a c0       	rjmp	.+276    	; 0x74e2 <system_execute_line+0x23a>
    73ce:	f8 01       	movw	r30, r16
    73d0:	82 81       	ldd	r24, Z+2	; 0x02
    73d2:	81 11       	cpse	r24, r1
          else { report_ngc_parameters(); }
    73d4:	37 c1       	rjmp	.+622    	; 0x7644 <system_execute_line+0x39c>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    73d6:	2b db       	rcall	.-2474   	; 0x6a2e <report_ngc_parameters>
      if ( !(sys.state == STATE_IDLE || sys.state == STATE_ALARM) ) { return(STATUS_IDLE_ERROR); }
      switch( line[1] ) {
        case '#' : // Print Grbl NGC parameters
          if ( line[2] != 0 ) { return(STATUS_INVALID_STATEMENT); }
          else { report_ngc_parameters(); }
          break;
    73d8:	f1 2c       	mov	r15, r1
        case 'H' : // Perform homing cycle [IDLE/ALARM]
          if (bit_isfalse(settings.flags,BITFLAG_HOMING_ENABLE)) {return(STATUS_SETTING_DISABLED); }
    73da:	98 c1       	rjmp	.+816    	; 0x770c <system_execute_line+0x464>
    73dc:	80 91 fe 0e 	lds	r24, 0x0EFE	; 0x800efe <settings+0x45>
    73e0:	84 ff       	sbrs	r24, 4
          if (system_check_safety_door_ajar()) { return(STATUS_CHECK_DOOR); } // Block if safety door is ajar.
    73e2:	35 c1       	rjmp	.+618    	; 0x764e <system_execute_line+0x3a6>
    73e4:	ae de       	rcall	.-676    	; 0x7142 <system_check_safety_door_ajar>
    73e6:	e8 2e       	mov	r14, r24
    73e8:	81 11       	cpse	r24, r1
    73ea:	36 c1       	rjmp	.+620    	; 0x7658 <system_execute_line+0x3b0>
          sys.state = STATE_HOMING; // Set system state variable
    73ec:	84 e0       	ldi	r24, 0x04	; 4
    73ee:	80 93 11 0c 	sts	0x0C11, r24	; 0x800c11 <sys>
          if (line[2] == 0) {
    73f2:	f8 01       	movw	r30, r16
    73f4:	82 81       	ldd	r24, Z+2	; 0x02
    73f6:	81 11       	cpse	r24, r1
    73f8:	34 c1       	rjmp	.+616    	; 0x7662 <system_execute_line+0x3ba>
            mc_homing_cycle(HOMING_CYCLE_ALL);
    73fa:	0e 94 22 06 	call	0xc44	; 0xc44 <mc_homing_cycle>
                case 'Z': mc_homing_cycle(HOMING_CYCLE_Z); break;
                default: return(STATUS_INVALID_STATEMENT);
              }
          #endif
          } else { return(STATUS_INVALID_STATEMENT); }
          if (!sys.abort) {  // Execute startup scripts after successful homing.
    73fe:	f0 90 12 0c 	lds	r15, 0x0C12	; 0x800c12 <sys+0x1>
    7402:	f1 10       	cpse	r15, r1
    7404:	33 c1       	rjmp	.+614    	; 0x766c <system_execute_line+0x3c4>
            sys.state = STATE_IDLE; // Set to IDLE when complete.
    7406:	10 92 11 0c 	sts	0x0C11, r1	; 0x800c11 <sys>
            st_go_idle(); // Set steppers to the settings idle state before returning.
    740a:	0e 94 92 18 	call	0x3124	; 0x3124 <st_go_idle>
            if (line[2] == 0) { system_execute_startup(line); }
    740e:	f8 01       	movw	r30, r16
    7410:	82 81       	ldd	r24, Z+2	; 0x02
    7412:	81 11       	cpse	r24, r1
    7414:	7b c1       	rjmp	.+758    	; 0x770c <system_execute_line+0x464>
    7416:	c8 01       	movw	r24, r16
    7418:	97 de       	rcall	.-722    	; 0x7148 <system_execute_startup>
    741a:	78 c1       	rjmp	.+752    	; 0x770c <system_execute_line+0x464>
          }
          break;
        case 'S' : // Puts Grbl to sleep [IDLE/ALARM]
          if ((line[2] != 'L') || (line[3] != 'P') || (line[4] != 0)) { return(STATUS_INVALID_STATEMENT); }
    741c:	f8 01       	movw	r30, r16
    741e:	82 81       	ldd	r24, Z+2	; 0x02
    7420:	8c 34       	cpi	r24, 0x4C	; 76
    7422:	09 f0       	breq	.+2      	; 0x7426 <system_execute_line+0x17e>
    7424:	25 c1       	rjmp	.+586    	; 0x7670 <system_execute_line+0x3c8>
    7426:	83 81       	ldd	r24, Z+3	; 0x03
    7428:	80 35       	cpi	r24, 0x50	; 80
    742a:	09 f0       	breq	.+2      	; 0x742e <system_execute_line+0x186>
    742c:	26 c1       	rjmp	.+588    	; 0x767a <system_execute_line+0x3d2>
    742e:	84 81       	ldd	r24, Z+4	; 0x04
    7430:	81 11       	cpse	r24, r1
          system_set_exec_state_flag(EXEC_SLEEP); // Set to execute sleep mode immediately
    7432:	28 c1       	rjmp	.+592    	; 0x7684 <system_execute_line+0x3dc>
    7434:	80 e8       	ldi	r24, 0x80	; 128
    7436:	2f df       	rcall	.-418    	; 0x7296 <system_set_exec_state_flag>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    7438:	f1 2c       	mov	r15, r1
        case 'S' : // Puts Grbl to sleep [IDLE/ALARM]
          if ((line[2] != 'L') || (line[3] != 'P') || (line[4] != 0)) { return(STATUS_INVALID_STATEMENT); }
          system_set_exec_state_flag(EXEC_SLEEP); // Set to execute sleep mode immediately
          break;
        case 'I' : // Print or store build info. [IDLE/ALARM]
          if ( line[++char_counter] == 0 ) {
    743a:	68 c1       	rjmp	.+720    	; 0x770c <system_execute_line+0x464>
    743c:	82 e0       	ldi	r24, 0x02	; 2
    743e:	89 83       	std	Y+1, r24	; 0x01
    7440:	f8 01       	movw	r30, r16
    7442:	82 81       	ldd	r24, Z+2	; 0x02
    7444:	81 11       	cpse	r24, r1
            settings_read_build_info(line);
    7446:	07 c0       	rjmp	.+14     	; 0x7456 <system_execute_line+0x1ae>
    7448:	c8 01       	movw	r24, r16
    744a:	0e 94 05 25 	call	0x4a0a	; 0x4a0a <settings_read_build_info>
            report_build_info(line);
    744e:	c8 01       	movw	r24, r16
    7450:	ea db       	rcall	.-2092   	; 0x6c26 <report_build_info>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    7452:	f1 2c       	mov	r15, r1
    7454:	5b c1       	rjmp	.+694    	; 0x770c <system_execute_line+0x464>
          if ( line[++char_counter] == 0 ) {
            settings_read_build_info(line);
            report_build_info(line);
          #ifdef ENABLE_BUILD_INFO_WRITE_COMMAND
            } else { // Store startup line [IDLE/ALARM]
              if(line[char_counter++] != '=') { return(STATUS_INVALID_STATEMENT); }
    7456:	83 e0       	ldi	r24, 0x03	; 3
    7458:	89 83       	std	Y+1, r24	; 0x01
    745a:	f8 01       	movw	r30, r16
    745c:	82 81       	ldd	r24, Z+2	; 0x02
    745e:	8d 33       	cpi	r24, 0x3D	; 61
    7460:	09 f0       	breq	.+2      	; 0x7464 <system_execute_line+0x1bc>
    7462:	15 c1       	rjmp	.+554    	; 0x768e <system_execute_line+0x3e6>
              helper_var = char_counter; // Set helper variable as counter to start of user info line.
              do {
                line[char_counter-helper_var] = line[char_counter];
    7464:	89 81       	ldd	r24, Y+1	; 0x01
    7466:	e8 2f       	mov	r30, r24
    7468:	f0 e0       	ldi	r31, 0x00	; 0
    746a:	df 01       	movw	r26, r30
    746c:	13 97       	sbiw	r26, 0x03	; 3
    746e:	a0 0f       	add	r26, r16
    7470:	b1 1f       	adc	r27, r17
    7472:	e0 0f       	add	r30, r16
    7474:	f1 1f       	adc	r31, r17
    7476:	90 81       	ld	r25, Z
    7478:	9c 93       	st	X, r25
              } while (line[char_counter++] != 0);
    747a:	8f 5f       	subi	r24, 0xFF	; 255
    747c:	89 83       	std	Y+1, r24	; 0x01
    747e:	80 81       	ld	r24, Z
    7480:	81 11       	cpse	r24, r1
    7482:	f0 cf       	rjmp	.-32     	; 0x7464 <system_execute_line+0x1bc>
              settings_store_build_info(line);
    7484:	c8 01       	movw	r24, r16
    7486:	0e 94 6d 24 	call	0x48da	; 0x48da <settings_store_build_info>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    748a:	f1 2c       	mov	r15, r1
    748c:	3f c1       	rjmp	.+638    	; 0x770c <system_execute_line+0x464>
              settings_store_build_info(line);
          #endif
          }
          break;
        case 'R' : // Restore defaults [IDLE/ALARM]
          if ((line[2] != 'S') || (line[3] != 'T') || (line[4] != '=') || (line[6] != 0)) { return(STATUS_INVALID_STATEMENT); }
    748e:	f8 01       	movw	r30, r16
    7490:	82 81       	ldd	r24, Z+2	; 0x02
    7492:	83 35       	cpi	r24, 0x53	; 83
    7494:	09 f0       	breq	.+2      	; 0x7498 <system_execute_line+0x1f0>
    7496:	00 c1       	rjmp	.+512    	; 0x7698 <system_execute_line+0x3f0>
    7498:	83 81       	ldd	r24, Z+3	; 0x03
    749a:	84 35       	cpi	r24, 0x54	; 84
    749c:	09 f0       	breq	.+2      	; 0x74a0 <system_execute_line+0x1f8>
    749e:	01 c1       	rjmp	.+514    	; 0x76a2 <system_execute_line+0x3fa>
    74a0:	84 81       	ldd	r24, Z+4	; 0x04
    74a2:	8d 33       	cpi	r24, 0x3D	; 61
    74a4:	09 f0       	breq	.+2      	; 0x74a8 <system_execute_line+0x200>
    74a6:	02 c1       	rjmp	.+516    	; 0x76ac <system_execute_line+0x404>
    74a8:	86 81       	ldd	r24, Z+6	; 0x06
    74aa:	81 11       	cpse	r24, r1
    74ac:	04 c1       	rjmp	.+520    	; 0x76b6 <system_execute_line+0x40e>
          switch (line[5]) {
    74ae:	85 81       	ldd	r24, Z+5	; 0x05
    74b0:	84 32       	cpi	r24, 0x24	; 36
    74b2:	31 f0       	breq	.+12     	; 0x74c0 <system_execute_line+0x218>
    74b4:	8a 32       	cpi	r24, 0x2A	; 42
    74b6:	61 f0       	breq	.+24     	; 0x74d0 <system_execute_line+0x228>
    74b8:	83 32       	cpi	r24, 0x23	; 35
    74ba:	09 f0       	breq	.+2      	; 0x74be <system_execute_line+0x216>
    74bc:	01 c1       	rjmp	.+514    	; 0x76c0 <system_execute_line+0x418>
    74be:	04 c0       	rjmp	.+8      	; 0x74c8 <system_execute_line+0x220>
            #ifdef ENABLE_RESTORE_EEPROM_DEFAULT_SETTINGS
              case '$': settings_restore(SETTINGS_RESTORE_DEFAULTS); break;
    74c0:	81 e0       	ldi	r24, 0x01	; 1
    74c2:	0e 94 94 24 	call	0x4928	; 0x4928 <settings_restore>
            #endif
            #ifdef ENABLE_RESTORE_EEPROM_CLEAR_PARAMETERS
              case '#': settings_restore(SETTINGS_RESTORE_PARAMETERS); break;
    74c6:	07 c0       	rjmp	.+14     	; 0x74d6 <system_execute_line+0x22e>
    74c8:	82 e0       	ldi	r24, 0x02	; 2
    74ca:	0e 94 94 24 	call	0x4928	; 0x4928 <settings_restore>
            #endif
            #ifdef ENABLE_RESTORE_EEPROM_WIPE_ALL
              case '*': settings_restore(SETTINGS_RESTORE_ALL); break;
    74ce:	03 c0       	rjmp	.+6      	; 0x74d6 <system_execute_line+0x22e>
    74d0:	8f ef       	ldi	r24, 0xFF	; 255
    74d2:	0e 94 94 24 	call	0x4928	; 0x4928 <settings_restore>
            #endif
            default: return(STATUS_INVALID_STATEMENT);
          }
          report_feedback_message(MESSAGE_RESTORE_DEFAULTS);
    74d6:	89 e0       	ldi	r24, 0x09	; 9
    74d8:	28 d9       	rcall	.-3504   	; 0x672a <report_feedback_message>
          mc_reset(); // Force reset to ensure settings are initialized correctly.
    74da:	0e 94 ac 06 	call	0xd58	; 0xd58 <mc_reset>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    74de:	f1 2c       	mov	r15, r1
            #endif
            default: return(STATUS_INVALID_STATEMENT);
          }
          report_feedback_message(MESSAGE_RESTORE_DEFAULTS);
          mc_reset(); // Force reset to ensure settings are initialized correctly.
          break;
    74e0:	15 c1       	rjmp	.+554    	; 0x770c <system_execute_line+0x464>
        case 'N' : // Startup lines. [IDLE/ALARM]
          if ( line[++char_counter] == 0 ) { // Print startup lines
    74e2:	92 e0       	ldi	r25, 0x02	; 2
    74e4:	99 83       	std	Y+1, r25	; 0x01
    74e6:	f8 01       	movw	r30, r16
    74e8:	92 81       	ldd	r25, Z+2	; 0x02
    74ea:	99 23       	and	r25, r25
    74ec:	79 f0       	breq	.+30     	; 0x750c <system_execute_line+0x264>
            for (helper_var=0; helper_var < N_STARTUP_LINE; helper_var++) {
              if (!(settings_read_startup_line(helper_var, line))) {
    74ee:	14 c0       	rjmp	.+40     	; 0x7518 <system_execute_line+0x270>
    74f0:	b8 01       	movw	r22, r16
    74f2:	8f 2d       	mov	r24, r15
    74f4:	0e 94 e7 24 	call	0x49ce	; 0x49ce <settings_read_startup_line>
                report_status_message(STATUS_SETTING_READ_FAIL);
    74f8:	81 11       	cpse	r24, r1
    74fa:	03 c0       	rjmp	.+6      	; 0x7502 <system_execute_line+0x25a>
    74fc:	87 e0       	ldi	r24, 0x07	; 7
    74fe:	f8 d8       	rcall	.-3600   	; 0x66f0 <report_status_message>
              } else {
                report_startup_line(helper_var,line);
    7500:	03 c0       	rjmp	.+6      	; 0x7508 <system_execute_line+0x260>
    7502:	b8 01       	movw	r22, r16
    7504:	8f 2d       	mov	r24, r15
    7506:	68 db       	rcall	.-2352   	; 0x6bd8 <report_startup_line>
          report_feedback_message(MESSAGE_RESTORE_DEFAULTS);
          mc_reset(); // Force reset to ensure settings are initialized correctly.
          break;
        case 'N' : // Startup lines. [IDLE/ALARM]
          if ( line[++char_counter] == 0 ) { // Print startup lines
            for (helper_var=0; helper_var < N_STARTUP_LINE; helper_var++) {
    7508:	f3 94       	inc	r15
    750a:	01 c0       	rjmp	.+2      	; 0x750e <system_execute_line+0x266>
    750c:	f1 2c       	mov	r15, r1
    750e:	f1 e0       	ldi	r31, 0x01	; 1
    7510:	ff 15       	cp	r31, r15
    7512:	70 f7       	brcc	.-36     	; 0x74f0 <system_execute_line+0x248>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    7514:	f1 2c       	mov	r15, r1
    7516:	fa c0       	rjmp	.+500    	; 0x770c <system_execute_line+0x464>
                report_startup_line(helper_var,line);
              }
            }
            break;
          } else { // Store startup line [IDLE Only] Prevents motion during ALARM.
            if (sys.state != STATE_IDLE) { return(STATUS_IDLE_ERROR); } // Store only when idle.
    7518:	81 11       	cpse	r24, r1
    751a:	d7 c0       	rjmp	.+430    	; 0x76ca <system_execute_line+0x422>
            helper_var = true;  // Set helper_var to flag storing method.
    751c:	ff 24       	eor	r15, r15
    751e:	f3 94       	inc	r15
    7520:	01 c0       	rjmp	.+2      	; 0x7524 <system_execute_line+0x27c>
// since there are motions already stored in the buffer. However, this 'lag' should not
// be an issue, since these commands are not typically used during a cycle.
uint8_t system_execute_line(char *line)
{
  uint8_t char_counter = 1;
  uint8_t helper_var = 0; // Helper variable
    7522:	f1 2c       	mov	r15, r1
            if (sys.state != STATE_IDLE) { return(STATUS_IDLE_ERROR); } // Store only when idle.
            helper_var = true;  // Set helper_var to flag storing method.
            // No break. Continues into default: to read remaining command characters.
          }
        default :  // Storing setting methods [IDLE/ALARM]
          if(!read_float(line, &char_counter, &parameter)) { return(STATUS_BAD_NUMBER_FORMAT); }
    7524:	ae 01       	movw	r20, r28
    7526:	4e 5f       	subi	r20, 0xFE	; 254
    7528:	5f 4f       	sbci	r21, 0xFF	; 255
    752a:	be 01       	movw	r22, r28
    752c:	6f 5f       	subi	r22, 0xFF	; 255
    752e:	7f 4f       	sbci	r23, 0xFF	; 255
    7530:	c8 01       	movw	r24, r16
    7532:	0e 94 9d 2c 	call	0x593a	; 0x593a <read_float>
    7536:	88 23       	and	r24, r24
    7538:	09 f4       	brne	.+2      	; 0x753c <system_execute_line+0x294>
    753a:	cb c0       	rjmp	.+406    	; 0x76d2 <system_execute_line+0x42a>
          if(line[char_counter++] != '=') { return(STATUS_INVALID_STATEMENT); }
    753c:	89 81       	ldd	r24, Y+1	; 0x01
    753e:	91 e0       	ldi	r25, 0x01	; 1
    7540:	98 0f       	add	r25, r24
    7542:	99 83       	std	Y+1, r25	; 0x01
    7544:	f8 01       	movw	r30, r16
    7546:	e8 0f       	add	r30, r24
    7548:	f1 1d       	adc	r31, r1
    754a:	80 81       	ld	r24, Z
    754c:	8d 33       	cpi	r24, 0x3D	; 61
    754e:	09 f0       	breq	.+2      	; 0x7552 <system_execute_line+0x2aa>
    7550:	c4 c0       	rjmp	.+392    	; 0x76da <system_execute_line+0x432>
          if (helper_var) { // Store startup line
    7552:	ff 20       	and	r15, r15
    7554:	29 f1       	breq	.+74     	; 0x75a0 <system_execute_line+0x2f8>
            // Prepare sending gcode block to gcode parser by shifting all characters
            helper_var = char_counter; // Set helper variable as counter to start of gcode block
            do {
              line[char_counter-helper_var] = line[char_counter];
    7556:	89 81       	ldd	r24, Y+1	; 0x01
    7558:	e8 2f       	mov	r30, r24
    755a:	f0 e0       	ldi	r31, 0x00	; 0
    755c:	df 01       	movw	r26, r30
    755e:	a9 1b       	sub	r26, r25
    7560:	b1 09       	sbc	r27, r1
    7562:	a0 0f       	add	r26, r16
    7564:	b1 1f       	adc	r27, r17
    7566:	e0 0f       	add	r30, r16
    7568:	f1 1f       	adc	r31, r17
    756a:	20 81       	ld	r18, Z
    756c:	2c 93       	st	X, r18
            } while (line[char_counter++] != 0);
    756e:	8f 5f       	subi	r24, 0xFF	; 255
    7570:	89 83       	std	Y+1, r24	; 0x01
    7572:	20 81       	ld	r18, Z
    7574:	21 11       	cpse	r18, r1
            if (char_counter > EEPROM_LINE_SIZE) { return(STATUS_LINE_LENGTH_EXCEEDED); }
    7576:	ef cf       	rjmp	.-34     	; 0x7556 <system_execute_line+0x2ae>
    7578:	81 35       	cpi	r24, 0x51	; 81
            // Execute gcode block to ensure block is valid.
            helper_var = gc_execute_line(line); // Set helper_var to returned status code.
    757a:	08 f0       	brcs	.+2      	; 0x757e <system_execute_line+0x2d6>
    757c:	b3 c0       	rjmp	.+358    	; 0x76e4 <system_execute_line+0x43c>
    757e:	c8 01       	movw	r24, r16
            if (helper_var) { return(helper_var); }
    7580:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <gc_execute_line>
            else {
              helper_var = trunc(parameter); // Set helper_var to int value of parameter
    7584:	81 11       	cpse	r24, r1
    7586:	b3 c0       	rjmp	.+358    	; 0x76ee <system_execute_line+0x446>
    7588:	6a 81       	ldd	r22, Y+2	; 0x02
    758a:	7b 81       	ldd	r23, Y+3	; 0x03
    758c:	8c 81       	ldd	r24, Y+4	; 0x04
    758e:	9d 81       	ldd	r25, Y+5	; 0x05
    7590:	51 d5       	rcall	.+2722   	; 0x8034 <trunc>
    7592:	b8 d2       	rcall	.+1392   	; 0x7b04 <__fixunssfsi>
    7594:	86 2f       	mov	r24, r22
              settings_store_startup_line(helper_var,line);
    7596:	b8 01       	movw	r22, r16
    7598:	0e 94 56 24 	call	0x48ac	; 0x48ac <settings_store_startup_line>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    759c:	f1 2c       	mov	r15, r1
    759e:	b6 c0       	rjmp	.+364    	; 0x770c <system_execute_line+0x464>
            else {
              helper_var = trunc(parameter); // Set helper_var to int value of parameter
              settings_store_startup_line(helper_var,line);
            }
          } else { // Store global setting.
            if(!read_float(line, &char_counter, &value)) { return(STATUS_BAD_NUMBER_FORMAT); }
    75a0:	ae 01       	movw	r20, r28
    75a2:	4a 5f       	subi	r20, 0xFA	; 250
    75a4:	5f 4f       	sbci	r21, 0xFF	; 255
    75a6:	be 01       	movw	r22, r28
    75a8:	6f 5f       	subi	r22, 0xFF	; 255
    75aa:	7f 4f       	sbci	r23, 0xFF	; 255
    75ac:	c8 01       	movw	r24, r16
    75ae:	0e 94 9d 2c 	call	0x593a	; 0x593a <read_float>
    75b2:	88 23       	and	r24, r24
    75b4:	09 f4       	brne	.+2      	; 0x75b8 <system_execute_line+0x310>
    75b6:	9d c0       	rjmp	.+314    	; 0x76f2 <system_execute_line+0x44a>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
    75b8:	89 81       	ldd	r24, Y+1	; 0x01
    75ba:	f8 01       	movw	r30, r16
    75bc:	e8 0f       	add	r30, r24
    75be:	f1 1d       	adc	r31, r1
    75c0:	80 81       	ld	r24, Z
    75c2:	81 11       	cpse	r24, r1
    75c4:	9a c0       	rjmp	.+308    	; 0x76fa <system_execute_line+0x452>
    75c6:	ca 80       	ldd	r12, Y+2	; 0x02
    75c8:	db 80       	ldd	r13, Y+3	; 0x03
    75ca:	ec 80       	ldd	r14, Y+4	; 0x04
    75cc:	fd 80       	ldd	r15, Y+5	; 0x05
    75ce:	20 e0       	ldi	r18, 0x00	; 0
    75d0:	30 e0       	ldi	r19, 0x00	; 0
    75d2:	4f e7       	ldi	r20, 0x7F	; 127
    75d4:	53 e4       	ldi	r21, 0x43	; 67
    75d6:	c7 01       	movw	r24, r14
    75d8:	b6 01       	movw	r22, r12
    75da:	23 d4       	rcall	.+2118   	; 0x7e22 <__gesf2>
    75dc:	18 16       	cp	r1, r24
    75de:	0c f4       	brge	.+2      	; 0x75e2 <system_execute_line+0x33a>
            return(settings_store_global_setting((uint8_t)parameter, value));
    75e0:	91 c0       	rjmp	.+290    	; 0x7704 <system_execute_line+0x45c>
    75e2:	8e 80       	ldd	r8, Y+6	; 0x06
    75e4:	9f 80       	ldd	r9, Y+7	; 0x07
    75e6:	a8 84       	ldd	r10, Y+8	; 0x08
    75e8:	b9 84       	ldd	r11, Y+9	; 0x09
    75ea:	c7 01       	movw	r24, r14
    75ec:	b6 01       	movw	r22, r12
    75ee:	8a d2       	rcall	.+1300   	; 0x7b04 <__fixunssfsi>
    75f0:	86 2f       	mov	r24, r22
    75f2:	b5 01       	movw	r22, r10
    75f4:	a4 01       	movw	r20, r8
    75f6:	0e 94 4b 25 	call	0x4a96	; 0x4a96 <settings_store_global_setting>
    75fa:	f8 2e       	mov	r15, r24
    75fc:	87 c0       	rjmp	.+270    	; 0x770c <system_execute_line+0x464>
  float parameter, value;
  switch( line[char_counter] ) {
    case 0 : report_grbl_help(); break;
    case 'J' : // Jogging
      // Execute only if in IDLE or JOG states.
      if (sys.state != STATE_IDLE && sys.state != STATE_JOG) { return(STATUS_IDLE_ERROR); }
    75fe:	68 94       	set
    7600:	ff 24       	eor	r15, r15
    7602:	f3 f8       	bld	r15, 3
    7604:	83 c0       	rjmp	.+262    	; 0x770c <system_execute_line+0x464>
      if(line[2] != '=') { return(STATUS_INVALID_STATEMENT); }
    7606:	0f 2e       	mov	r0, r31
    7608:	f3 e0       	ldi	r31, 0x03	; 3
    760a:	ff 2e       	mov	r15, r31
    760c:	f0 2d       	mov	r31, r0
    760e:	7e c0       	rjmp	.+252    	; 0x770c <system_execute_line+0x464>
      return(gc_execute_line(line)); // NOTE: $J= is ignored inside g-code parser and used to detect jog motions.
      break;
    case '$': case 'G': case 'C': case 'X':
      if ( line[2] != 0 ) { return(STATUS_INVALID_STATEMENT); }
    7610:	0f 2e       	mov	r0, r31
    7612:	f3 e0       	ldi	r31, 0x03	; 3
    7614:	ff 2e       	mov	r15, r31
    7616:	f0 2d       	mov	r31, r0
    7618:	79 c0       	rjmp	.+242    	; 0x770c <system_execute_line+0x464>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    761a:	f1 2c       	mov	r15, r1
    761c:	77 c0       	rjmp	.+238    	; 0x770c <system_execute_line+0x464>
      break;
    case '$': case 'G': case 'C': case 'X':
      if ( line[2] != 0 ) { return(STATUS_INVALID_STATEMENT); }
      switch( line[1] ) {
        case '$' : // Prints Grbl settings
          if ( sys.state & (STATE_CYCLE | STATE_HOLD) ) { return(STATUS_IDLE_ERROR); } // Block during cycle. Takes too long to print.
    761e:	68 94       	set
    7620:	ff 24       	eor	r15, r15
    7622:	f3 f8       	bld	r15, 3
    7624:	73 c0       	rjmp	.+230    	; 0x770c <system_execute_line+0x464>
          // simple and consistent.
          if ( sys.state == STATE_CHECK_MODE ) {
            mc_reset();
            report_feedback_message(MESSAGE_DISABLED);
          } else {
            if (sys.state) { return(STATUS_IDLE_ERROR); } // Requires no alarm mode.
    7626:	68 94       	set
    7628:	ff 24       	eor	r15, r15
    762a:	f3 f8       	bld	r15, 3
    762c:	6f c0       	rjmp	.+222    	; 0x770c <system_execute_line+0x464>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    762e:	f1 2c       	mov	r15, r1
    7630:	6d c0       	rjmp	.+218    	; 0x770c <system_execute_line+0x464>
          }
          break;
        case 'X' : // Disable alarm lock [ALARM]
          if (sys.state == STATE_ALARM) {
            // Block if safety door is ajar.
            if (system_check_safety_door_ajar()) { return(STATUS_CHECK_DOOR); }
    7632:	0f 2e       	mov	r0, r31
    7634:	fd e0       	ldi	r31, 0x0D	; 13
    7636:	ff 2e       	mov	r15, r31
    7638:	f0 2d       	mov	r31, r0
    763a:	68 c0       	rjmp	.+208    	; 0x770c <system_execute_line+0x464>
          break;
      }
      break;
    default :
      // Block any system command that requires the state as IDLE/ALARM. (i.e. EEPROM, homing)
      if ( !(sys.state == STATE_IDLE || sys.state == STATE_ALARM) ) { return(STATUS_IDLE_ERROR); }
    763c:	68 94       	set
    763e:	ff 24       	eor	r15, r15
    7640:	f3 f8       	bld	r15, 3
    7642:	64 c0       	rjmp	.+200    	; 0x770c <system_execute_line+0x464>
      switch( line[1] ) {
        case '#' : // Print Grbl NGC parameters
          if ( line[2] != 0 ) { return(STATUS_INVALID_STATEMENT); }
    7644:	0f 2e       	mov	r0, r31
    7646:	f3 e0       	ldi	r31, 0x03	; 3
    7648:	ff 2e       	mov	r15, r31
    764a:	f0 2d       	mov	r31, r0
    764c:	5f c0       	rjmp	.+190    	; 0x770c <system_execute_line+0x464>
          else { report_ngc_parameters(); }
          break;
        case 'H' : // Perform homing cycle [IDLE/ALARM]
          if (bit_isfalse(settings.flags,BITFLAG_HOMING_ENABLE)) {return(STATUS_SETTING_DISABLED); }
    764e:	0f 2e       	mov	r0, r31
    7650:	f5 e0       	ldi	r31, 0x05	; 5
    7652:	ff 2e       	mov	r15, r31
    7654:	f0 2d       	mov	r31, r0
    7656:	5a c0       	rjmp	.+180    	; 0x770c <system_execute_line+0x464>
          if (system_check_safety_door_ajar()) { return(STATUS_CHECK_DOOR); } // Block if safety door is ajar.
    7658:	0f 2e       	mov	r0, r31
    765a:	fd e0       	ldi	r31, 0x0D	; 13
    765c:	ff 2e       	mov	r15, r31
    765e:	f0 2d       	mov	r31, r0
    7660:	55 c0       	rjmp	.+170    	; 0x770c <system_execute_line+0x464>
                case 'Y': mc_homing_cycle(HOMING_CYCLE_Y); break;
                case 'Z': mc_homing_cycle(HOMING_CYCLE_Z); break;
                default: return(STATUS_INVALID_STATEMENT);
              }
          #endif
          } else { return(STATUS_INVALID_STATEMENT); }
    7662:	0f 2e       	mov	r0, r31
    7664:	f3 e0       	ldi	r31, 0x03	; 3
    7666:	ff 2e       	mov	r15, r31
    7668:	f0 2d       	mov	r31, r0
    766a:	50 c0       	rjmp	.+160    	; 0x770c <system_execute_line+0x464>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    766c:	fe 2c       	mov	r15, r14
    766e:	4e c0       	rjmp	.+156    	; 0x770c <system_execute_line+0x464>
            st_go_idle(); // Set steppers to the settings idle state before returning.
            if (line[2] == 0) { system_execute_startup(line); }
          }
          break;
        case 'S' : // Puts Grbl to sleep [IDLE/ALARM]
          if ((line[2] != 'L') || (line[3] != 'P') || (line[4] != 0)) { return(STATUS_INVALID_STATEMENT); }
    7670:	0f 2e       	mov	r0, r31
    7672:	f3 e0       	ldi	r31, 0x03	; 3
    7674:	ff 2e       	mov	r15, r31
    7676:	f0 2d       	mov	r31, r0
    7678:	49 c0       	rjmp	.+146    	; 0x770c <system_execute_line+0x464>
    767a:	0f 2e       	mov	r0, r31
    767c:	f3 e0       	ldi	r31, 0x03	; 3
    767e:	ff 2e       	mov	r15, r31
    7680:	f0 2d       	mov	r31, r0
    7682:	44 c0       	rjmp	.+136    	; 0x770c <system_execute_line+0x464>
    7684:	0f 2e       	mov	r0, r31
    7686:	f3 e0       	ldi	r31, 0x03	; 3
    7688:	ff 2e       	mov	r15, r31
    768a:	f0 2d       	mov	r31, r0
    768c:	3f c0       	rjmp	.+126    	; 0x770c <system_execute_line+0x464>
          if ( line[++char_counter] == 0 ) {
            settings_read_build_info(line);
            report_build_info(line);
          #ifdef ENABLE_BUILD_INFO_WRITE_COMMAND
            } else { // Store startup line [IDLE/ALARM]
              if(line[char_counter++] != '=') { return(STATUS_INVALID_STATEMENT); }
    768e:	0f 2e       	mov	r0, r31
    7690:	f3 e0       	ldi	r31, 0x03	; 3
    7692:	ff 2e       	mov	r15, r31
    7694:	f0 2d       	mov	r31, r0
    7696:	3a c0       	rjmp	.+116    	; 0x770c <system_execute_line+0x464>
              settings_store_build_info(line);
          #endif
          }
          break;
        case 'R' : // Restore defaults [IDLE/ALARM]
          if ((line[2] != 'S') || (line[3] != 'T') || (line[4] != '=') || (line[6] != 0)) { return(STATUS_INVALID_STATEMENT); }
    7698:	0f 2e       	mov	r0, r31
    769a:	f3 e0       	ldi	r31, 0x03	; 3
    769c:	ff 2e       	mov	r15, r31
    769e:	f0 2d       	mov	r31, r0
    76a0:	35 c0       	rjmp	.+106    	; 0x770c <system_execute_line+0x464>
    76a2:	0f 2e       	mov	r0, r31
    76a4:	f3 e0       	ldi	r31, 0x03	; 3
    76a6:	ff 2e       	mov	r15, r31
    76a8:	f0 2d       	mov	r31, r0
    76aa:	30 c0       	rjmp	.+96     	; 0x770c <system_execute_line+0x464>
    76ac:	0f 2e       	mov	r0, r31
    76ae:	f3 e0       	ldi	r31, 0x03	; 3
    76b0:	ff 2e       	mov	r15, r31
    76b2:	f0 2d       	mov	r31, r0
    76b4:	2b c0       	rjmp	.+86     	; 0x770c <system_execute_line+0x464>
    76b6:	0f 2e       	mov	r0, r31
    76b8:	f3 e0       	ldi	r31, 0x03	; 3
    76ba:	ff 2e       	mov	r15, r31
    76bc:	f0 2d       	mov	r31, r0
    76be:	26 c0       	rjmp	.+76     	; 0x770c <system_execute_line+0x464>
              case '#': settings_restore(SETTINGS_RESTORE_PARAMETERS); break;
            #endif
            #ifdef ENABLE_RESTORE_EEPROM_WIPE_ALL
              case '*': settings_restore(SETTINGS_RESTORE_ALL); break;
            #endif
            default: return(STATUS_INVALID_STATEMENT);
    76c0:	0f 2e       	mov	r0, r31
    76c2:	f3 e0       	ldi	r31, 0x03	; 3
    76c4:	ff 2e       	mov	r15, r31
    76c6:	f0 2d       	mov	r31, r0
    76c8:	21 c0       	rjmp	.+66     	; 0x770c <system_execute_line+0x464>
                report_startup_line(helper_var,line);
              }
            }
            break;
          } else { // Store startup line [IDLE Only] Prevents motion during ALARM.
            if (sys.state != STATE_IDLE) { return(STATUS_IDLE_ERROR); } // Store only when idle.
    76ca:	68 94       	set
    76cc:	ff 24       	eor	r15, r15
    76ce:	f3 f8       	bld	r15, 3
    76d0:	1d c0       	rjmp	.+58     	; 0x770c <system_execute_line+0x464>
            helper_var = true;  // Set helper_var to flag storing method.
            // No break. Continues into default: to read remaining command characters.
          }
        default :  // Storing setting methods [IDLE/ALARM]
          if(!read_float(line, &char_counter, &parameter)) { return(STATUS_BAD_NUMBER_FORMAT); }
    76d2:	68 94       	set
    76d4:	ff 24       	eor	r15, r15
    76d6:	f1 f8       	bld	r15, 1
    76d8:	19 c0       	rjmp	.+50     	; 0x770c <system_execute_line+0x464>
          if(line[char_counter++] != '=') { return(STATUS_INVALID_STATEMENT); }
    76da:	0f 2e       	mov	r0, r31
    76dc:	f3 e0       	ldi	r31, 0x03	; 3
    76de:	ff 2e       	mov	r15, r31
    76e0:	f0 2d       	mov	r31, r0
    76e2:	14 c0       	rjmp	.+40     	; 0x770c <system_execute_line+0x464>
            // Prepare sending gcode block to gcode parser by shifting all characters
            helper_var = char_counter; // Set helper variable as counter to start of gcode block
            do {
              line[char_counter-helper_var] = line[char_counter];
            } while (line[char_counter++] != 0);
            if (char_counter > EEPROM_LINE_SIZE) { return(STATUS_LINE_LENGTH_EXCEEDED); }
    76e4:	0f 2e       	mov	r0, r31
    76e6:	fe e0       	ldi	r31, 0x0E	; 14
    76e8:	ff 2e       	mov	r15, r31
    76ea:	f0 2d       	mov	r31, r0
    76ec:	0f c0       	rjmp	.+30     	; 0x770c <system_execute_line+0x464>
            // Execute gcode block to ensure block is valid.
            helper_var = gc_execute_line(line); // Set helper_var to returned status code.
            if (helper_var) { return(helper_var); }
    76ee:	f8 2e       	mov	r15, r24
    76f0:	0d c0       	rjmp	.+26     	; 0x770c <system_execute_line+0x464>
            else {
              helper_var = trunc(parameter); // Set helper_var to int value of parameter
              settings_store_startup_line(helper_var,line);
            }
          } else { // Store global setting.
            if(!read_float(line, &char_counter, &value)) { return(STATUS_BAD_NUMBER_FORMAT); }
    76f2:	68 94       	set
    76f4:	ff 24       	eor	r15, r15
    76f6:	f1 f8       	bld	r15, 1
    76f8:	09 c0       	rjmp	.+18     	; 0x770c <system_execute_line+0x464>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
    76fa:	0f 2e       	mov	r0, r31
    76fc:	f3 e0       	ldi	r31, 0x03	; 3
    76fe:	ff 2e       	mov	r15, r31
    7700:	f0 2d       	mov	r31, r0
    7702:	04 c0       	rjmp	.+8      	; 0x770c <system_execute_line+0x464>
    7704:	0f 2e       	mov	r0, r31
    7706:	f3 e0       	ldi	r31, 0x03	; 3
    7708:	ff 2e       	mov	r15, r31
    770a:	f0 2d       	mov	r31, r0
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
}
    770c:	8f 2d       	mov	r24, r15
    770e:	29 96       	adiw	r28, 0x09	; 9
    7710:	0f b6       	in	r0, 0x3f	; 63
    7712:	f8 94       	cli
    7714:	de bf       	out	0x3e, r29	; 62
    7716:	0f be       	out	0x3f, r0	; 63
    7718:	cd bf       	out	0x3d, r28	; 61
    771a:	df 91       	pop	r29
    771c:	cf 91       	pop	r28
    771e:	1f 91       	pop	r17
    7720:	0f 91       	pop	r16
    7722:	ff 90       	pop	r15
    7724:	ef 90       	pop	r14
    7726:	df 90       	pop	r13
    7728:	cf 90       	pop	r12
    772a:	bf 90       	pop	r11
    772c:	af 90       	pop	r10
    772e:	9f 90       	pop	r9
    7730:	8f 90       	pop	r8
    7732:	08 95       	ret

00007734 <system_clear_exec_state_flag>:
  sys_rt_exec_state |= (mask);
  SREG = sreg;
}

void system_clear_exec_state_flag(uint8_t mask) {
  uint8_t sreg = SREG;
    7734:	2f b7       	in	r18, 0x3f	; 63
  cli();
    7736:	f8 94       	cli
  sys_rt_exec_state &= ~(mask);
    7738:	90 91 23 0c 	lds	r25, 0x0C23	; 0x800c23 <sys_rt_exec_state>
    773c:	80 95       	com	r24
    773e:	89 23       	and	r24, r25
    7740:	80 93 23 0c 	sts	0x0C23, r24	; 0x800c23 <sys_rt_exec_state>
  SREG = sreg;
    7744:	2f bf       	out	0x3f, r18	; 63
    7746:	08 95       	ret

00007748 <system_set_exec_alarm>:
}

void system_set_exec_alarm(uint8_t code) {
  uint8_t sreg = SREG;
    7748:	9f b7       	in	r25, 0x3f	; 63
  cli();
    774a:	f8 94       	cli
  sys_rt_exec_alarm = code;
    774c:	80 93 3d 0c 	sts	0x0C3D, r24	; 0x800c3d <sys_rt_exec_alarm>
  SREG = sreg;
    7750:	9f bf       	out	0x3f, r25	; 63
    7752:	08 95       	ret

00007754 <system_clear_exec_alarm>:
}

void system_clear_exec_alarm() {
  uint8_t sreg = SREG;
    7754:	8f b7       	in	r24, 0x3f	; 63
  cli();
    7756:	f8 94       	cli
  sys_rt_exec_alarm = 0;
    7758:	10 92 3d 0c 	sts	0x0C3D, r1	; 0x800c3d <sys_rt_exec_alarm>
  SREG = sreg;
    775c:	8f bf       	out	0x3f, r24	; 63
    775e:	08 95       	ret

00007760 <system_set_exec_motion_override_flag>:
}

void system_set_exec_motion_override_flag(uint8_t mask) {
  uint8_t sreg = SREG;
    7760:	9f b7       	in	r25, 0x3f	; 63
  cli();
    7762:	f8 94       	cli
  sys_rt_exec_motion_override |= (mask);
    7764:	20 91 10 0c 	lds	r18, 0x0C10	; 0x800c10 <sys_rt_exec_motion_override>
    7768:	82 2b       	or	r24, r18
    776a:	80 93 10 0c 	sts	0x0C10, r24	; 0x800c10 <sys_rt_exec_motion_override>
  SREG = sreg;
    776e:	9f bf       	out	0x3f, r25	; 63
    7770:	08 95       	ret

00007772 <system_set_exec_accessory_override_flag>:
}

void system_set_exec_accessory_override_flag(uint8_t mask) {
  uint8_t sreg = SREG;
    7772:	9f b7       	in	r25, 0x3f	; 63
  cli();
    7774:	f8 94       	cli
  sys_rt_exec_accessory_override |= (mask);
    7776:	20 91 22 0c 	lds	r18, 0x0C22	; 0x800c22 <sys_rt_exec_accessory_override>
    777a:	82 2b       	or	r24, r18
    777c:	80 93 22 0c 	sts	0x0C22, r24	; 0x800c22 <sys_rt_exec_accessory_override>
  SREG = sreg;
    7780:	9f bf       	out	0x3f, r25	; 63
    7782:	08 95       	ret

00007784 <system_clear_exec_motion_overrides>:
}

void system_clear_exec_motion_overrides() {
  uint8_t sreg = SREG;
    7784:	8f b7       	in	r24, 0x3f	; 63
  cli();
    7786:	f8 94       	cli
  sys_rt_exec_motion_override = 0;
    7788:	10 92 10 0c 	sts	0x0C10, r1	; 0x800c10 <sys_rt_exec_motion_override>
  SREG = sreg;
    778c:	8f bf       	out	0x3f, r24	; 63
    778e:	08 95       	ret

00007790 <system_clear_exec_accessory_overrides>:
}

void system_clear_exec_accessory_overrides() {
  uint8_t sreg = SREG;
    7790:	8f b7       	in	r24, 0x3f	; 63
  cli();
    7792:	f8 94       	cli
  sys_rt_exec_accessory_override = 0;
    7794:	10 92 22 0c 	sts	0x0C22, r1	; 0x800c22 <sys_rt_exec_accessory_override>
  SREG = sreg;
    7798:	8f bf       	out	0x3f, r24	; 63
    779a:	08 95       	ret

0000779c <sleep_disable>:
  // If reached, sleep counter has expired. Execute sleep procedures.
  // Notify user that Grbl has timed out and will be parking. 
  // To exit sleep, resume or reset. Either way, the job will not be recoverable. 
  report_feedback_message(MESSAGE_SLEEP_MODE);
  system_set_exec_state_flag(EXEC_SLEEP);
}
    779c:	e1 e7       	ldi	r30, 0x71	; 113
    779e:	f0 e0       	ldi	r31, 0x00	; 0
    77a0:	80 81       	ld	r24, Z
    77a2:	8e 7f       	andi	r24, 0xFE	; 254
    77a4:	80 83       	st	Z, r24
    77a6:	08 95       	ret

000077a8 <sleep_init>:
// Initialization routine for sleep timer.
void sleep_init()
{
  // Configure Timer 3: Sleep Counter Overflow Interrupt
  // NOTE: By using an overflow interrupt, the timer is automatically reloaded upon overflow.
  TCCR3B = 0; // Normal operation. Overflow.
    77a8:	e1 e9       	ldi	r30, 0x91	; 145
    77aa:	f0 e0       	ldi	r31, 0x00	; 0
    77ac:	10 82       	st	Z, r1
  TCCR3A = 0;
    77ae:	10 92 90 00 	sts	0x0090, r1	; 0x800090 <__TEXT_REGION_LENGTH__+0x7c0090>
  TCCR3B = (TCCR3B & ~((1<<CS32) | (1<<CS31))) | (1<<CS30); // Stop timer
    77b2:	80 81       	ld	r24, Z
    77b4:	88 7f       	andi	r24, 0xF8	; 248
    77b6:	81 60       	ori	r24, 0x01	; 1
    77b8:	80 83       	st	Z, r24
  // TCCR3B |= (1<<CS32); // Enable timer with 1/256 prescaler. ~4.4min max with uint8 and 1.05sec/tick
  // TCCR3B |= (1<<CS31); // Enable timer with 1/8 prescaler. ~8.3sec max with uint8 and 32.7msec/tick
  TCCR3B |= (1<<CS31)|(1<<CS30); // Enable timer with 1/64 prescaler. ~66.8sec max with uint8 and 0.262sec/tick
    77ba:	80 81       	ld	r24, Z
    77bc:	83 60       	ori	r24, 0x03	; 3
    77be:	80 83       	st	Z, r24
  // TCCR3B |= (1<<CS32)|(1<<CS30); // Enable timer with 1/1024 prescaler. ~17.8min max with uint8 and 4.19sec/tick
  sleep_disable();
    77c0:	ed cf       	rjmp	.-38     	; 0x779c <sleep_disable>
    77c2:	08 95       	ret

000077c4 <__vector_35>:
}


// Increment sleep counter with each timer overflow.
ISR(TIMER3_OVF_vect) { sleep_counter++; }
    77c4:	1f 92       	push	r1
    77c6:	0f 92       	push	r0
    77c8:	0f b6       	in	r0, 0x3f	; 63
    77ca:	0f 92       	push	r0
    77cc:	11 24       	eor	r1, r1
    77ce:	8f 93       	push	r24
    77d0:	80 91 0f 0f 	lds	r24, 0x0F0F	; 0x800f0f <sleep_counter>
    77d4:	8f 5f       	subi	r24, 0xFF	; 255
    77d6:	80 93 0f 0f 	sts	0x0F0F, r24	; 0x800f0f <sleep_counter>
    77da:	8f 91       	pop	r24
    77dc:	0f 90       	pop	r0
    77de:	0f be       	out	0x3f, r0	; 63
    77e0:	0f 90       	pop	r0
    77e2:	1f 90       	pop	r1
    77e4:	18 95       	reti

000077e6 <jog_execute>:
#include "grbl.h"


// Sets up valid jog motion received from g-code parser, checks for soft-limits, and executes the jog.
uint8_t jog_execute(plan_line_data_t *pl_data, parser_block_t *gc_block)
{
    77e6:	0f 93       	push	r16
    77e8:	1f 93       	push	r17
    77ea:	cf 93       	push	r28
    77ec:	df 93       	push	r29
    77ee:	ec 01       	movw	r28, r24
    77f0:	8b 01       	movw	r16, r22
  // Initialize planner data struct for jogging motions.
  // NOTE: Spindle and coolant are allowed to fully function with overrides during a jog.
  pl_data->feed_rate = gc_block->values.f;
    77f2:	fb 01       	movw	r30, r22
    77f4:	84 85       	ldd	r24, Z+12	; 0x0c
    77f6:	95 85       	ldd	r25, Z+13	; 0x0d
    77f8:	a6 85       	ldd	r26, Z+14	; 0x0e
    77fa:	b7 85       	ldd	r27, Z+15	; 0x0f
    77fc:	88 83       	st	Y, r24
    77fe:	99 83       	std	Y+1, r25	; 0x01
    7800:	aa 83       	std	Y+2, r26	; 0x02
    7802:	bb 83       	std	Y+3, r27	; 0x03
  pl_data->condition |= PL_COND_FLAG_NO_FEED_OVERRIDE;
    7804:	8c 85       	ldd	r24, Y+12	; 0x0c
    7806:	84 60       	ori	r24, 0x04	; 4
    7808:	8c 87       	std	Y+12, r24	; 0x0c
  pl_data->line_number = gc_block->values.n;
    780a:	85 8d       	ldd	r24, Z+29	; 0x1d
    780c:	96 8d       	ldd	r25, Z+30	; 0x1e
    780e:	a7 8d       	ldd	r26, Z+31	; 0x1f
    7810:	b0 a1       	ldd	r27, Z+32	; 0x20
    7812:	88 87       	std	Y+8, r24	; 0x08
    7814:	99 87       	std	Y+9, r25	; 0x09
    7816:	aa 87       	std	Y+10, r26	; 0x0a
    7818:	bb 87       	std	Y+11, r27	; 0x0b

  if (bit_istrue(settings.flags,BITFLAG_SOFT_LIMIT_ENABLE)) {
    781a:	80 91 fe 0e 	lds	r24, 0x0EFE	; 0x800efe <settings+0x45>
    781e:	85 ff       	sbrs	r24, 5
    7820:	05 c0       	rjmp	.+10     	; 0x782c <jog_execute+0x46>
    if (system_check_travel_limits(gc_block->values.xyz)) { return(STATUS_TRAVEL_EXCEEDED); }
    7822:	cb 01       	movw	r24, r22
    7824:	8e 96       	adiw	r24, 0x2e	; 46
    7826:	f7 dc       	rcall	.-1554   	; 0x7216 <system_check_travel_limits>
    7828:	81 11       	cpse	r24, r1
    782a:	15 c0       	rjmp	.+42     	; 0x7856 <jog_execute+0x70>
  }

  // Valid jog command. Plan, set state, and execute.
  mc_line(gc_block->values.xyz,pl_data);
    782c:	be 01       	movw	r22, r28
    782e:	c8 01       	movw	r24, r16
    7830:	8e 96       	adiw	r24, 0x2e	; 46
    7832:	0e 94 ec 02 	call	0x5d8	; 0x5d8 <mc_line>
  if (sys.state == STATE_IDLE) {
    7836:	c0 91 11 0c 	lds	r28, 0x0C11	; 0x800c11 <sys>
    783a:	c1 11       	cpse	r28, r1
    783c:	0e c0       	rjmp	.+28     	; 0x785a <jog_execute+0x74>
    if (plan_get_current_block() != NULL) { // Check if there is a block to execute.
    783e:	0e 94 c3 28 	call	0x5186	; 0x5186 <plan_get_current_block>
    7842:	89 2b       	or	r24, r25
    7844:	59 f0       	breq	.+22     	; 0x785c <jog_execute+0x76>
      sys.state = STATE_JOG;
    7846:	80 e2       	ldi	r24, 0x20	; 32
    7848:	80 93 11 0c 	sts	0x0C11, r24	; 0x800c11 <sys>
      st_prep_buffer();
    784c:	0e 94 86 1b 	call	0x370c	; 0x370c <st_prep_buffer>
      st_wake_up();  // NOTE: Manual start. No state machine required.
    7850:	0e 94 6e 18 	call	0x30dc	; 0x30dc <st_wake_up>
    7854:	03 c0       	rjmp	.+6      	; 0x785c <jog_execute+0x76>
  pl_data->feed_rate = gc_block->values.f;
  pl_data->condition |= PL_COND_FLAG_NO_FEED_OVERRIDE;
  pl_data->line_number = gc_block->values.n;

  if (bit_istrue(settings.flags,BITFLAG_SOFT_LIMIT_ENABLE)) {
    if (system_check_travel_limits(gc_block->values.xyz)) { return(STATUS_TRAVEL_EXCEEDED); }
    7856:	cf e0       	ldi	r28, 0x0F	; 15
    7858:	01 c0       	rjmp	.+2      	; 0x785c <jog_execute+0x76>
      st_prep_buffer();
      st_wake_up();  // NOTE: Manual start. No state machine required.
    }
  }

  return(STATUS_OK);
    785a:	c0 e0       	ldi	r28, 0x00	; 0
}
    785c:	8c 2f       	mov	r24, r28
    785e:	df 91       	pop	r29
    7860:	cf 91       	pop	r28
    7862:	1f 91       	pop	r17
    7864:	0f 91       	pop	r16
    7866:	08 95       	ret

00007868 <__subsf3>:
    7868:	50 58       	subi	r21, 0x80	; 128

0000786a <__addsf3>:
    786a:	bb 27       	eor	r27, r27
    786c:	aa 27       	eor	r26, r26
    786e:	0e d0       	rcall	.+28     	; 0x788c <__addsf3x>
    7870:	76 c2       	rjmp	.+1260   	; 0x7d5e <__fp_round>
    7872:	3f d2       	rcall	.+1150   	; 0x7cf2 <__fp_pscA>
    7874:	30 f0       	brcs	.+12     	; 0x7882 <__addsf3+0x18>
    7876:	44 d2       	rcall	.+1160   	; 0x7d00 <__fp_pscB>
    7878:	20 f0       	brcs	.+8      	; 0x7882 <__addsf3+0x18>
    787a:	31 f4       	brne	.+12     	; 0x7888 <__addsf3+0x1e>
    787c:	9f 3f       	cpi	r25, 0xFF	; 255
    787e:	11 f4       	brne	.+4      	; 0x7884 <__addsf3+0x1a>
    7880:	1e f4       	brtc	.+6      	; 0x7888 <__addsf3+0x1e>
    7882:	0f c2       	rjmp	.+1054   	; 0x7ca2 <__fp_nan>
    7884:	0e f4       	brtc	.+2      	; 0x7888 <__addsf3+0x1e>
    7886:	e0 95       	com	r30
    7888:	e7 fb       	bst	r30, 7
    788a:	dc c1       	rjmp	.+952    	; 0x7c44 <__fp_inf>

0000788c <__addsf3x>:
    788c:	e9 2f       	mov	r30, r25
    788e:	89 d2       	rcall	.+1298   	; 0x7da2 <__fp_split3>
    7890:	80 f3       	brcs	.-32     	; 0x7872 <__addsf3+0x8>
    7892:	ba 17       	cp	r27, r26
    7894:	62 07       	cpc	r22, r18
    7896:	73 07       	cpc	r23, r19
    7898:	84 07       	cpc	r24, r20
    789a:	95 07       	cpc	r25, r21
    789c:	18 f0       	brcs	.+6      	; 0x78a4 <__addsf3x+0x18>
    789e:	71 f4       	brne	.+28     	; 0x78bc <__addsf3x+0x30>
    78a0:	9e f5       	brtc	.+102    	; 0x7908 <__addsf3x+0x7c>
    78a2:	b8 c2       	rjmp	.+1392   	; 0x7e14 <__fp_zero>
    78a4:	0e f4       	brtc	.+2      	; 0x78a8 <__addsf3x+0x1c>
    78a6:	e0 95       	com	r30
    78a8:	0b 2e       	mov	r0, r27
    78aa:	ba 2f       	mov	r27, r26
    78ac:	a0 2d       	mov	r26, r0
    78ae:	0b 01       	movw	r0, r22
    78b0:	b9 01       	movw	r22, r18
    78b2:	90 01       	movw	r18, r0
    78b4:	0c 01       	movw	r0, r24
    78b6:	ca 01       	movw	r24, r20
    78b8:	a0 01       	movw	r20, r0
    78ba:	11 24       	eor	r1, r1
    78bc:	ff 27       	eor	r31, r31
    78be:	59 1b       	sub	r21, r25
    78c0:	99 f0       	breq	.+38     	; 0x78e8 <__addsf3x+0x5c>
    78c2:	59 3f       	cpi	r21, 0xF9	; 249
    78c4:	50 f4       	brcc	.+20     	; 0x78da <__addsf3x+0x4e>
    78c6:	50 3e       	cpi	r21, 0xE0	; 224
    78c8:	68 f1       	brcs	.+90     	; 0x7924 <__addsf3x+0x98>
    78ca:	1a 16       	cp	r1, r26
    78cc:	f0 40       	sbci	r31, 0x00	; 0
    78ce:	a2 2f       	mov	r26, r18
    78d0:	23 2f       	mov	r18, r19
    78d2:	34 2f       	mov	r19, r20
    78d4:	44 27       	eor	r20, r20
    78d6:	58 5f       	subi	r21, 0xF8	; 248
    78d8:	f3 cf       	rjmp	.-26     	; 0x78c0 <__addsf3x+0x34>
    78da:	46 95       	lsr	r20
    78dc:	37 95       	ror	r19
    78de:	27 95       	ror	r18
    78e0:	a7 95       	ror	r26
    78e2:	f0 40       	sbci	r31, 0x00	; 0
    78e4:	53 95       	inc	r21
    78e6:	c9 f7       	brne	.-14     	; 0x78da <__addsf3x+0x4e>
    78e8:	7e f4       	brtc	.+30     	; 0x7908 <__addsf3x+0x7c>
    78ea:	1f 16       	cp	r1, r31
    78ec:	ba 0b       	sbc	r27, r26
    78ee:	62 0b       	sbc	r22, r18
    78f0:	73 0b       	sbc	r23, r19
    78f2:	84 0b       	sbc	r24, r20
    78f4:	ba f0       	brmi	.+46     	; 0x7924 <__addsf3x+0x98>
    78f6:	91 50       	subi	r25, 0x01	; 1
    78f8:	a1 f0       	breq	.+40     	; 0x7922 <__addsf3x+0x96>
    78fa:	ff 0f       	add	r31, r31
    78fc:	bb 1f       	adc	r27, r27
    78fe:	66 1f       	adc	r22, r22
    7900:	77 1f       	adc	r23, r23
    7902:	88 1f       	adc	r24, r24
    7904:	c2 f7       	brpl	.-16     	; 0x78f6 <__addsf3x+0x6a>
    7906:	0e c0       	rjmp	.+28     	; 0x7924 <__addsf3x+0x98>
    7908:	ba 0f       	add	r27, r26
    790a:	62 1f       	adc	r22, r18
    790c:	73 1f       	adc	r23, r19
    790e:	84 1f       	adc	r24, r20
    7910:	48 f4       	brcc	.+18     	; 0x7924 <__addsf3x+0x98>
    7912:	87 95       	ror	r24
    7914:	77 95       	ror	r23
    7916:	67 95       	ror	r22
    7918:	b7 95       	ror	r27
    791a:	f7 95       	ror	r31
    791c:	9e 3f       	cpi	r25, 0xFE	; 254
    791e:	08 f0       	brcs	.+2      	; 0x7922 <__addsf3x+0x96>
    7920:	b3 cf       	rjmp	.-154    	; 0x7888 <__addsf3+0x1e>
    7922:	93 95       	inc	r25
    7924:	88 0f       	add	r24, r24
    7926:	08 f0       	brcs	.+2      	; 0x792a <__addsf3x+0x9e>
    7928:	99 27       	eor	r25, r25
    792a:	ee 0f       	add	r30, r30
    792c:	97 95       	ror	r25
    792e:	87 95       	ror	r24
    7930:	08 95       	ret
    7932:	df d1       	rcall	.+958    	; 0x7cf2 <__fp_pscA>
    7934:	58 f0       	brcs	.+22     	; 0x794c <__addsf3x+0xc0>
    7936:	80 e8       	ldi	r24, 0x80	; 128
    7938:	91 e0       	ldi	r25, 0x01	; 1
    793a:	09 f4       	brne	.+2      	; 0x793e <__addsf3x+0xb2>
    793c:	9e ef       	ldi	r25, 0xFE	; 254
    793e:	e0 d1       	rcall	.+960    	; 0x7d00 <__fp_pscB>
    7940:	28 f0       	brcs	.+10     	; 0x794c <__addsf3x+0xc0>
    7942:	40 e8       	ldi	r20, 0x80	; 128
    7944:	51 e0       	ldi	r21, 0x01	; 1
    7946:	59 f4       	brne	.+22     	; 0x795e <atan2+0xe>
    7948:	5e ef       	ldi	r21, 0xFE	; 254
    794a:	09 c0       	rjmp	.+18     	; 0x795e <atan2+0xe>
    794c:	aa c1       	rjmp	.+852    	; 0x7ca2 <__fp_nan>
    794e:	62 c2       	rjmp	.+1220   	; 0x7e14 <__fp_zero>

00007950 <atan2>:
    7950:	e9 2f       	mov	r30, r25
    7952:	e0 78       	andi	r30, 0x80	; 128
    7954:	26 d2       	rcall	.+1100   	; 0x7da2 <__fp_split3>
    7956:	68 f3       	brcs	.-38     	; 0x7932 <__addsf3x+0xa6>
    7958:	09 2e       	mov	r0, r25
    795a:	05 2a       	or	r0, r21
    795c:	c1 f3       	breq	.-16     	; 0x794e <__addsf3x+0xc2>
    795e:	26 17       	cp	r18, r22
    7960:	37 07       	cpc	r19, r23
    7962:	48 07       	cpc	r20, r24
    7964:	59 07       	cpc	r21, r25
    7966:	38 f0       	brcs	.+14     	; 0x7976 <atan2+0x26>
    7968:	0e 2e       	mov	r0, r30
    796a:	07 f8       	bld	r0, 7
    796c:	e0 25       	eor	r30, r0
    796e:	69 f0       	breq	.+26     	; 0x798a <atan2+0x3a>
    7970:	e0 25       	eor	r30, r0
    7972:	e0 64       	ori	r30, 0x40	; 64
    7974:	0a c0       	rjmp	.+20     	; 0x798a <atan2+0x3a>
    7976:	ef 63       	ori	r30, 0x3F	; 63
    7978:	07 f8       	bld	r0, 7
    797a:	00 94       	com	r0
    797c:	07 fa       	bst	r0, 7
    797e:	db 01       	movw	r26, r22
    7980:	b9 01       	movw	r22, r18
    7982:	9d 01       	movw	r18, r26
    7984:	dc 01       	movw	r26, r24
    7986:	ca 01       	movw	r24, r20
    7988:	ad 01       	movw	r20, r26
    798a:	ef 93       	push	r30
    798c:	5d d0       	rcall	.+186    	; 0x7a48 <__divsf3_pse>
    798e:	e7 d1       	rcall	.+974    	; 0x7d5e <__fp_round>
    7990:	0a d0       	rcall	.+20     	; 0x79a6 <atan>
    7992:	5f 91       	pop	r21
    7994:	55 23       	and	r21, r21
    7996:	31 f0       	breq	.+12     	; 0x79a4 <atan2+0x54>
    7998:	2b ed       	ldi	r18, 0xDB	; 219
    799a:	3f e0       	ldi	r19, 0x0F	; 15
    799c:	49 e4       	ldi	r20, 0x49	; 73
    799e:	50 fd       	sbrc	r21, 0
    79a0:	49 ec       	ldi	r20, 0xC9	; 201
    79a2:	63 cf       	rjmp	.-314    	; 0x786a <__addsf3>
    79a4:	08 95       	ret

000079a6 <atan>:
    79a6:	df 93       	push	r29
    79a8:	dd 27       	eor	r29, r29
    79aa:	b9 2f       	mov	r27, r25
    79ac:	bf 77       	andi	r27, 0x7F	; 127
    79ae:	40 e8       	ldi	r20, 0x80	; 128
    79b0:	5f e3       	ldi	r21, 0x3F	; 63
    79b2:	16 16       	cp	r1, r22
    79b4:	17 06       	cpc	r1, r23
    79b6:	48 07       	cpc	r20, r24
    79b8:	5b 07       	cpc	r21, r27
    79ba:	10 f4       	brcc	.+4      	; 0x79c0 <atan+0x1a>
    79bc:	d9 2f       	mov	r29, r25
    79be:	35 d2       	rcall	.+1130   	; 0x7e2a <inverse>
    79c0:	9f 93       	push	r25
    79c2:	8f 93       	push	r24
    79c4:	7f 93       	push	r23
    79c6:	6f 93       	push	r22
    79c8:	32 d3       	rcall	.+1636   	; 0x802e <square>
    79ca:	ee e9       	ldi	r30, 0x9E	; 158
    79cc:	f2 e0       	ldi	r31, 0x02	; 2
    79ce:	6c d1       	rcall	.+728    	; 0x7ca8 <__fp_powser>
    79d0:	c6 d1       	rcall	.+908    	; 0x7d5e <__fp_round>
    79d2:	2f 91       	pop	r18
    79d4:	3f 91       	pop	r19
    79d6:	4f 91       	pop	r20
    79d8:	5f 91       	pop	r21
    79da:	6a d2       	rcall	.+1236   	; 0x7eb0 <__mulsf3x>
    79dc:	dd 23       	and	r29, r29
    79de:	49 f0       	breq	.+18     	; 0x79f2 <atan+0x4c>
    79e0:	90 58       	subi	r25, 0x80	; 128
    79e2:	a2 ea       	ldi	r26, 0xA2	; 162
    79e4:	2a ed       	ldi	r18, 0xDA	; 218
    79e6:	3f e0       	ldi	r19, 0x0F	; 15
    79e8:	49 ec       	ldi	r20, 0xC9	; 201
    79ea:	5f e3       	ldi	r21, 0x3F	; 63
    79ec:	d0 78       	andi	r29, 0x80	; 128
    79ee:	5d 27       	eor	r21, r29
    79f0:	4d df       	rcall	.-358    	; 0x788c <__addsf3x>
    79f2:	df 91       	pop	r29
    79f4:	b4 c1       	rjmp	.+872    	; 0x7d5e <__fp_round>

000079f6 <ceil>:
    79f6:	f7 d1       	rcall	.+1006   	; 0x7de6 <__fp_trunc>
    79f8:	80 f0       	brcs	.+32     	; 0x7a1a <ceil+0x24>
    79fa:	9f 37       	cpi	r25, 0x7F	; 127
    79fc:	40 f4       	brcc	.+16     	; 0x7a0e <ceil+0x18>
    79fe:	91 11       	cpse	r25, r1
    7a00:	0e f4       	brtc	.+2      	; 0x7a04 <ceil+0xe>
    7a02:	09 c2       	rjmp	.+1042   	; 0x7e16 <__fp_szero>
    7a04:	60 e0       	ldi	r22, 0x00	; 0
    7a06:	70 e0       	ldi	r23, 0x00	; 0
    7a08:	80 e8       	ldi	r24, 0x80	; 128
    7a0a:	9f e3       	ldi	r25, 0x3F	; 63
    7a0c:	08 95       	ret
    7a0e:	26 f0       	brts	.+8      	; 0x7a18 <ceil+0x22>
    7a10:	1b 16       	cp	r1, r27
    7a12:	61 1d       	adc	r22, r1
    7a14:	71 1d       	adc	r23, r1
    7a16:	81 1d       	adc	r24, r1
    7a18:	1b c1       	rjmp	.+566    	; 0x7c50 <__fp_mintl>
    7a1a:	35 c1       	rjmp	.+618    	; 0x7c86 <__fp_mpack>

00007a1c <__cmpsf2>:
    7a1c:	ef d0       	rcall	.+478    	; 0x7bfc <__fp_cmp>
    7a1e:	08 f4       	brcc	.+2      	; 0x7a22 <__cmpsf2+0x6>
    7a20:	81 e0       	ldi	r24, 0x01	; 1
    7a22:	08 95       	ret

00007a24 <cos>:
    7a24:	75 d1       	rcall	.+746    	; 0x7d10 <__fp_rempio2>
    7a26:	e3 95       	inc	r30
    7a28:	ab c1       	rjmp	.+854    	; 0x7d80 <__fp_sinus>

00007a2a <__divsf3>:
    7a2a:	0c d0       	rcall	.+24     	; 0x7a44 <__divsf3x>
    7a2c:	98 c1       	rjmp	.+816    	; 0x7d5e <__fp_round>
    7a2e:	68 d1       	rcall	.+720    	; 0x7d00 <__fp_pscB>
    7a30:	40 f0       	brcs	.+16     	; 0x7a42 <__divsf3+0x18>
    7a32:	5f d1       	rcall	.+702    	; 0x7cf2 <__fp_pscA>
    7a34:	30 f0       	brcs	.+12     	; 0x7a42 <__divsf3+0x18>
    7a36:	21 f4       	brne	.+8      	; 0x7a40 <__divsf3+0x16>
    7a38:	5f 3f       	cpi	r21, 0xFF	; 255
    7a3a:	19 f0       	breq	.+6      	; 0x7a42 <__divsf3+0x18>
    7a3c:	03 c1       	rjmp	.+518    	; 0x7c44 <__fp_inf>
    7a3e:	51 11       	cpse	r21, r1
    7a40:	ea c1       	rjmp	.+980    	; 0x7e16 <__fp_szero>
    7a42:	2f c1       	rjmp	.+606    	; 0x7ca2 <__fp_nan>

00007a44 <__divsf3x>:
    7a44:	ae d1       	rcall	.+860    	; 0x7da2 <__fp_split3>
    7a46:	98 f3       	brcs	.-26     	; 0x7a2e <__divsf3+0x4>

00007a48 <__divsf3_pse>:
    7a48:	99 23       	and	r25, r25
    7a4a:	c9 f3       	breq	.-14     	; 0x7a3e <__divsf3+0x14>
    7a4c:	55 23       	and	r21, r21
    7a4e:	b1 f3       	breq	.-20     	; 0x7a3c <__divsf3+0x12>
    7a50:	95 1b       	sub	r25, r21
    7a52:	55 0b       	sbc	r21, r21
    7a54:	bb 27       	eor	r27, r27
    7a56:	aa 27       	eor	r26, r26
    7a58:	62 17       	cp	r22, r18
    7a5a:	73 07       	cpc	r23, r19
    7a5c:	84 07       	cpc	r24, r20
    7a5e:	38 f0       	brcs	.+14     	; 0x7a6e <__divsf3_pse+0x26>
    7a60:	9f 5f       	subi	r25, 0xFF	; 255
    7a62:	5f 4f       	sbci	r21, 0xFF	; 255
    7a64:	22 0f       	add	r18, r18
    7a66:	33 1f       	adc	r19, r19
    7a68:	44 1f       	adc	r20, r20
    7a6a:	aa 1f       	adc	r26, r26
    7a6c:	a9 f3       	breq	.-22     	; 0x7a58 <__divsf3_pse+0x10>
    7a6e:	33 d0       	rcall	.+102    	; 0x7ad6 <__divsf3_pse+0x8e>
    7a70:	0e 2e       	mov	r0, r30
    7a72:	3a f0       	brmi	.+14     	; 0x7a82 <__divsf3_pse+0x3a>
    7a74:	e0 e8       	ldi	r30, 0x80	; 128
    7a76:	30 d0       	rcall	.+96     	; 0x7ad8 <__divsf3_pse+0x90>
    7a78:	91 50       	subi	r25, 0x01	; 1
    7a7a:	50 40       	sbci	r21, 0x00	; 0
    7a7c:	e6 95       	lsr	r30
    7a7e:	00 1c       	adc	r0, r0
    7a80:	ca f7       	brpl	.-14     	; 0x7a74 <__divsf3_pse+0x2c>
    7a82:	29 d0       	rcall	.+82     	; 0x7ad6 <__divsf3_pse+0x8e>
    7a84:	fe 2f       	mov	r31, r30
    7a86:	27 d0       	rcall	.+78     	; 0x7ad6 <__divsf3_pse+0x8e>
    7a88:	66 0f       	add	r22, r22
    7a8a:	77 1f       	adc	r23, r23
    7a8c:	88 1f       	adc	r24, r24
    7a8e:	bb 1f       	adc	r27, r27
    7a90:	26 17       	cp	r18, r22
    7a92:	37 07       	cpc	r19, r23
    7a94:	48 07       	cpc	r20, r24
    7a96:	ab 07       	cpc	r26, r27
    7a98:	b0 e8       	ldi	r27, 0x80	; 128
    7a9a:	09 f0       	breq	.+2      	; 0x7a9e <__divsf3_pse+0x56>
    7a9c:	bb 0b       	sbc	r27, r27
    7a9e:	80 2d       	mov	r24, r0
    7aa0:	bf 01       	movw	r22, r30
    7aa2:	ff 27       	eor	r31, r31
    7aa4:	93 58       	subi	r25, 0x83	; 131
    7aa6:	5f 4f       	sbci	r21, 0xFF	; 255
    7aa8:	2a f0       	brmi	.+10     	; 0x7ab4 <__divsf3_pse+0x6c>
    7aaa:	9e 3f       	cpi	r25, 0xFE	; 254
    7aac:	51 05       	cpc	r21, r1
    7aae:	68 f0       	brcs	.+26     	; 0x7aca <__divsf3_pse+0x82>
    7ab0:	c9 c0       	rjmp	.+402    	; 0x7c44 <__fp_inf>
    7ab2:	b1 c1       	rjmp	.+866    	; 0x7e16 <__fp_szero>
    7ab4:	5f 3f       	cpi	r21, 0xFF	; 255
    7ab6:	ec f3       	brlt	.-6      	; 0x7ab2 <__divsf3_pse+0x6a>
    7ab8:	98 3e       	cpi	r25, 0xE8	; 232
    7aba:	dc f3       	brlt	.-10     	; 0x7ab2 <__divsf3_pse+0x6a>
    7abc:	86 95       	lsr	r24
    7abe:	77 95       	ror	r23
    7ac0:	67 95       	ror	r22
    7ac2:	b7 95       	ror	r27
    7ac4:	f7 95       	ror	r31
    7ac6:	9f 5f       	subi	r25, 0xFF	; 255
    7ac8:	c9 f7       	brne	.-14     	; 0x7abc <__divsf3_pse+0x74>
    7aca:	88 0f       	add	r24, r24
    7acc:	91 1d       	adc	r25, r1
    7ace:	96 95       	lsr	r25
    7ad0:	87 95       	ror	r24
    7ad2:	97 f9       	bld	r25, 7
    7ad4:	08 95       	ret
    7ad6:	e1 e0       	ldi	r30, 0x01	; 1
    7ad8:	66 0f       	add	r22, r22
    7ada:	77 1f       	adc	r23, r23
    7adc:	88 1f       	adc	r24, r24
    7ade:	bb 1f       	adc	r27, r27
    7ae0:	62 17       	cp	r22, r18
    7ae2:	73 07       	cpc	r23, r19
    7ae4:	84 07       	cpc	r24, r20
    7ae6:	ba 07       	cpc	r27, r26
    7ae8:	20 f0       	brcs	.+8      	; 0x7af2 <__divsf3_pse+0xaa>
    7aea:	62 1b       	sub	r22, r18
    7aec:	73 0b       	sbc	r23, r19
    7aee:	84 0b       	sbc	r24, r20
    7af0:	ba 0b       	sbc	r27, r26
    7af2:	ee 1f       	adc	r30, r30
    7af4:	88 f7       	brcc	.-30     	; 0x7ad8 <__divsf3_pse+0x90>
    7af6:	e0 95       	com	r30
    7af8:	08 95       	ret

00007afa <__fixsfsi>:
    7afa:	04 d0       	rcall	.+8      	; 0x7b04 <__fixunssfsi>
    7afc:	68 94       	set
    7afe:	b1 11       	cpse	r27, r1
    7b00:	8a c1       	rjmp	.+788    	; 0x7e16 <__fp_szero>
    7b02:	08 95       	ret

00007b04 <__fixunssfsi>:
    7b04:	56 d1       	rcall	.+684    	; 0x7db2 <__fp_splitA>
    7b06:	88 f0       	brcs	.+34     	; 0x7b2a <__fixunssfsi+0x26>
    7b08:	9f 57       	subi	r25, 0x7F	; 127
    7b0a:	90 f0       	brcs	.+36     	; 0x7b30 <__fixunssfsi+0x2c>
    7b0c:	b9 2f       	mov	r27, r25
    7b0e:	99 27       	eor	r25, r25
    7b10:	b7 51       	subi	r27, 0x17	; 23
    7b12:	a0 f0       	brcs	.+40     	; 0x7b3c <__fixunssfsi+0x38>
    7b14:	d1 f0       	breq	.+52     	; 0x7b4a <__fixunssfsi+0x46>
    7b16:	66 0f       	add	r22, r22
    7b18:	77 1f       	adc	r23, r23
    7b1a:	88 1f       	adc	r24, r24
    7b1c:	99 1f       	adc	r25, r25
    7b1e:	1a f0       	brmi	.+6      	; 0x7b26 <__fixunssfsi+0x22>
    7b20:	ba 95       	dec	r27
    7b22:	c9 f7       	brne	.-14     	; 0x7b16 <__fixunssfsi+0x12>
    7b24:	12 c0       	rjmp	.+36     	; 0x7b4a <__fixunssfsi+0x46>
    7b26:	b1 30       	cpi	r27, 0x01	; 1
    7b28:	81 f0       	breq	.+32     	; 0x7b4a <__fixunssfsi+0x46>
    7b2a:	74 d1       	rcall	.+744    	; 0x7e14 <__fp_zero>
    7b2c:	b1 e0       	ldi	r27, 0x01	; 1
    7b2e:	08 95       	ret
    7b30:	71 c1       	rjmp	.+738    	; 0x7e14 <__fp_zero>
    7b32:	67 2f       	mov	r22, r23
    7b34:	78 2f       	mov	r23, r24
    7b36:	88 27       	eor	r24, r24
    7b38:	b8 5f       	subi	r27, 0xF8	; 248
    7b3a:	39 f0       	breq	.+14     	; 0x7b4a <__fixunssfsi+0x46>
    7b3c:	b9 3f       	cpi	r27, 0xF9	; 249
    7b3e:	cc f3       	brlt	.-14     	; 0x7b32 <__fixunssfsi+0x2e>
    7b40:	86 95       	lsr	r24
    7b42:	77 95       	ror	r23
    7b44:	67 95       	ror	r22
    7b46:	b3 95       	inc	r27
    7b48:	d9 f7       	brne	.-10     	; 0x7b40 <__fixunssfsi+0x3c>
    7b4a:	3e f4       	brtc	.+14     	; 0x7b5a <__fixunssfsi+0x56>
    7b4c:	90 95       	com	r25
    7b4e:	80 95       	com	r24
    7b50:	70 95       	com	r23
    7b52:	61 95       	neg	r22
    7b54:	7f 4f       	sbci	r23, 0xFF	; 255
    7b56:	8f 4f       	sbci	r24, 0xFF	; 255
    7b58:	9f 4f       	sbci	r25, 0xFF	; 255
    7b5a:	08 95       	ret

00007b5c <__floatunsisf>:
    7b5c:	e8 94       	clt
    7b5e:	09 c0       	rjmp	.+18     	; 0x7b72 <__floatsisf+0x12>

00007b60 <__floatsisf>:
    7b60:	97 fb       	bst	r25, 7
    7b62:	3e f4       	brtc	.+14     	; 0x7b72 <__floatsisf+0x12>
    7b64:	90 95       	com	r25
    7b66:	80 95       	com	r24
    7b68:	70 95       	com	r23
    7b6a:	61 95       	neg	r22
    7b6c:	7f 4f       	sbci	r23, 0xFF	; 255
    7b6e:	8f 4f       	sbci	r24, 0xFF	; 255
    7b70:	9f 4f       	sbci	r25, 0xFF	; 255
    7b72:	99 23       	and	r25, r25
    7b74:	a9 f0       	breq	.+42     	; 0x7ba0 <__floatsisf+0x40>
    7b76:	f9 2f       	mov	r31, r25
    7b78:	96 e9       	ldi	r25, 0x96	; 150
    7b7a:	bb 27       	eor	r27, r27
    7b7c:	93 95       	inc	r25
    7b7e:	f6 95       	lsr	r31
    7b80:	87 95       	ror	r24
    7b82:	77 95       	ror	r23
    7b84:	67 95       	ror	r22
    7b86:	b7 95       	ror	r27
    7b88:	f1 11       	cpse	r31, r1
    7b8a:	f8 cf       	rjmp	.-16     	; 0x7b7c <__floatsisf+0x1c>
    7b8c:	fa f4       	brpl	.+62     	; 0x7bcc <__floatsisf+0x6c>
    7b8e:	bb 0f       	add	r27, r27
    7b90:	11 f4       	brne	.+4      	; 0x7b96 <__floatsisf+0x36>
    7b92:	60 ff       	sbrs	r22, 0
    7b94:	1b c0       	rjmp	.+54     	; 0x7bcc <__floatsisf+0x6c>
    7b96:	6f 5f       	subi	r22, 0xFF	; 255
    7b98:	7f 4f       	sbci	r23, 0xFF	; 255
    7b9a:	8f 4f       	sbci	r24, 0xFF	; 255
    7b9c:	9f 4f       	sbci	r25, 0xFF	; 255
    7b9e:	16 c0       	rjmp	.+44     	; 0x7bcc <__floatsisf+0x6c>
    7ba0:	88 23       	and	r24, r24
    7ba2:	11 f0       	breq	.+4      	; 0x7ba8 <__floatsisf+0x48>
    7ba4:	96 e9       	ldi	r25, 0x96	; 150
    7ba6:	11 c0       	rjmp	.+34     	; 0x7bca <__floatsisf+0x6a>
    7ba8:	77 23       	and	r23, r23
    7baa:	21 f0       	breq	.+8      	; 0x7bb4 <__floatsisf+0x54>
    7bac:	9e e8       	ldi	r25, 0x8E	; 142
    7bae:	87 2f       	mov	r24, r23
    7bb0:	76 2f       	mov	r23, r22
    7bb2:	05 c0       	rjmp	.+10     	; 0x7bbe <__floatsisf+0x5e>
    7bb4:	66 23       	and	r22, r22
    7bb6:	71 f0       	breq	.+28     	; 0x7bd4 <__floatsisf+0x74>
    7bb8:	96 e8       	ldi	r25, 0x86	; 134
    7bba:	86 2f       	mov	r24, r22
    7bbc:	70 e0       	ldi	r23, 0x00	; 0
    7bbe:	60 e0       	ldi	r22, 0x00	; 0
    7bc0:	2a f0       	brmi	.+10     	; 0x7bcc <__floatsisf+0x6c>
    7bc2:	9a 95       	dec	r25
    7bc4:	66 0f       	add	r22, r22
    7bc6:	77 1f       	adc	r23, r23
    7bc8:	88 1f       	adc	r24, r24
    7bca:	da f7       	brpl	.-10     	; 0x7bc2 <__floatsisf+0x62>
    7bcc:	88 0f       	add	r24, r24
    7bce:	96 95       	lsr	r25
    7bd0:	87 95       	ror	r24
    7bd2:	97 f9       	bld	r25, 7
    7bd4:	08 95       	ret

00007bd6 <floor>:
    7bd6:	07 d1       	rcall	.+526    	; 0x7de6 <__fp_trunc>
    7bd8:	80 f0       	brcs	.+32     	; 0x7bfa <floor+0x24>
    7bda:	9f 37       	cpi	r25, 0x7F	; 127
    7bdc:	40 f4       	brcc	.+16     	; 0x7bee <floor+0x18>
    7bde:	91 11       	cpse	r25, r1
    7be0:	0e f0       	brts	.+2      	; 0x7be4 <floor+0xe>
    7be2:	19 c1       	rjmp	.+562    	; 0x7e16 <__fp_szero>
    7be4:	60 e0       	ldi	r22, 0x00	; 0
    7be6:	70 e0       	ldi	r23, 0x00	; 0
    7be8:	80 e8       	ldi	r24, 0x80	; 128
    7bea:	9f eb       	ldi	r25, 0xBF	; 191
    7bec:	08 95       	ret
    7bee:	26 f4       	brtc	.+8      	; 0x7bf8 <floor+0x22>
    7bf0:	1b 16       	cp	r1, r27
    7bf2:	61 1d       	adc	r22, r1
    7bf4:	71 1d       	adc	r23, r1
    7bf6:	81 1d       	adc	r24, r1
    7bf8:	2b c0       	rjmp	.+86     	; 0x7c50 <__fp_mintl>
    7bfa:	45 c0       	rjmp	.+138    	; 0x7c86 <__fp_mpack>

00007bfc <__fp_cmp>:
    7bfc:	99 0f       	add	r25, r25
    7bfe:	00 08       	sbc	r0, r0
    7c00:	55 0f       	add	r21, r21
    7c02:	aa 0b       	sbc	r26, r26
    7c04:	e0 e8       	ldi	r30, 0x80	; 128
    7c06:	fe ef       	ldi	r31, 0xFE	; 254
    7c08:	16 16       	cp	r1, r22
    7c0a:	17 06       	cpc	r1, r23
    7c0c:	e8 07       	cpc	r30, r24
    7c0e:	f9 07       	cpc	r31, r25
    7c10:	c0 f0       	brcs	.+48     	; 0x7c42 <__fp_cmp+0x46>
    7c12:	12 16       	cp	r1, r18
    7c14:	13 06       	cpc	r1, r19
    7c16:	e4 07       	cpc	r30, r20
    7c18:	f5 07       	cpc	r31, r21
    7c1a:	98 f0       	brcs	.+38     	; 0x7c42 <__fp_cmp+0x46>
    7c1c:	62 1b       	sub	r22, r18
    7c1e:	73 0b       	sbc	r23, r19
    7c20:	84 0b       	sbc	r24, r20
    7c22:	95 0b       	sbc	r25, r21
    7c24:	39 f4       	brne	.+14     	; 0x7c34 <__fp_cmp+0x38>
    7c26:	0a 26       	eor	r0, r26
    7c28:	61 f0       	breq	.+24     	; 0x7c42 <__fp_cmp+0x46>
    7c2a:	23 2b       	or	r18, r19
    7c2c:	24 2b       	or	r18, r20
    7c2e:	25 2b       	or	r18, r21
    7c30:	21 f4       	brne	.+8      	; 0x7c3a <__fp_cmp+0x3e>
    7c32:	08 95       	ret
    7c34:	0a 26       	eor	r0, r26
    7c36:	09 f4       	brne	.+2      	; 0x7c3a <__fp_cmp+0x3e>
    7c38:	a1 40       	sbci	r26, 0x01	; 1
    7c3a:	a6 95       	lsr	r26
    7c3c:	8f ef       	ldi	r24, 0xFF	; 255
    7c3e:	81 1d       	adc	r24, r1
    7c40:	81 1d       	adc	r24, r1
    7c42:	08 95       	ret

00007c44 <__fp_inf>:
    7c44:	97 f9       	bld	r25, 7
    7c46:	9f 67       	ori	r25, 0x7F	; 127
    7c48:	80 e8       	ldi	r24, 0x80	; 128
    7c4a:	70 e0       	ldi	r23, 0x00	; 0
    7c4c:	60 e0       	ldi	r22, 0x00	; 0
    7c4e:	08 95       	ret

00007c50 <__fp_mintl>:
    7c50:	88 23       	and	r24, r24
    7c52:	71 f4       	brne	.+28     	; 0x7c70 <__fp_mintl+0x20>
    7c54:	77 23       	and	r23, r23
    7c56:	21 f0       	breq	.+8      	; 0x7c60 <__fp_mintl+0x10>
    7c58:	98 50       	subi	r25, 0x08	; 8
    7c5a:	87 2b       	or	r24, r23
    7c5c:	76 2f       	mov	r23, r22
    7c5e:	07 c0       	rjmp	.+14     	; 0x7c6e <__fp_mintl+0x1e>
    7c60:	66 23       	and	r22, r22
    7c62:	11 f4       	brne	.+4      	; 0x7c68 <__fp_mintl+0x18>
    7c64:	99 27       	eor	r25, r25
    7c66:	0d c0       	rjmp	.+26     	; 0x7c82 <__fp_mintl+0x32>
    7c68:	90 51       	subi	r25, 0x10	; 16
    7c6a:	86 2b       	or	r24, r22
    7c6c:	70 e0       	ldi	r23, 0x00	; 0
    7c6e:	60 e0       	ldi	r22, 0x00	; 0
    7c70:	2a f0       	brmi	.+10     	; 0x7c7c <__fp_mintl+0x2c>
    7c72:	9a 95       	dec	r25
    7c74:	66 0f       	add	r22, r22
    7c76:	77 1f       	adc	r23, r23
    7c78:	88 1f       	adc	r24, r24
    7c7a:	da f7       	brpl	.-10     	; 0x7c72 <__fp_mintl+0x22>
    7c7c:	88 0f       	add	r24, r24
    7c7e:	96 95       	lsr	r25
    7c80:	87 95       	ror	r24
    7c82:	97 f9       	bld	r25, 7
    7c84:	08 95       	ret

00007c86 <__fp_mpack>:
    7c86:	9f 3f       	cpi	r25, 0xFF	; 255
    7c88:	31 f0       	breq	.+12     	; 0x7c96 <__fp_mpack_finite+0xc>

00007c8a <__fp_mpack_finite>:
    7c8a:	91 50       	subi	r25, 0x01	; 1
    7c8c:	20 f4       	brcc	.+8      	; 0x7c96 <__fp_mpack_finite+0xc>
    7c8e:	87 95       	ror	r24
    7c90:	77 95       	ror	r23
    7c92:	67 95       	ror	r22
    7c94:	b7 95       	ror	r27
    7c96:	88 0f       	add	r24, r24
    7c98:	91 1d       	adc	r25, r1
    7c9a:	96 95       	lsr	r25
    7c9c:	87 95       	ror	r24
    7c9e:	97 f9       	bld	r25, 7
    7ca0:	08 95       	ret

00007ca2 <__fp_nan>:
    7ca2:	9f ef       	ldi	r25, 0xFF	; 255
    7ca4:	80 ec       	ldi	r24, 0xC0	; 192
    7ca6:	08 95       	ret

00007ca8 <__fp_powser>:
    7ca8:	df 93       	push	r29
    7caa:	cf 93       	push	r28
    7cac:	1f 93       	push	r17
    7cae:	0f 93       	push	r16
    7cb0:	ff 92       	push	r15
    7cb2:	ef 92       	push	r14
    7cb4:	df 92       	push	r13
    7cb6:	7b 01       	movw	r14, r22
    7cb8:	8c 01       	movw	r16, r24
    7cba:	68 94       	set
    7cbc:	05 c0       	rjmp	.+10     	; 0x7cc8 <__fp_powser+0x20>
    7cbe:	da 2e       	mov	r13, r26
    7cc0:	ef 01       	movw	r28, r30
    7cc2:	f6 d0       	rcall	.+492    	; 0x7eb0 <__mulsf3x>
    7cc4:	fe 01       	movw	r30, r28
    7cc6:	e8 94       	clt
    7cc8:	a5 91       	lpm	r26, Z+
    7cca:	25 91       	lpm	r18, Z+
    7ccc:	35 91       	lpm	r19, Z+
    7cce:	45 91       	lpm	r20, Z+
    7cd0:	55 91       	lpm	r21, Z+
    7cd2:	ae f3       	brts	.-22     	; 0x7cbe <__fp_powser+0x16>
    7cd4:	ef 01       	movw	r28, r30
    7cd6:	da dd       	rcall	.-1100   	; 0x788c <__addsf3x>
    7cd8:	fe 01       	movw	r30, r28
    7cda:	97 01       	movw	r18, r14
    7cdc:	a8 01       	movw	r20, r16
    7cde:	da 94       	dec	r13
    7ce0:	79 f7       	brne	.-34     	; 0x7cc0 <__fp_powser+0x18>
    7ce2:	df 90       	pop	r13
    7ce4:	ef 90       	pop	r14
    7ce6:	ff 90       	pop	r15
    7ce8:	0f 91       	pop	r16
    7cea:	1f 91       	pop	r17
    7cec:	cf 91       	pop	r28
    7cee:	df 91       	pop	r29
    7cf0:	08 95       	ret

00007cf2 <__fp_pscA>:
    7cf2:	00 24       	eor	r0, r0
    7cf4:	0a 94       	dec	r0
    7cf6:	16 16       	cp	r1, r22
    7cf8:	17 06       	cpc	r1, r23
    7cfa:	18 06       	cpc	r1, r24
    7cfc:	09 06       	cpc	r0, r25
    7cfe:	08 95       	ret

00007d00 <__fp_pscB>:
    7d00:	00 24       	eor	r0, r0
    7d02:	0a 94       	dec	r0
    7d04:	12 16       	cp	r1, r18
    7d06:	13 06       	cpc	r1, r19
    7d08:	14 06       	cpc	r1, r20
    7d0a:	05 06       	cpc	r0, r21
    7d0c:	08 95       	ret
    7d0e:	c9 cf       	rjmp	.-110    	; 0x7ca2 <__fp_nan>

00007d10 <__fp_rempio2>:
    7d10:	50 d0       	rcall	.+160    	; 0x7db2 <__fp_splitA>
    7d12:	e8 f3       	brcs	.-6      	; 0x7d0e <__fp_pscB+0xe>
    7d14:	e8 94       	clt
    7d16:	e0 e0       	ldi	r30, 0x00	; 0
    7d18:	bb 27       	eor	r27, r27
    7d1a:	9f 57       	subi	r25, 0x7F	; 127
    7d1c:	f0 f0       	brcs	.+60     	; 0x7d5a <__fp_rempio2+0x4a>
    7d1e:	2a ed       	ldi	r18, 0xDA	; 218
    7d20:	3f e0       	ldi	r19, 0x0F	; 15
    7d22:	49 ec       	ldi	r20, 0xC9	; 201
    7d24:	06 c0       	rjmp	.+12     	; 0x7d32 <__fp_rempio2+0x22>
    7d26:	ee 0f       	add	r30, r30
    7d28:	bb 0f       	add	r27, r27
    7d2a:	66 1f       	adc	r22, r22
    7d2c:	77 1f       	adc	r23, r23
    7d2e:	88 1f       	adc	r24, r24
    7d30:	28 f0       	brcs	.+10     	; 0x7d3c <__fp_rempio2+0x2c>
    7d32:	b2 3a       	cpi	r27, 0xA2	; 162
    7d34:	62 07       	cpc	r22, r18
    7d36:	73 07       	cpc	r23, r19
    7d38:	84 07       	cpc	r24, r20
    7d3a:	28 f0       	brcs	.+10     	; 0x7d46 <__fp_rempio2+0x36>
    7d3c:	b2 5a       	subi	r27, 0xA2	; 162
    7d3e:	62 0b       	sbc	r22, r18
    7d40:	73 0b       	sbc	r23, r19
    7d42:	84 0b       	sbc	r24, r20
    7d44:	e3 95       	inc	r30
    7d46:	9a 95       	dec	r25
    7d48:	72 f7       	brpl	.-36     	; 0x7d26 <__fp_rempio2+0x16>
    7d4a:	80 38       	cpi	r24, 0x80	; 128
    7d4c:	30 f4       	brcc	.+12     	; 0x7d5a <__fp_rempio2+0x4a>
    7d4e:	9a 95       	dec	r25
    7d50:	bb 0f       	add	r27, r27
    7d52:	66 1f       	adc	r22, r22
    7d54:	77 1f       	adc	r23, r23
    7d56:	88 1f       	adc	r24, r24
    7d58:	d2 f7       	brpl	.-12     	; 0x7d4e <__fp_rempio2+0x3e>
    7d5a:	90 48       	sbci	r25, 0x80	; 128
    7d5c:	96 cf       	rjmp	.-212    	; 0x7c8a <__fp_mpack_finite>

00007d5e <__fp_round>:
    7d5e:	09 2e       	mov	r0, r25
    7d60:	03 94       	inc	r0
    7d62:	00 0c       	add	r0, r0
    7d64:	11 f4       	brne	.+4      	; 0x7d6a <__fp_round+0xc>
    7d66:	88 23       	and	r24, r24
    7d68:	52 f0       	brmi	.+20     	; 0x7d7e <__fp_round+0x20>
    7d6a:	bb 0f       	add	r27, r27
    7d6c:	40 f4       	brcc	.+16     	; 0x7d7e <__fp_round+0x20>
    7d6e:	bf 2b       	or	r27, r31
    7d70:	11 f4       	brne	.+4      	; 0x7d76 <__fp_round+0x18>
    7d72:	60 ff       	sbrs	r22, 0
    7d74:	04 c0       	rjmp	.+8      	; 0x7d7e <__fp_round+0x20>
    7d76:	6f 5f       	subi	r22, 0xFF	; 255
    7d78:	7f 4f       	sbci	r23, 0xFF	; 255
    7d7a:	8f 4f       	sbci	r24, 0xFF	; 255
    7d7c:	9f 4f       	sbci	r25, 0xFF	; 255
    7d7e:	08 95       	ret

00007d80 <__fp_sinus>:
    7d80:	ef 93       	push	r30
    7d82:	e0 ff       	sbrs	r30, 0
    7d84:	06 c0       	rjmp	.+12     	; 0x7d92 <__fp_sinus+0x12>
    7d86:	a2 ea       	ldi	r26, 0xA2	; 162
    7d88:	2a ed       	ldi	r18, 0xDA	; 218
    7d8a:	3f e0       	ldi	r19, 0x0F	; 15
    7d8c:	49 ec       	ldi	r20, 0xC9	; 201
    7d8e:	5f eb       	ldi	r21, 0xBF	; 191
    7d90:	7d dd       	rcall	.-1286   	; 0x788c <__addsf3x>
    7d92:	e5 df       	rcall	.-54     	; 0x7d5e <__fp_round>
    7d94:	0f 90       	pop	r0
    7d96:	03 94       	inc	r0
    7d98:	01 fc       	sbrc	r0, 1
    7d9a:	90 58       	subi	r25, 0x80	; 128
    7d9c:	eb ec       	ldi	r30, 0xCB	; 203
    7d9e:	f2 e0       	ldi	r31, 0x02	; 2
    7da0:	57 c1       	rjmp	.+686    	; 0x8050 <__fp_powsodd>

00007da2 <__fp_split3>:
    7da2:	57 fd       	sbrc	r21, 7
    7da4:	90 58       	subi	r25, 0x80	; 128
    7da6:	44 0f       	add	r20, r20
    7da8:	55 1f       	adc	r21, r21
    7daa:	59 f0       	breq	.+22     	; 0x7dc2 <__fp_splitA+0x10>
    7dac:	5f 3f       	cpi	r21, 0xFF	; 255
    7dae:	71 f0       	breq	.+28     	; 0x7dcc <__fp_splitA+0x1a>
    7db0:	47 95       	ror	r20

00007db2 <__fp_splitA>:
    7db2:	88 0f       	add	r24, r24
    7db4:	97 fb       	bst	r25, 7
    7db6:	99 1f       	adc	r25, r25
    7db8:	61 f0       	breq	.+24     	; 0x7dd2 <__fp_splitA+0x20>
    7dba:	9f 3f       	cpi	r25, 0xFF	; 255
    7dbc:	79 f0       	breq	.+30     	; 0x7ddc <__fp_splitA+0x2a>
    7dbe:	87 95       	ror	r24
    7dc0:	08 95       	ret
    7dc2:	12 16       	cp	r1, r18
    7dc4:	13 06       	cpc	r1, r19
    7dc6:	14 06       	cpc	r1, r20
    7dc8:	55 1f       	adc	r21, r21
    7dca:	f2 cf       	rjmp	.-28     	; 0x7db0 <__fp_split3+0xe>
    7dcc:	46 95       	lsr	r20
    7dce:	f1 df       	rcall	.-30     	; 0x7db2 <__fp_splitA>
    7dd0:	08 c0       	rjmp	.+16     	; 0x7de2 <__fp_splitA+0x30>
    7dd2:	16 16       	cp	r1, r22
    7dd4:	17 06       	cpc	r1, r23
    7dd6:	18 06       	cpc	r1, r24
    7dd8:	99 1f       	adc	r25, r25
    7dda:	f1 cf       	rjmp	.-30     	; 0x7dbe <__fp_splitA+0xc>
    7ddc:	86 95       	lsr	r24
    7dde:	71 05       	cpc	r23, r1
    7de0:	61 05       	cpc	r22, r1
    7de2:	08 94       	sec
    7de4:	08 95       	ret

00007de6 <__fp_trunc>:
    7de6:	e5 df       	rcall	.-54     	; 0x7db2 <__fp_splitA>
    7de8:	a0 f0       	brcs	.+40     	; 0x7e12 <__fp_trunc+0x2c>
    7dea:	be e7       	ldi	r27, 0x7E	; 126
    7dec:	b9 17       	cp	r27, r25
    7dee:	88 f4       	brcc	.+34     	; 0x7e12 <__fp_trunc+0x2c>
    7df0:	bb 27       	eor	r27, r27
    7df2:	9f 38       	cpi	r25, 0x8F	; 143
    7df4:	60 f4       	brcc	.+24     	; 0x7e0e <__fp_trunc+0x28>
    7df6:	16 16       	cp	r1, r22
    7df8:	b1 1d       	adc	r27, r1
    7dfa:	67 2f       	mov	r22, r23
    7dfc:	78 2f       	mov	r23, r24
    7dfe:	88 27       	eor	r24, r24
    7e00:	98 5f       	subi	r25, 0xF8	; 248
    7e02:	f7 cf       	rjmp	.-18     	; 0x7df2 <__fp_trunc+0xc>
    7e04:	86 95       	lsr	r24
    7e06:	77 95       	ror	r23
    7e08:	67 95       	ror	r22
    7e0a:	b1 1d       	adc	r27, r1
    7e0c:	93 95       	inc	r25
    7e0e:	96 39       	cpi	r25, 0x96	; 150
    7e10:	c8 f3       	brcs	.-14     	; 0x7e04 <__fp_trunc+0x1e>
    7e12:	08 95       	ret

00007e14 <__fp_zero>:
    7e14:	e8 94       	clt

00007e16 <__fp_szero>:
    7e16:	bb 27       	eor	r27, r27
    7e18:	66 27       	eor	r22, r22
    7e1a:	77 27       	eor	r23, r23
    7e1c:	cb 01       	movw	r24, r22
    7e1e:	97 f9       	bld	r25, 7
    7e20:	08 95       	ret

00007e22 <__gesf2>:
    7e22:	ec de       	rcall	.-552    	; 0x7bfc <__fp_cmp>
    7e24:	08 f4       	brcc	.+2      	; 0x7e28 <__gesf2+0x6>
    7e26:	8f ef       	ldi	r24, 0xFF	; 255
    7e28:	08 95       	ret

00007e2a <inverse>:
    7e2a:	9b 01       	movw	r18, r22
    7e2c:	ac 01       	movw	r20, r24
    7e2e:	60 e0       	ldi	r22, 0x00	; 0
    7e30:	70 e0       	ldi	r23, 0x00	; 0
    7e32:	80 e8       	ldi	r24, 0x80	; 128
    7e34:	9f e3       	ldi	r25, 0x3F	; 63
    7e36:	f9 cd       	rjmp	.-1038   	; 0x7a2a <__divsf3>

00007e38 <lround>:
    7e38:	bc df       	rcall	.-136    	; 0x7db2 <__fp_splitA>
    7e3a:	58 f1       	brcs	.+86     	; 0x7e92 <lround+0x5a>
    7e3c:	9e 57       	subi	r25, 0x7E	; 126
    7e3e:	58 f1       	brcs	.+86     	; 0x7e96 <lround+0x5e>
    7e40:	98 51       	subi	r25, 0x18	; 24
    7e42:	a0 f0       	brcs	.+40     	; 0x7e6c <lround+0x34>
    7e44:	e9 f0       	breq	.+58     	; 0x7e80 <lround+0x48>
    7e46:	98 30       	cpi	r25, 0x08	; 8
    7e48:	20 f5       	brcc	.+72     	; 0x7e92 <lround+0x5a>
    7e4a:	09 2e       	mov	r0, r25
    7e4c:	99 27       	eor	r25, r25
    7e4e:	66 0f       	add	r22, r22
    7e50:	77 1f       	adc	r23, r23
    7e52:	88 1f       	adc	r24, r24
    7e54:	99 1f       	adc	r25, r25
    7e56:	0a 94       	dec	r0
    7e58:	d1 f7       	brne	.-12     	; 0x7e4e <lround+0x16>
    7e5a:	12 c0       	rjmp	.+36     	; 0x7e80 <lround+0x48>
    7e5c:	06 2e       	mov	r0, r22
    7e5e:	67 2f       	mov	r22, r23
    7e60:	78 2f       	mov	r23, r24
    7e62:	88 27       	eor	r24, r24
    7e64:	98 5f       	subi	r25, 0xF8	; 248
    7e66:	11 f4       	brne	.+4      	; 0x7e6c <lround+0x34>
    7e68:	00 0c       	add	r0, r0
    7e6a:	07 c0       	rjmp	.+14     	; 0x7e7a <lround+0x42>
    7e6c:	99 3f       	cpi	r25, 0xF9	; 249
    7e6e:	b4 f3       	brlt	.-20     	; 0x7e5c <lround+0x24>
    7e70:	86 95       	lsr	r24
    7e72:	77 95       	ror	r23
    7e74:	67 95       	ror	r22
    7e76:	93 95       	inc	r25
    7e78:	d9 f7       	brne	.-10     	; 0x7e70 <lround+0x38>
    7e7a:	61 1d       	adc	r22, r1
    7e7c:	71 1d       	adc	r23, r1
    7e7e:	81 1d       	adc	r24, r1
    7e80:	3e f4       	brtc	.+14     	; 0x7e90 <lround+0x58>
    7e82:	90 95       	com	r25
    7e84:	80 95       	com	r24
    7e86:	70 95       	com	r23
    7e88:	61 95       	neg	r22
    7e8a:	7f 4f       	sbci	r23, 0xFF	; 255
    7e8c:	8f 4f       	sbci	r24, 0xFF	; 255
    7e8e:	9f 4f       	sbci	r25, 0xFF	; 255
    7e90:	08 95       	ret
    7e92:	68 94       	set
    7e94:	c0 cf       	rjmp	.-128    	; 0x7e16 <__fp_szero>
    7e96:	be cf       	rjmp	.-132    	; 0x7e14 <__fp_zero>

00007e98 <__mulsf3>:
    7e98:	0b d0       	rcall	.+22     	; 0x7eb0 <__mulsf3x>
    7e9a:	61 cf       	rjmp	.-318    	; 0x7d5e <__fp_round>
    7e9c:	2a df       	rcall	.-428    	; 0x7cf2 <__fp_pscA>
    7e9e:	28 f0       	brcs	.+10     	; 0x7eaa <__mulsf3+0x12>
    7ea0:	2f df       	rcall	.-418    	; 0x7d00 <__fp_pscB>
    7ea2:	18 f0       	brcs	.+6      	; 0x7eaa <__mulsf3+0x12>
    7ea4:	95 23       	and	r25, r21
    7ea6:	09 f0       	breq	.+2      	; 0x7eaa <__mulsf3+0x12>
    7ea8:	cd ce       	rjmp	.-614    	; 0x7c44 <__fp_inf>
    7eaa:	fb ce       	rjmp	.-522    	; 0x7ca2 <__fp_nan>
    7eac:	11 24       	eor	r1, r1
    7eae:	b3 cf       	rjmp	.-154    	; 0x7e16 <__fp_szero>

00007eb0 <__mulsf3x>:
    7eb0:	78 df       	rcall	.-272    	; 0x7da2 <__fp_split3>
    7eb2:	a0 f3       	brcs	.-24     	; 0x7e9c <__mulsf3+0x4>

00007eb4 <__mulsf3_pse>:
    7eb4:	95 9f       	mul	r25, r21
    7eb6:	d1 f3       	breq	.-12     	; 0x7eac <__mulsf3+0x14>
    7eb8:	95 0f       	add	r25, r21
    7eba:	50 e0       	ldi	r21, 0x00	; 0
    7ebc:	55 1f       	adc	r21, r21
    7ebe:	62 9f       	mul	r22, r18
    7ec0:	f0 01       	movw	r30, r0
    7ec2:	72 9f       	mul	r23, r18
    7ec4:	bb 27       	eor	r27, r27
    7ec6:	f0 0d       	add	r31, r0
    7ec8:	b1 1d       	adc	r27, r1
    7eca:	63 9f       	mul	r22, r19
    7ecc:	aa 27       	eor	r26, r26
    7ece:	f0 0d       	add	r31, r0
    7ed0:	b1 1d       	adc	r27, r1
    7ed2:	aa 1f       	adc	r26, r26
    7ed4:	64 9f       	mul	r22, r20
    7ed6:	66 27       	eor	r22, r22
    7ed8:	b0 0d       	add	r27, r0
    7eda:	a1 1d       	adc	r26, r1
    7edc:	66 1f       	adc	r22, r22
    7ede:	82 9f       	mul	r24, r18
    7ee0:	22 27       	eor	r18, r18
    7ee2:	b0 0d       	add	r27, r0
    7ee4:	a1 1d       	adc	r26, r1
    7ee6:	62 1f       	adc	r22, r18
    7ee8:	73 9f       	mul	r23, r19
    7eea:	b0 0d       	add	r27, r0
    7eec:	a1 1d       	adc	r26, r1
    7eee:	62 1f       	adc	r22, r18
    7ef0:	83 9f       	mul	r24, r19
    7ef2:	a0 0d       	add	r26, r0
    7ef4:	61 1d       	adc	r22, r1
    7ef6:	22 1f       	adc	r18, r18
    7ef8:	74 9f       	mul	r23, r20
    7efa:	33 27       	eor	r19, r19
    7efc:	a0 0d       	add	r26, r0
    7efe:	61 1d       	adc	r22, r1
    7f00:	23 1f       	adc	r18, r19
    7f02:	84 9f       	mul	r24, r20
    7f04:	60 0d       	add	r22, r0
    7f06:	21 1d       	adc	r18, r1
    7f08:	82 2f       	mov	r24, r18
    7f0a:	76 2f       	mov	r23, r22
    7f0c:	6a 2f       	mov	r22, r26
    7f0e:	11 24       	eor	r1, r1
    7f10:	9f 57       	subi	r25, 0x7F	; 127
    7f12:	50 40       	sbci	r21, 0x00	; 0
    7f14:	8a f0       	brmi	.+34     	; 0x7f38 <__mulsf3_pse+0x84>
    7f16:	e1 f0       	breq	.+56     	; 0x7f50 <__mulsf3_pse+0x9c>
    7f18:	88 23       	and	r24, r24
    7f1a:	4a f0       	brmi	.+18     	; 0x7f2e <__mulsf3_pse+0x7a>
    7f1c:	ee 0f       	add	r30, r30
    7f1e:	ff 1f       	adc	r31, r31
    7f20:	bb 1f       	adc	r27, r27
    7f22:	66 1f       	adc	r22, r22
    7f24:	77 1f       	adc	r23, r23
    7f26:	88 1f       	adc	r24, r24
    7f28:	91 50       	subi	r25, 0x01	; 1
    7f2a:	50 40       	sbci	r21, 0x00	; 0
    7f2c:	a9 f7       	brne	.-22     	; 0x7f18 <__mulsf3_pse+0x64>
    7f2e:	9e 3f       	cpi	r25, 0xFE	; 254
    7f30:	51 05       	cpc	r21, r1
    7f32:	70 f0       	brcs	.+28     	; 0x7f50 <__mulsf3_pse+0x9c>
    7f34:	87 ce       	rjmp	.-754    	; 0x7c44 <__fp_inf>
    7f36:	6f cf       	rjmp	.-290    	; 0x7e16 <__fp_szero>
    7f38:	5f 3f       	cpi	r21, 0xFF	; 255
    7f3a:	ec f3       	brlt	.-6      	; 0x7f36 <__mulsf3_pse+0x82>
    7f3c:	98 3e       	cpi	r25, 0xE8	; 232
    7f3e:	dc f3       	brlt	.-10     	; 0x7f36 <__mulsf3_pse+0x82>
    7f40:	86 95       	lsr	r24
    7f42:	77 95       	ror	r23
    7f44:	67 95       	ror	r22
    7f46:	b7 95       	ror	r27
    7f48:	f7 95       	ror	r31
    7f4a:	e7 95       	ror	r30
    7f4c:	9f 5f       	subi	r25, 0xFF	; 255
    7f4e:	c1 f7       	brne	.-16     	; 0x7f40 <__mulsf3_pse+0x8c>
    7f50:	fe 2b       	or	r31, r30
    7f52:	88 0f       	add	r24, r24
    7f54:	91 1d       	adc	r25, r1
    7f56:	96 95       	lsr	r25
    7f58:	87 95       	ror	r24
    7f5a:	97 f9       	bld	r25, 7
    7f5c:	08 95       	ret

00007f5e <round>:
    7f5e:	29 df       	rcall	.-430    	; 0x7db2 <__fp_splitA>
    7f60:	e0 f0       	brcs	.+56     	; 0x7f9a <round+0x3c>
    7f62:	9e 37       	cpi	r25, 0x7E	; 126
    7f64:	d8 f0       	brcs	.+54     	; 0x7f9c <round+0x3e>
    7f66:	96 39       	cpi	r25, 0x96	; 150
    7f68:	b8 f4       	brcc	.+46     	; 0x7f98 <round+0x3a>
    7f6a:	9e 38       	cpi	r25, 0x8E	; 142
    7f6c:	48 f4       	brcc	.+18     	; 0x7f80 <round+0x22>
    7f6e:	67 2f       	mov	r22, r23
    7f70:	78 2f       	mov	r23, r24
    7f72:	88 27       	eor	r24, r24
    7f74:	98 5f       	subi	r25, 0xF8	; 248
    7f76:	f9 cf       	rjmp	.-14     	; 0x7f6a <round+0xc>
    7f78:	86 95       	lsr	r24
    7f7a:	77 95       	ror	r23
    7f7c:	67 95       	ror	r22
    7f7e:	93 95       	inc	r25
    7f80:	95 39       	cpi	r25, 0x95	; 149
    7f82:	d0 f3       	brcs	.-12     	; 0x7f78 <round+0x1a>
    7f84:	b6 2f       	mov	r27, r22
    7f86:	b1 70       	andi	r27, 0x01	; 1
    7f88:	6b 0f       	add	r22, r27
    7f8a:	71 1d       	adc	r23, r1
    7f8c:	81 1d       	adc	r24, r1
    7f8e:	20 f4       	brcc	.+8      	; 0x7f98 <round+0x3a>
    7f90:	87 95       	ror	r24
    7f92:	77 95       	ror	r23
    7f94:	67 95       	ror	r22
    7f96:	93 95       	inc	r25
    7f98:	5b ce       	rjmp	.-842    	; 0x7c50 <__fp_mintl>
    7f9a:	75 ce       	rjmp	.-790    	; 0x7c86 <__fp_mpack>
    7f9c:	3c cf       	rjmp	.-392    	; 0x7e16 <__fp_szero>

00007f9e <sin>:
    7f9e:	9f 93       	push	r25
    7fa0:	b7 de       	rcall	.-658    	; 0x7d10 <__fp_rempio2>
    7fa2:	0f 90       	pop	r0
    7fa4:	07 fc       	sbrc	r0, 7
    7fa6:	ee 5f       	subi	r30, 0xFE	; 254
    7fa8:	eb ce       	rjmp	.-554    	; 0x7d80 <__fp_sinus>
    7faa:	11 f4       	brne	.+4      	; 0x7fb0 <sin+0x12>
    7fac:	0e f4       	brtc	.+2      	; 0x7fb0 <sin+0x12>
    7fae:	79 ce       	rjmp	.-782    	; 0x7ca2 <__fp_nan>
    7fb0:	6a ce       	rjmp	.-812    	; 0x7c86 <__fp_mpack>

00007fb2 <sqrt>:
    7fb2:	ff de       	rcall	.-514    	; 0x7db2 <__fp_splitA>
    7fb4:	d0 f3       	brcs	.-12     	; 0x7faa <sin+0xc>
    7fb6:	99 23       	and	r25, r25
    7fb8:	d9 f3       	breq	.-10     	; 0x7fb0 <sin+0x12>
    7fba:	ce f3       	brts	.-14     	; 0x7fae <sin+0x10>
    7fbc:	9f 57       	subi	r25, 0x7F	; 127
    7fbe:	55 0b       	sbc	r21, r21
    7fc0:	87 ff       	sbrs	r24, 7
    7fc2:	3f d0       	rcall	.+126    	; 0x8042 <__fp_norm2>
    7fc4:	00 24       	eor	r0, r0
    7fc6:	a0 e6       	ldi	r26, 0x60	; 96
    7fc8:	40 ea       	ldi	r20, 0xA0	; 160
    7fca:	90 01       	movw	r18, r0
    7fcc:	80 58       	subi	r24, 0x80	; 128
    7fce:	56 95       	lsr	r21
    7fd0:	97 95       	ror	r25
    7fd2:	28 f4       	brcc	.+10     	; 0x7fde <sqrt+0x2c>
    7fd4:	80 5c       	subi	r24, 0xC0	; 192
    7fd6:	66 0f       	add	r22, r22
    7fd8:	77 1f       	adc	r23, r23
    7fda:	88 1f       	adc	r24, r24
    7fdc:	20 f0       	brcs	.+8      	; 0x7fe6 <sqrt+0x34>
    7fde:	26 17       	cp	r18, r22
    7fe0:	37 07       	cpc	r19, r23
    7fe2:	48 07       	cpc	r20, r24
    7fe4:	30 f4       	brcc	.+12     	; 0x7ff2 <sqrt+0x40>
    7fe6:	62 1b       	sub	r22, r18
    7fe8:	73 0b       	sbc	r23, r19
    7fea:	84 0b       	sbc	r24, r20
    7fec:	20 29       	or	r18, r0
    7fee:	31 29       	or	r19, r1
    7ff0:	4a 2b       	or	r20, r26
    7ff2:	a6 95       	lsr	r26
    7ff4:	17 94       	ror	r1
    7ff6:	07 94       	ror	r0
    7ff8:	20 25       	eor	r18, r0
    7ffa:	31 25       	eor	r19, r1
    7ffc:	4a 27       	eor	r20, r26
    7ffe:	58 f7       	brcc	.-42     	; 0x7fd6 <sqrt+0x24>
    8000:	66 0f       	add	r22, r22
    8002:	77 1f       	adc	r23, r23
    8004:	88 1f       	adc	r24, r24
    8006:	20 f0       	brcs	.+8      	; 0x8010 <sqrt+0x5e>
    8008:	26 17       	cp	r18, r22
    800a:	37 07       	cpc	r19, r23
    800c:	48 07       	cpc	r20, r24
    800e:	30 f4       	brcc	.+12     	; 0x801c <sqrt+0x6a>
    8010:	62 0b       	sbc	r22, r18
    8012:	73 0b       	sbc	r23, r19
    8014:	84 0b       	sbc	r24, r20
    8016:	20 0d       	add	r18, r0
    8018:	31 1d       	adc	r19, r1
    801a:	41 1d       	adc	r20, r1
    801c:	a0 95       	com	r26
    801e:	81 f7       	brne	.-32     	; 0x8000 <sqrt+0x4e>
    8020:	b9 01       	movw	r22, r18
    8022:	84 2f       	mov	r24, r20
    8024:	91 58       	subi	r25, 0x81	; 129
    8026:	88 0f       	add	r24, r24
    8028:	96 95       	lsr	r25
    802a:	87 95       	ror	r24
    802c:	08 95       	ret

0000802e <square>:
    802e:	9b 01       	movw	r18, r22
    8030:	ac 01       	movw	r20, r24
    8032:	32 cf       	rjmp	.-412    	; 0x7e98 <__mulsf3>

00008034 <trunc>:
    8034:	d8 de       	rcall	.-592    	; 0x7de6 <__fp_trunc>
    8036:	20 f0       	brcs	.+8      	; 0x8040 <trunc+0xc>
    8038:	9f 37       	cpi	r25, 0x7F	; 127
    803a:	08 f4       	brcc	.+2      	; 0x803e <trunc+0xa>
    803c:	ec ce       	rjmp	.-552    	; 0x7e16 <__fp_szero>
    803e:	08 ce       	rjmp	.-1008   	; 0x7c50 <__fp_mintl>
    8040:	22 ce       	rjmp	.-956    	; 0x7c86 <__fp_mpack>

00008042 <__fp_norm2>:
    8042:	91 50       	subi	r25, 0x01	; 1
    8044:	50 40       	sbci	r21, 0x00	; 0
    8046:	66 0f       	add	r22, r22
    8048:	77 1f       	adc	r23, r23
    804a:	88 1f       	adc	r24, r24
    804c:	d2 f7       	brpl	.-12     	; 0x8042 <__fp_norm2>
    804e:	08 95       	ret

00008050 <__fp_powsodd>:
    8050:	9f 93       	push	r25
    8052:	8f 93       	push	r24
    8054:	7f 93       	push	r23
    8056:	6f 93       	push	r22
    8058:	ff 93       	push	r31
    805a:	ef 93       	push	r30
    805c:	9b 01       	movw	r18, r22
    805e:	ac 01       	movw	r20, r24
    8060:	1b df       	rcall	.-458    	; 0x7e98 <__mulsf3>
    8062:	ef 91       	pop	r30
    8064:	ff 91       	pop	r31
    8066:	20 de       	rcall	.-960    	; 0x7ca8 <__fp_powser>
    8068:	2f 91       	pop	r18
    806a:	3f 91       	pop	r19
    806c:	4f 91       	pop	r20
    806e:	5f 91       	pop	r21
    8070:	13 cf       	rjmp	.-474    	; 0x7e98 <__mulsf3>

00008072 <__udivmodsi4>:
    8072:	a1 e2       	ldi	r26, 0x21	; 33
    8074:	1a 2e       	mov	r1, r26
    8076:	aa 1b       	sub	r26, r26
    8078:	bb 1b       	sub	r27, r27
    807a:	fd 01       	movw	r30, r26
    807c:	0d c0       	rjmp	.+26     	; 0x8098 <__udivmodsi4_ep>

0000807e <__udivmodsi4_loop>:
    807e:	aa 1f       	adc	r26, r26
    8080:	bb 1f       	adc	r27, r27
    8082:	ee 1f       	adc	r30, r30
    8084:	ff 1f       	adc	r31, r31
    8086:	a2 17       	cp	r26, r18
    8088:	b3 07       	cpc	r27, r19
    808a:	e4 07       	cpc	r30, r20
    808c:	f5 07       	cpc	r31, r21
    808e:	20 f0       	brcs	.+8      	; 0x8098 <__udivmodsi4_ep>
    8090:	a2 1b       	sub	r26, r18
    8092:	b3 0b       	sbc	r27, r19
    8094:	e4 0b       	sbc	r30, r20
    8096:	f5 0b       	sbc	r31, r21

00008098 <__udivmodsi4_ep>:
    8098:	66 1f       	adc	r22, r22
    809a:	77 1f       	adc	r23, r23
    809c:	88 1f       	adc	r24, r24
    809e:	99 1f       	adc	r25, r25
    80a0:	1a 94       	dec	r1
    80a2:	69 f7       	brne	.-38     	; 0x807e <__udivmodsi4_loop>
    80a4:	60 95       	com	r22
    80a6:	70 95       	com	r23
    80a8:	80 95       	com	r24
    80aa:	90 95       	com	r25
    80ac:	9b 01       	movw	r18, r22
    80ae:	ac 01       	movw	r20, r24
    80b0:	bd 01       	movw	r22, r26
    80b2:	cf 01       	movw	r24, r30
    80b4:	08 95       	ret

000080b6 <__tablejump2__>:
    80b6:	ee 0f       	add	r30, r30
    80b8:	ff 1f       	adc	r31, r31
    80ba:	88 1f       	adc	r24, r24
    80bc:	8b bf       	out	0x3b, r24	; 59
    80be:	07 90       	elpm	r0, Z+
    80c0:	f6 91       	elpm	r31, Z
    80c2:	e0 2d       	mov	r30, r0
    80c4:	19 94       	eijmp

000080c6 <__umulhisi3>:
    80c6:	a2 9f       	mul	r26, r18
    80c8:	b0 01       	movw	r22, r0
    80ca:	b3 9f       	mul	r27, r19
    80cc:	c0 01       	movw	r24, r0
    80ce:	a3 9f       	mul	r26, r19
    80d0:	70 0d       	add	r23, r0
    80d2:	81 1d       	adc	r24, r1
    80d4:	11 24       	eor	r1, r1
    80d6:	91 1d       	adc	r25, r1
    80d8:	b2 9f       	mul	r27, r18
    80da:	70 0d       	add	r23, r0
    80dc:	81 1d       	adc	r24, r1
    80de:	11 24       	eor	r1, r1
    80e0:	91 1d       	adc	r25, r1
    80e2:	08 95       	ret

000080e4 <memcmp>:
    80e4:	fb 01       	movw	r30, r22
    80e6:	dc 01       	movw	r26, r24
    80e8:	04 c0       	rjmp	.+8      	; 0x80f2 <memcmp+0xe>
    80ea:	8d 91       	ld	r24, X+
    80ec:	01 90       	ld	r0, Z+
    80ee:	80 19       	sub	r24, r0
    80f0:	21 f4       	brne	.+8      	; 0x80fa <memcmp+0x16>
    80f2:	41 50       	subi	r20, 0x01	; 1
    80f4:	50 40       	sbci	r21, 0x00	; 0
    80f6:	c8 f7       	brcc	.-14     	; 0x80ea <memcmp+0x6>
    80f8:	88 1b       	sub	r24, r24
    80fa:	99 0b       	sbc	r25, r25
    80fc:	08 95       	ret

000080fe <_exit>:
    80fe:	f8 94       	cli

00008100 <__stop_program>:
    8100:	ff cf       	rjmp	.-2      	; 0x8100 <__stop_program>
